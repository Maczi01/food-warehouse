{"ast":null,"code":"var _classCallCheck = require(\"C:\\\\Users\\\\Admin\\\\Desktop\\\\react1\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Admin\\\\Desktop\\\\react1\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\n// Generated by CoffeeScript 2.4.1\n(function () {\n  var DocumentPosition,\n      NodeType,\n      XMLCData,\n      XMLComment,\n      XMLDeclaration,\n      XMLDocType,\n      XMLDummy,\n      XMLElement,\n      XMLNamedNodeMap,\n      XMLNode,\n      XMLNodeList,\n      XMLProcessingInstruction,\n      XMLRaw,\n      XMLText,\n      getValue,\n      isEmpty,\n      isFunction,\n      isObject,\n      hasProp = {}.hasOwnProperty,\n      splice = [].splice;\n\n  var _require = require('./Utility');\n\n  isObject = _require.isObject;\n  isFunction = _require.isFunction;\n  isEmpty = _require.isEmpty;\n  getValue = _require.getValue;\n  XMLElement = null;\n  XMLCData = null;\n  XMLComment = null;\n  XMLDeclaration = null;\n  XMLDocType = null;\n  XMLRaw = null;\n  XMLText = null;\n  XMLProcessingInstruction = null;\n  XMLDummy = null;\n  NodeType = null;\n  XMLNodeList = null;\n  XMLNamedNodeMap = null;\n  DocumentPosition = null; // Represents a generic XMl element\n\n  module.exports = XMLNode = function () {\n    var XMLNode = /*#__PURE__*/function () {\n      \"use strict\";\n\n      // Initializes a new instance of `XMLNode`\n      // `parent` the parent node\n      function XMLNode(parent1) {\n        _classCallCheck(this, XMLNode);\n\n        this.parent = parent1;\n\n        if (this.parent) {\n          this.options = this.parent.options;\n          this.stringify = this.parent.stringify;\n        }\n\n        this.value = null;\n        this.children = [];\n        this.baseURI = null; // first execution, load dependencies that are otherwise\n        // circular (so we can't load them at the top)\n\n        if (!XMLElement) {\n          XMLElement = require('./XMLElement');\n          XMLCData = require('./XMLCData');\n          XMLComment = require('./XMLComment');\n          XMLDeclaration = require('./XMLDeclaration');\n          XMLDocType = require('./XMLDocType');\n          XMLRaw = require('./XMLRaw');\n          XMLText = require('./XMLText');\n          XMLProcessingInstruction = require('./XMLProcessingInstruction');\n          XMLDummy = require('./XMLDummy');\n          NodeType = require('./NodeType');\n          XMLNodeList = require('./XMLNodeList');\n          XMLNamedNodeMap = require('./XMLNamedNodeMap');\n          DocumentPosition = require('./DocumentPosition');\n        }\n      } // Sets the parent node of this node and its children recursively\n      // `parent` the parent node\n\n\n      _createClass(XMLNode, [{\n        key: \"setParent\",\n        value: function setParent(parent) {\n          var child, j, len, ref1, results;\n          this.parent = parent;\n\n          if (parent) {\n            this.options = parent.options;\n            this.stringify = parent.stringify;\n          }\n\n          ref1 = this.children;\n          results = [];\n\n          for (j = 0, len = ref1.length; j < len; j++) {\n            child = ref1[j];\n            results.push(child.setParent(this));\n          }\n\n          return results;\n        } // Creates a child element node\n        // `name` node name or an object describing the XML tree\n        // `attributes` an object containing name/value pairs of attributes\n        // `text` element text\n\n      }, {\n        key: \"element\",\n        value: function element(name, attributes, text) {\n          var childNode, item, j, k, key, lastChild, len, len1, val;\n          lastChild = null;\n\n          if (attributes === null && text == null) {\n            attributes = {};\n            text = null;\n          }\n\n          if (attributes == null) {\n            attributes = {};\n          }\n\n          attributes = getValue(attributes); // swap argument order: text <-> attributes\n\n          if (!isObject(attributes)) {\n            var _ref = [attributes, text];\n            text = _ref[0];\n            attributes = _ref[1];\n          }\n\n          if (name != null) {\n            name = getValue(name);\n          } // expand if array\n\n\n          if (Array.isArray(name)) {\n            for (j = 0, len = name.length; j < len; j++) {\n              item = name[j];\n              lastChild = this.element(item);\n            } // evaluate if function\n\n          } else if (isFunction(name)) {\n            lastChild = this.element(name.apply()); // expand if object\n          } else if (isObject(name)) {\n            for (key in name) {\n              if (!hasProp.call(name, key)) continue;\n              val = name[key];\n\n              if (isFunction(val)) {\n                // evaluate if function\n                val = val.apply();\n              } // assign attributes\n\n\n              if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {\n                lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val); // skip empty arrays\n              } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {\n                lastChild = this.dummy(); // empty objects produce one node\n              } else if (isObject(val) && isEmpty(val)) {\n                lastChild = this.element(key); // skip null and undefined nodes\n              } else if (!this.options.keepNullNodes && val == null) {\n                lastChild = this.dummy(); // expand list by creating child nodes\n              } else if (!this.options.separateArrayItems && Array.isArray(val)) {\n                for (k = 0, len1 = val.length; k < len1; k++) {\n                  item = val[k];\n                  childNode = {};\n                  childNode[key] = item;\n                  lastChild = this.element(childNode);\n                } // expand child nodes under parent\n\n              } else if (isObject(val)) {\n                // if the key is #text expand child nodes under this node to support mixed content\n                if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {\n                  lastChild = this.element(val);\n                } else {\n                  lastChild = this.element(key);\n                  lastChild.element(val);\n                }\n              } else {\n                // text node\n                lastChild = this.element(key, val);\n              }\n            } // skip null nodes\n\n          } else if (!this.options.keepNullNodes && text === null) {\n            lastChild = this.dummy();\n          } else {\n            // text node\n            if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {\n              lastChild = this.text(text); // cdata node\n            } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {\n              lastChild = this.cdata(text); // comment node\n            } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {\n              lastChild = this.comment(text); // raw text node\n            } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {\n              lastChild = this.raw(text); // processing instruction\n            } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {\n              lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);\n            } else {\n              // element node\n              lastChild = this.node(name, attributes, text);\n            }\n          }\n\n          if (lastChild == null) {\n            throw new Error(\"Could not create any elements with: \" + name + \". \" + this.debugInfo());\n          }\n\n          return lastChild;\n        } // Creates a child element node before the current node\n        // `name` node name or an object describing the XML tree\n        // `attributes` an object containing name/value pairs of attributes\n        // `text` element text\n\n      }, {\n        key: \"insertBefore\",\n        value: function insertBefore(name, attributes, text) {\n          var child, i, newChild, refChild, removed; // DOM level 1\n          // insertBefore(newChild, refChild) inserts the child node newChild before refChild\n\n          if (name != null ? name.type : void 0) {\n            newChild = name;\n            refChild = attributes;\n            newChild.setParent(this);\n\n            if (refChild) {\n              // temporarily remove children starting *with* refChild\n              i = children.indexOf(refChild);\n              removed = children.splice(i); // add the new child\n\n              children.push(newChild); // add back removed children after new child\n\n              Array.prototype.push.apply(children, removed);\n            } else {\n              children.push(newChild);\n            }\n\n            return newChild;\n          } else {\n            if (this.isRoot) {\n              throw new Error(\"Cannot insert elements at root level. \" + this.debugInfo(name));\n            } // temporarily remove children starting *with* this\n\n\n            i = this.parent.children.indexOf(this);\n            removed = this.parent.children.splice(i); // add the new child\n\n            child = this.parent.element(name, attributes, text); // add back removed children after new child\n\n            Array.prototype.push.apply(this.parent.children, removed);\n            return child;\n          }\n        } // Creates a child element node after the current node\n        // `name` node name or an object describing the XML tree\n        // `attributes` an object containing name/value pairs of attributes\n        // `text` element text\n\n      }, {\n        key: \"insertAfter\",\n        value: function insertAfter(name, attributes, text) {\n          var child, i, removed;\n\n          if (this.isRoot) {\n            throw new Error(\"Cannot insert elements at root level. \" + this.debugInfo(name));\n          } // temporarily remove children starting *after* this\n\n\n          i = this.parent.children.indexOf(this);\n          removed = this.parent.children.splice(i + 1); // add the new child\n\n          child = this.parent.element(name, attributes, text); // add back removed children after new child\n\n          Array.prototype.push.apply(this.parent.children, removed);\n          return child;\n        } // Deletes a child element node\n\n      }, {\n        key: \"remove\",\n        value: function remove() {\n          var i, ref1;\n\n          if (this.isRoot) {\n            throw new Error(\"Cannot remove the root element. \" + this.debugInfo());\n          }\n\n          i = this.parent.children.indexOf(this);\n          splice.apply(this.parent.children, [i, i - i + 1].concat(ref1 = [])), ref1;\n          return this.parent;\n        } // Creates a node\n        // `name` name of the node\n        // `attributes` an object containing name/value pairs of attributes\n        // `text` element text\n\n      }, {\n        key: \"node\",\n        value: function node(name, attributes, text) {\n          var child;\n\n          if (name != null) {\n            name = getValue(name);\n          }\n\n          attributes || (attributes = {});\n          attributes = getValue(attributes); // swap argument order: text <-> attributes\n\n          if (!isObject(attributes)) {\n            var _ref2 = [attributes, text];\n            text = _ref2[0];\n            attributes = _ref2[1];\n          }\n\n          child = new XMLElement(this, name, attributes);\n\n          if (text != null) {\n            child.text(text);\n          }\n\n          this.children.push(child);\n          return child;\n        } // Creates a text node\n        // `value` element text\n\n      }, {\n        key: \"text\",\n        value: function text(value) {\n          var child;\n\n          if (isObject(value)) {\n            this.element(value);\n          }\n\n          child = new XMLText(this, value);\n          this.children.push(child);\n          return this;\n        } // Creates a CDATA node\n        // `value` element text without CDATA delimiters\n\n      }, {\n        key: \"cdata\",\n        value: function cdata(value) {\n          var child;\n          child = new XMLCData(this, value);\n          this.children.push(child);\n          return this;\n        } // Creates a comment node\n        // `value` comment text\n\n      }, {\n        key: \"comment\",\n        value: function comment(value) {\n          var child;\n          child = new XMLComment(this, value);\n          this.children.push(child);\n          return this;\n        } // Creates a comment node before the current node\n        // `value` comment text\n\n      }, {\n        key: \"commentBefore\",\n        value: function commentBefore(value) {\n          var child, i, removed; // temporarily remove children starting *with* this\n\n          i = this.parent.children.indexOf(this);\n          removed = this.parent.children.splice(i); // add the new child\n\n          child = this.parent.comment(value); // add back removed children after new child\n\n          Array.prototype.push.apply(this.parent.children, removed);\n          return this;\n        } // Creates a comment node after the current node\n        // `value` comment text\n\n      }, {\n        key: \"commentAfter\",\n        value: function commentAfter(value) {\n          var child, i, removed; // temporarily remove children starting *after* this\n\n          i = this.parent.children.indexOf(this);\n          removed = this.parent.children.splice(i + 1); // add the new child\n\n          child = this.parent.comment(value); // add back removed children after new child\n\n          Array.prototype.push.apply(this.parent.children, removed);\n          return this;\n        } // Adds unescaped raw text\n        // `value` text\n\n      }, {\n        key: \"raw\",\n        value: function raw(value) {\n          var child;\n          child = new XMLRaw(this, value);\n          this.children.push(child);\n          return this;\n        } // Adds a dummy node\n\n      }, {\n        key: \"dummy\",\n        value: function dummy() {\n          var child;\n          child = new XMLDummy(this); // Normally when a new node is created it is added to the child node collection.\n          // However, dummy nodes are never added to the XML tree. They are created while\n          // converting JS objects to XML nodes in order not to break the recursive function\n          // chain. They can be thought of as invisible nodes. They can be traversed through\n          // by using prev(), next(), up(), etc. functions but they do not exists in the tree.\n          // @children.push child\n\n          return child;\n        } // Adds a processing instruction\n        // `target` instruction target\n        // `value` instruction value\n\n      }, {\n        key: \"instruction\",\n        value: function instruction(target, value) {\n          var insTarget, insValue, instruction, j, len;\n\n          if (target != null) {\n            target = getValue(target);\n          }\n\n          if (value != null) {\n            value = getValue(value);\n          }\n\n          if (Array.isArray(target)) {\n            // expand if array\n            for (j = 0, len = target.length; j < len; j++) {\n              insTarget = target[j];\n              this.instruction(insTarget);\n            }\n          } else if (isObject(target)) {\n            // expand if object\n            for (insTarget in target) {\n              if (!hasProp.call(target, insTarget)) continue;\n              insValue = target[insTarget];\n              this.instruction(insTarget, insValue);\n            }\n          } else {\n            if (isFunction(value)) {\n              value = value.apply();\n            }\n\n            instruction = new XMLProcessingInstruction(this, target, value);\n            this.children.push(instruction);\n          }\n\n          return this;\n        } // Creates a processing instruction node before the current node\n        // `target` instruction target\n        // `value` instruction value\n\n      }, {\n        key: \"instructionBefore\",\n        value: function instructionBefore(target, value) {\n          var child, i, removed; // temporarily remove children starting *with* this\n\n          i = this.parent.children.indexOf(this);\n          removed = this.parent.children.splice(i); // add the new child\n\n          child = this.parent.instruction(target, value); // add back removed children after new child\n\n          Array.prototype.push.apply(this.parent.children, removed);\n          return this;\n        } // Creates a processing instruction node after the current node\n        // `target` instruction target\n        // `value` instruction value\n\n      }, {\n        key: \"instructionAfter\",\n        value: function instructionAfter(target, value) {\n          var child, i, removed; // temporarily remove children starting *after* this\n\n          i = this.parent.children.indexOf(this);\n          removed = this.parent.children.splice(i + 1); // add the new child\n\n          child = this.parent.instruction(target, value); // add back removed children after new child\n\n          Array.prototype.push.apply(this.parent.children, removed);\n          return this;\n        } // Creates the xml declaration\n        // `version` A version number string, e.g. 1.0\n        // `encoding` Encoding declaration, e.g. UTF-8\n        // `standalone` standalone document declaration: true or false\n\n      }, {\n        key: \"declaration\",\n        value: function declaration(version, encoding, standalone) {\n          var doc, xmldec;\n          doc = this.document();\n          xmldec = new XMLDeclaration(doc, version, encoding, standalone); // Replace XML declaration if exists, otherwise insert at top\n\n          if (doc.children.length === 0) {\n            doc.children.unshift(xmldec);\n          } else if (doc.children[0].type === NodeType.Declaration) {\n            doc.children[0] = xmldec;\n          } else {\n            doc.children.unshift(xmldec);\n          }\n\n          return doc.root() || doc;\n        } // Creates the document type declaration\n        // `pubID` the public identifier of the external subset\n        // `sysID` the system identifier of the external subset\n\n      }, {\n        key: \"dtd\",\n        value: function dtd(pubID, sysID) {\n          var child, doc, doctype, i, j, k, len, len1, ref1, ref2;\n          doc = this.document();\n          doctype = new XMLDocType(doc, pubID, sysID);\n          ref1 = doc.children; // Replace DTD if exists\n\n          for (i = j = 0, len = ref1.length; j < len; i = ++j) {\n            child = ref1[i];\n\n            if (child.type === NodeType.DocType) {\n              doc.children[i] = doctype;\n              return doctype;\n            }\n          }\n\n          ref2 = doc.children; // insert before root node if the root node exists\n\n          for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {\n            child = ref2[i];\n\n            if (child.isRoot) {\n              doc.children.splice(i, 0, doctype);\n              return doctype;\n            }\n          } // otherwise append to end\n\n\n          doc.children.push(doctype);\n          return doctype;\n        } // Gets the parent node\n\n      }, {\n        key: \"up\",\n        value: function up() {\n          if (this.isRoot) {\n            throw new Error(\"The root node has no parent. Use doc() if you need to get the document object.\");\n          }\n\n          return this.parent;\n        } // Gets the root node\n\n      }, {\n        key: \"root\",\n        value: function root() {\n          var node;\n          node = this;\n\n          while (node) {\n            if (node.type === NodeType.Document) {\n              return node.rootObject;\n            } else if (node.isRoot) {\n              return node;\n            } else {\n              node = node.parent;\n            }\n          }\n        } // Gets the node representing the XML document\n\n      }, {\n        key: \"document\",\n        value: function document() {\n          var node;\n          node = this;\n\n          while (node) {\n            if (node.type === NodeType.Document) {\n              return node;\n            } else {\n              node = node.parent;\n            }\n          }\n        } // Ends the document and converts string\n\n      }, {\n        key: \"end\",\n        value: function end(options) {\n          return this.document().end(options);\n        } // Gets the previous node\n\n      }, {\n        key: \"prev\",\n        value: function prev() {\n          var i;\n          i = this.parent.children.indexOf(this);\n\n          if (i < 1) {\n            throw new Error(\"Already at the first node. \" + this.debugInfo());\n          }\n\n          return this.parent.children[i - 1];\n        } // Gets the next node\n\n      }, {\n        key: \"next\",\n        value: function next() {\n          var i;\n          i = this.parent.children.indexOf(this);\n\n          if (i === -1 || i === this.parent.children.length - 1) {\n            throw new Error(\"Already at the last node. \" + this.debugInfo());\n          }\n\n          return this.parent.children[i + 1];\n        } // Imports cloned root from another XML document\n        // `doc` the XML document to insert nodes from\n\n      }, {\n        key: \"importDocument\",\n        value: function importDocument(doc) {\n          var child, clonedRoot, j, len, ref1;\n          clonedRoot = doc.root().clone();\n          clonedRoot.parent = this;\n          clonedRoot.isRoot = false;\n          this.children.push(clonedRoot); // set properties if imported element becomes the root node\n\n          if (this.type === NodeType.Document) {\n            clonedRoot.isRoot = true;\n            clonedRoot.documentObject = this;\n            this.rootObject = clonedRoot; // set dtd name\n\n            if (this.children) {\n              ref1 = this.children;\n\n              for (j = 0, len = ref1.length; j < len; j++) {\n                child = ref1[j];\n\n                if (child.type === NodeType.DocType) {\n                  child.name = clonedRoot.name;\n                  break;\n                }\n              }\n            }\n          }\n\n          return this;\n        } // Returns debug string for this node\n\n      }, {\n        key: \"debugInfo\",\n        value: function debugInfo(name) {\n          var ref1, ref2;\n          name = name || this.name;\n\n          if (name == null && !((ref1 = this.parent) != null ? ref1.name : void 0)) {\n            return \"\";\n          } else if (name == null) {\n            return \"parent: <\" + this.parent.name + \">\";\n          } else if (!((ref2 = this.parent) != null ? ref2.name : void 0)) {\n            return \"node: <\" + name + \">\";\n          } else {\n            return \"node: <\" + name + \">, parent: <\" + this.parent.name + \">\";\n          }\n        } // Aliases\n\n      }, {\n        key: \"ele\",\n        value: function ele(name, attributes, text) {\n          return this.element(name, attributes, text);\n        }\n      }, {\n        key: \"nod\",\n        value: function nod(name, attributes, text) {\n          return this.node(name, attributes, text);\n        }\n      }, {\n        key: \"txt\",\n        value: function txt(value) {\n          return this.text(value);\n        }\n      }, {\n        key: \"dat\",\n        value: function dat(value) {\n          return this.cdata(value);\n        }\n      }, {\n        key: \"com\",\n        value: function com(value) {\n          return this.comment(value);\n        }\n      }, {\n        key: \"ins\",\n        value: function ins(target, value) {\n          return this.instruction(target, value);\n        }\n      }, {\n        key: \"doc\",\n        value: function doc() {\n          return this.document();\n        }\n      }, {\n        key: \"dec\",\n        value: function dec(version, encoding, standalone) {\n          return this.declaration(version, encoding, standalone);\n        }\n      }, {\n        key: \"e\",\n        value: function e(name, attributes, text) {\n          return this.element(name, attributes, text);\n        }\n      }, {\n        key: \"n\",\n        value: function n(name, attributes, text) {\n          return this.node(name, attributes, text);\n        }\n      }, {\n        key: \"t\",\n        value: function t(value) {\n          return this.text(value);\n        }\n      }, {\n        key: \"d\",\n        value: function d(value) {\n          return this.cdata(value);\n        }\n      }, {\n        key: \"c\",\n        value: function c(value) {\n          return this.comment(value);\n        }\n      }, {\n        key: \"r\",\n        value: function r(value) {\n          return this.raw(value);\n        }\n      }, {\n        key: \"i\",\n        value: function i(target, value) {\n          return this.instruction(target, value);\n        }\n      }, {\n        key: \"u\",\n        value: function u() {\n          return this.up();\n        } // can be deprecated in a future release\n\n      }, {\n        key: \"importXMLBuilder\",\n        value: function importXMLBuilder(doc) {\n          return this.importDocument(doc);\n        } // Adds or modifies an attribute.\n        // `name` attribute name\n        // `value` attribute value\n\n      }, {\n        key: \"attribute\",\n        value: function attribute(name, value) {\n          throw new Error(\"attribute() applies to element nodes only.\");\n        }\n      }, {\n        key: \"att\",\n        value: function att(name, value) {\n          return this.attribute(name, value);\n        }\n      }, {\n        key: \"a\",\n        value: function a(name, value) {\n          return this.attribute(name, value);\n        } // Removes an attribute\n        // `name` attribute name\n\n      }, {\n        key: \"removeAttribute\",\n        value: function removeAttribute(name) {\n          throw new Error(\"attribute() applies to element nodes only.\");\n        } // DOM level 1 functions to be implemented later\n\n      }, {\n        key: \"replaceChild\",\n        value: function replaceChild(newChild, oldChild) {\n          throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n        }\n      }, {\n        key: \"removeChild\",\n        value: function removeChild(oldChild) {\n          throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n        }\n      }, {\n        key: \"appendChild\",\n        value: function appendChild(newChild) {\n          throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n        }\n      }, {\n        key: \"hasChildNodes\",\n        value: function hasChildNodes() {\n          return this.children.length !== 0;\n        }\n      }, {\n        key: \"cloneNode\",\n        value: function cloneNode(deep) {\n          throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n        }\n      }, {\n        key: \"normalize\",\n        value: function normalize() {\n          throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n        } // DOM level 2\n\n      }, {\n        key: \"isSupported\",\n        value: function isSupported(feature, version) {\n          return true;\n        }\n      }, {\n        key: \"hasAttributes\",\n        value: function hasAttributes() {\n          return this.attribs.length !== 0;\n        } // DOM level 3 functions to be implemented later\n\n      }, {\n        key: \"compareDocumentPosition\",\n        value: function compareDocumentPosition(other) {\n          var ref, res;\n          ref = this;\n\n          if (ref === other) {\n            return 0;\n          } else if (this.document() !== other.document()) {\n            res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;\n\n            if (Math.random() < 0.5) {\n              res |= DocumentPosition.Preceding;\n            } else {\n              res |= DocumentPosition.Following;\n            }\n\n            return res;\n          } else if (ref.isAncestor(other)) {\n            return DocumentPosition.Contains | DocumentPosition.Preceding;\n          } else if (ref.isDescendant(other)) {\n            return DocumentPosition.Contains | DocumentPosition.Following;\n          } else if (ref.isPreceding(other)) {\n            return DocumentPosition.Preceding;\n          } else {\n            return DocumentPosition.Following;\n          }\n        }\n      }, {\n        key: \"isSameNode\",\n        value: function isSameNode(other) {\n          throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n        }\n      }, {\n        key: \"lookupPrefix\",\n        value: function lookupPrefix(namespaceURI) {\n          throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n        }\n      }, {\n        key: \"isDefaultNamespace\",\n        value: function isDefaultNamespace(namespaceURI) {\n          throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n        }\n      }, {\n        key: \"lookupNamespaceURI\",\n        value: function lookupNamespaceURI(prefix) {\n          throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n        }\n      }, {\n        key: \"isEqualNode\",\n        value: function isEqualNode(node) {\n          var i, j, ref1;\n\n          if (node.nodeType !== this.nodeType) {\n            return false;\n          }\n\n          if (node.children.length !== this.children.length) {\n            return false;\n          }\n\n          for (i = j = 0, ref1 = this.children.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {\n            if (!this.children[i].isEqualNode(node.children[i])) {\n              return false;\n            }\n          }\n\n          return true;\n        }\n      }, {\n        key: \"getFeature\",\n        value: function getFeature(feature, version) {\n          throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n        }\n      }, {\n        key: \"setUserData\",\n        value: function setUserData(key, data, handler) {\n          throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n        }\n      }, {\n        key: \"getUserData\",\n        value: function getUserData(key) {\n          throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n        } // Returns true if other is an inclusive descendant of node,\n        // and false otherwise.\n\n      }, {\n        key: \"contains\",\n        value: function contains(other) {\n          if (!other) {\n            return false;\n          }\n\n          return other === this || this.isDescendant(other);\n        } // An object A is called a descendant of an object B, if either A is \n        // a child of B or A is a child of an object C that is a descendant of B.\n\n      }, {\n        key: \"isDescendant\",\n        value: function isDescendant(node) {\n          var child, isDescendantChild, j, len, ref1;\n          ref1 = this.children;\n\n          for (j = 0, len = ref1.length; j < len; j++) {\n            child = ref1[j];\n\n            if (node === child) {\n              return true;\n            }\n\n            isDescendantChild = child.isDescendant(node);\n\n            if (isDescendantChild) {\n              return true;\n            }\n          }\n\n          return false;\n        } // An object A is called an ancestor of an object B if and only if\n        // B is a descendant of A.\n\n      }, {\n        key: \"isAncestor\",\n        value: function isAncestor(node) {\n          return node.isDescendant(this);\n        } // An object A is preceding an object B if A and B are in the \n        // same tree and A comes before B in tree order.\n\n      }, {\n        key: \"isPreceding\",\n        value: function isPreceding(node) {\n          var nodePos, thisPos;\n          nodePos = this.treePosition(node);\n          thisPos = this.treePosition(this);\n\n          if (nodePos === -1 || thisPos === -1) {\n            return false;\n          } else {\n            return nodePos < thisPos;\n          }\n        } // An object A is folllowing an object B if A and B are in the \n        // same tree and A comes after B in tree order.\n\n      }, {\n        key: \"isFollowing\",\n        value: function isFollowing(node) {\n          var nodePos, thisPos;\n          nodePos = this.treePosition(node);\n          thisPos = this.treePosition(this);\n\n          if (nodePos === -1 || thisPos === -1) {\n            return false;\n          } else {\n            return nodePos > thisPos;\n          }\n        } // Returns the preorder position of the given node in the tree, or -1\n        // if the node is not in the tree.\n\n      }, {\n        key: \"treePosition\",\n        value: function treePosition(node) {\n          var found, pos;\n          pos = 0;\n          found = false;\n          this.foreachTreeNode(this.document(), function (childNode) {\n            pos++;\n\n            if (!found && childNode === node) {\n              return found = true;\n            }\n          });\n\n          if (found) {\n            return pos;\n          } else {\n            return -1;\n          }\n        } // Depth-first preorder traversal through the XML tree\n\n      }, {\n        key: \"foreachTreeNode\",\n        value: function foreachTreeNode(node, func) {\n          var child, j, len, ref1, res;\n          node || (node = this.document());\n          ref1 = node.children;\n\n          for (j = 0, len = ref1.length; j < len; j++) {\n            child = ref1[j];\n\n            if (res = func(child)) {\n              return res;\n            } else {\n              res = this.foreachTreeNode(child, func);\n\n              if (res) {\n                return res;\n              }\n            }\n          }\n        }\n      }]);\n\n      return XMLNode;\n    }();\n\n    ; // DOM level 1\n\n    Object.defineProperty(XMLNode.prototype, 'nodeName', {\n      get: function get() {\n        return this.name;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'nodeType', {\n      get: function get() {\n        return this.type;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'nodeValue', {\n      get: function get() {\n        return this.value;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'parentNode', {\n      get: function get() {\n        return this.parent;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'childNodes', {\n      get: function get() {\n        if (!this.childNodeList || !this.childNodeList.nodes) {\n          this.childNodeList = new XMLNodeList(this.children);\n        }\n\n        return this.childNodeList;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'firstChild', {\n      get: function get() {\n        return this.children[0] || null;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'lastChild', {\n      get: function get() {\n        return this.children[this.children.length - 1] || null;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'previousSibling', {\n      get: function get() {\n        var i;\n        i = this.parent.children.indexOf(this);\n        return this.parent.children[i - 1] || null;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'nextSibling', {\n      get: function get() {\n        var i;\n        i = this.parent.children.indexOf(this);\n        return this.parent.children[i + 1] || null;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'ownerDocument', {\n      get: function get() {\n        return this.document() || null;\n      }\n    }); // DOM level 3\n\n    Object.defineProperty(XMLNode.prototype, 'textContent', {\n      get: function get() {\n        var child, j, len, ref1, str;\n\n        if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {\n          str = '';\n          ref1 = this.children;\n\n          for (j = 0, len = ref1.length; j < len; j++) {\n            child = ref1[j];\n\n            if (child.textContent) {\n              str += child.textContent;\n            }\n          }\n\n          return str;\n        } else {\n          return null;\n        }\n      },\n      set: function set(value) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n    });\n    return XMLNode;\n  }.call(this);\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}