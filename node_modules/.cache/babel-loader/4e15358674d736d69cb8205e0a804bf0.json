{"ast":null,"code":"/**\n * @author      Created by Marcus Spiegel <marcus.spiegel@gmail.com> on 2011-03-25.\n * @link        https://github.com/mashpie/i18n-node\n * @license     http://opensource.org/licenses/MIT\n *\n * @version     0.8.3\n */\n'use strict'; // dependencies\n\nvar vsprintf = require('sprintf-js').vsprintf,\n    fs = require('fs'),\n    url = require('url'),\n    path = require('path'),\n    debug = require('debug')('i18n:debug'),\n    warn = require('debug')('i18n:warn'),\n    error = require('debug')('i18n:error'),\n    Mustache = require('mustache'),\n    Messageformat = require('messageformat'),\n    MakePlural = require('make-plural'),\n    parseInterval = require('math-interval-parser').default; // exports an instance\n\n\nmodule.exports = function () {\n  var MessageformatInstanceForLocale = {},\n      PluralsForLocale = {},\n      locales = {},\n      api = {\n    '__': '__',\n    '__n': '__n',\n    '__l': '__l',\n    '__h': '__h',\n    '__mf': '__mf',\n    'getLocale': 'getLocale',\n    'setLocale': 'setLocale',\n    'getCatalog': 'getCatalog',\n    'getLocales': 'getLocales',\n    'addLocale': 'addLocale',\n    'removeLocale': 'removeLocale'\n  },\n      pathsep = path.sep,\n      // ---> means win support will be available in node 0.8.x and above\n  autoReload,\n      cookiename,\n      defaultLocale,\n      directory,\n      directoryPermissions,\n      extension,\n      fallbacks,\n      indent,\n      logDebugFn,\n      logErrorFn,\n      logWarnFn,\n      preserveLegacyCase,\n      objectNotation,\n      prefix,\n      queryParameter,\n      register,\n      updateFiles,\n      syncFiles; // public exports\n\n  var i18n = {};\n  i18n.version = '0.8.3';\n\n  i18n.configure = function i18nConfigure(opt) {\n    // reset locales\n    locales = {}; // Provide custom API method aliases if desired\n    // This needs to be processed before the first call to applyAPItoObject()\n\n    if (opt.api && typeof opt.api === 'object') {\n      for (var method in opt.api) {\n        if (opt.api.hasOwnProperty(method)) {\n          var alias = opt.api[method];\n\n          if (typeof api[method] !== 'undefined') {\n            api[method] = alias;\n          }\n        }\n      }\n    } // you may register i18n in global scope, up to you\n\n\n    if (typeof opt.register === 'object') {\n      register = opt.register; // or give an array objects to register to\n\n      if (Array.isArray(opt.register)) {\n        register = opt.register;\n        register.forEach(function (r) {\n          applyAPItoObject(r);\n        });\n      } else {\n        applyAPItoObject(opt.register);\n      }\n    } // sets a custom cookie name to parse locale settings from\n\n\n    cookiename = typeof opt.cookie === 'string' ? opt.cookie : null; // query-string parameter to be watched - @todo: add test & doc\n\n    queryParameter = typeof opt.queryParameter === 'string' ? opt.queryParameter : null; // where to store json files\n\n    directory = typeof opt.directory === 'string' ? opt.directory : path.join(__dirname, 'locales'); // permissions when creating new directories\n\n    directoryPermissions = typeof opt.directoryPermissions === 'string' ? parseInt(opt.directoryPermissions, 8) : null; // write new locale information to disk\n\n    updateFiles = typeof opt.updateFiles === 'boolean' ? opt.updateFiles : true; // sync locale information accros all files\n\n    syncFiles = typeof opt.syncFiles === 'boolean' ? opt.syncFiles : false; // what to use as the indentation unit (ex: \"\\t\", \"  \")\n\n    indent = typeof opt.indent === 'string' ? opt.indent : '\\t'; // json files prefix\n\n    prefix = typeof opt.prefix === 'string' ? opt.prefix : ''; // where to store json files\n\n    extension = typeof opt.extension === 'string' ? opt.extension : '.json'; // setting defaultLocale\n\n    defaultLocale = typeof opt.defaultLocale === 'string' ? opt.defaultLocale : 'en'; // auto reload locale files when changed\n\n    autoReload = typeof opt.autoReload === 'boolean' ? opt.autoReload : false; // enable object notation?\n\n    objectNotation = typeof opt.objectNotation !== 'undefined' ? opt.objectNotation : false;\n    if (objectNotation === true) objectNotation = '.'; // read language fallback map\n\n    fallbacks = typeof opt.fallbacks === 'object' ? opt.fallbacks : {}; // setting custom logger functions\n\n    logDebugFn = typeof opt.logDebugFn === 'function' ? opt.logDebugFn : debug;\n    logWarnFn = typeof opt.logWarnFn === 'function' ? opt.logWarnFn : warn;\n    logErrorFn = typeof opt.logErrorFn === 'function' ? opt.logErrorFn : error;\n    preserveLegacyCase = typeof opt.preserveLegacyCase === 'undefined' ? true : opt.preserveLegacyCase; // when missing locales we try to guess that from directory\n\n    opt.locales = opt.locales || guessLocales(directory); // implicitly read all locales\n\n    if (Array.isArray(opt.locales)) {\n      opt.locales.forEach(function (l) {\n        read(l);\n      }); // auto reload locale files when changed\n\n      if (autoReload) {\n        // watch changes of locale files (it's called twice because fs.watch is still unstable)\n        fs.watch(directory, function (event, filename) {\n          var localeFromFile = guessLocaleFromFile(filename);\n\n          if (localeFromFile && opt.locales.indexOf(localeFromFile) > -1) {\n            logDebug('Auto reloading locale file \"' + filename + '\".');\n            read(localeFromFile);\n          }\n        });\n      }\n    }\n  };\n\n  i18n.init = function i18nInit(request, response, next) {\n    if (typeof request === 'object') {\n      // guess requested language/locale\n      guessLanguage(request); // bind api to req\n\n      applyAPItoObject(request); // looks double but will ensure schema on api refactor\n\n      i18n.setLocale(request, request.locale);\n    } else {\n      return logError('i18n.init must be called with one parameter minimum, ie. i18n.init(req)');\n    }\n\n    if (typeof response === 'object') {\n      applyAPItoObject(response); // and set that locale to response too\n\n      i18n.setLocale(response, request.locale);\n    } // head over to next callback when bound as middleware\n\n\n    if (typeof next === 'function') {\n      return next();\n    }\n  };\n\n  i18n.__ = function i18nTranslate(phrase) {\n    var msg;\n    var argv = parseArgv(arguments);\n    var namedValues = argv[0];\n    var args = argv[1]; // called like __({phrase: \"Hello\", locale: \"en\"})\n\n    if (typeof phrase === 'object') {\n      if (typeof phrase.locale === 'string' && typeof phrase.phrase === 'string') {\n        msg = translate(phrase.locale, phrase.phrase);\n      }\n    } // called like __(\"Hello\")\n    else {\n        // get translated message with locale from scope (deprecated) or object\n        msg = translate(getLocaleFromObject(this), phrase);\n      } // postprocess to get compatible to plurals\n\n\n    if (typeof msg === 'object' && msg.one) {\n      msg = msg.one;\n    } // in case there is no 'one' but an 'other' rule\n\n\n    if (typeof msg === 'object' && msg.other) {\n      msg = msg.other;\n    } // head over to postProcessing\n\n\n    return postProcess(msg, namedValues, args);\n  };\n\n  i18n.__mf = function i18nMessageformat(phrase) {\n    var msg, mf, f;\n    var targetLocale = defaultLocale;\n    var argv = parseArgv(arguments);\n    var namedValues = argv[0];\n    var args = argv[1]; // called like __({phrase: \"Hello\", locale: \"en\"})\n\n    if (typeof phrase === 'object') {\n      if (typeof phrase.locale === 'string' && typeof phrase.phrase === 'string') {\n        msg = phrase.phrase;\n        targetLocale = phrase.locale;\n      }\n    } // called like __(\"Hello\")\n    else {\n        // get translated message with locale from scope (deprecated) or object\n        msg = phrase;\n        targetLocale = getLocaleFromObject(this);\n      }\n\n    msg = translate(targetLocale, msg); // --- end get msg\n    // now head over to Messageformat\n    // and try to cache instance\n\n    if (MessageformatInstanceForLocale[targetLocale]) {\n      mf = MessageformatInstanceForLocale[targetLocale];\n    } else {\n      mf = new Messageformat(targetLocale); // @see https://messageformat.github.io/messageformat/MessageFormat#disablePluralKeyChecks__anchor\n\n      mf.disablePluralKeyChecks();\n      mf.compiledFunctions = {};\n      MessageformatInstanceForLocale[targetLocale] = mf;\n    } // let's try to cache that function\n\n\n    if (mf.compiledFunctions[msg]) {\n      f = mf.compiledFunctions[msg];\n    } else {\n      f = mf.compile(msg);\n      mf.compiledFunctions[msg] = f;\n    }\n\n    return postProcess(f(namedValues), namedValues, args);\n  };\n\n  i18n.__l = function i18nTranslationList(phrase) {\n    var translations = [];\n    Object.keys(locales).sort().forEach(function (l) {\n      translations.push(i18n.__({\n        phrase: phrase,\n        locale: l\n      }));\n    });\n    return translations;\n  };\n\n  i18n.__h = function i18nTranslationHash(phrase) {\n    var translations = [];\n    Object.keys(locales).sort().forEach(function (l) {\n      var hash = {};\n      hash[l] = i18n.__({\n        phrase: phrase,\n        locale: l\n      });\n      translations.push(hash);\n    });\n    return translations;\n  };\n\n  i18n.__n = function i18nTranslatePlural(singular, plural, count) {\n    var msg,\n        namedValues,\n        targetLocale,\n        args = []; // Accept an object with named values as the last parameter\n\n    if (argsEndWithNamedObject(arguments)) {\n      namedValues = arguments[arguments.length - 1];\n      args = arguments.length >= 5 ? Array.prototype.slice.call(arguments, 3, -1) : [];\n    } else {\n      namedValues = {};\n      args = arguments.length >= 4 ? Array.prototype.slice.call(arguments, 3) : [];\n    } // called like __n({singular: \"%s cat\", plural: \"%s cats\", locale: \"en\"}, 3)\n\n\n    if (typeof singular === 'object') {\n      if (typeof singular.locale === 'string' && typeof singular.singular === 'string' && typeof singular.plural === 'string') {\n        targetLocale = singular.locale;\n        msg = translate(singular.locale, singular.singular, singular.plural);\n      }\n\n      args.unshift(count); // some template engines pass all values as strings -> so we try to convert them to numbers\n\n      if (typeof plural === 'number' || parseInt(plural, 10) + '' === plural) {\n        count = plural;\n      } // called like __n({singular: \"%s cat\", plural: \"%s cats\", locale: \"en\", count: 3})\n\n\n      if (typeof singular.count === 'number' || typeof singular.count === 'string') {\n        count = singular.count;\n        args.unshift(plural);\n      }\n    } else {\n      // called like  __n('cat', 3)\n      if (typeof plural === 'number' || parseInt(plural, 10) + '' === plural) {\n        count = plural; // we add same string as default\n        // which efectivly copies the key to the plural.value\n        // this is for initialization of new empty translations\n\n        plural = singular;\n        args.unshift(count);\n        args.unshift(plural);\n      } // called like __n('%s cat', '%s cats', 3)\n      // get translated message with locale from scope (deprecated) or object\n\n\n      msg = translate(getLocaleFromObject(this), singular, plural);\n      targetLocale = getLocaleFromObject(this);\n    }\n\n    if (count === null) count = namedValues.count; // enforce number\n\n    count = parseInt(count, 10); // find the correct plural rule for given locale\n\n    if (typeof msg === 'object') {\n      var p; // create a new Plural for locale\n      // and try to cache instance\n\n      if (PluralsForLocale[targetLocale]) {\n        p = PluralsForLocale[targetLocale];\n      } else {\n        // split locales with a region code\n        var lc = targetLocale.toLowerCase().split(/[_-\\s]+/).filter(function (el) {\n          return true && el;\n        }); // take the first part of locale, fallback to full locale\n\n        p = MakePlural[lc[0] || targetLocale];\n        PluralsForLocale[targetLocale] = p;\n      } // fallback to 'other' on case of missing translations\n\n\n      msg = msg[p(count)] || msg.other;\n    } // head over to postProcessing\n\n\n    return postProcess(msg, namedValues, args, count);\n  };\n\n  i18n.setLocale = function i18nSetLocale(object, locale, skipImplicitObjects) {\n    // when given an array of objects => setLocale on each\n    if (Array.isArray(object) && typeof locale === 'string') {\n      for (var i = object.length - 1; i >= 0; i--) {\n        i18n.setLocale(object[i], locale, true);\n      }\n\n      return i18n.getLocale(object[0]);\n    } // defaults to called like i18n.setLocale(req, 'en')\n\n\n    var targetObject = object;\n    var targetLocale = locale; // called like req.setLocale('en') or i18n.setLocale('en')\n\n    if (locale === undefined && typeof object === 'string') {\n      targetObject = this;\n      targetLocale = object;\n    } // consider a fallback\n\n\n    if (!locales[targetLocale] && fallbacks[targetLocale]) {\n      targetLocale = fallbacks[targetLocale];\n    } // now set locale on object\n\n\n    targetObject.locale = locales[targetLocale] ? targetLocale : defaultLocale; // consider any extra registered objects\n\n    if (typeof register === 'object') {\n      if (Array.isArray(register) && !skipImplicitObjects) {\n        register.forEach(function (r) {\n          r.locale = targetObject.locale;\n        });\n      } else {\n        register.locale = targetObject.locale;\n      }\n    } // consider res\n\n\n    if (targetObject.res && !skipImplicitObjects) {\n      // escape recursion\n      // @see  - https://github.com/balderdashy/sails/pull/3631\n      //       - https://github.com/mashpie/i18n-node/pull/218\n      if (targetObject.res.locals) {\n        i18n.setLocale(targetObject.res, targetObject.locale, true);\n        i18n.setLocale(targetObject.res.locals, targetObject.locale, true);\n      } else {\n        i18n.setLocale(targetObject.res, targetObject.locale);\n      }\n    } // consider locals\n\n\n    if (targetObject.locals && !skipImplicitObjects) {\n      // escape recursion\n      // @see  - https://github.com/balderdashy/sails/pull/3631\n      //       - https://github.com/mashpie/i18n-node/pull/218\n      if (targetObject.locals.res) {\n        i18n.setLocale(targetObject.locals, targetObject.locale, true);\n        i18n.setLocale(targetObject.locals.res, targetObject.locale, true);\n      } else {\n        i18n.setLocale(targetObject.locals, targetObject.locale);\n      }\n    }\n\n    return i18n.getLocale(targetObject);\n  };\n\n  i18n.getLocale = function i18nGetLocale(request) {\n    // called like i18n.getLocale(req)\n    if (request && request.locale) {\n      return request.locale;\n    } // called like req.getLocale()\n\n\n    return this.locale || defaultLocale;\n  };\n\n  i18n.getCatalog = function i18nGetCatalog(object, locale) {\n    var targetLocale; // called like i18n.getCatalog(req)\n\n    if (typeof object === 'object' && typeof object.locale === 'string' && locale === undefined) {\n      targetLocale = object.locale;\n    } // called like i18n.getCatalog(req, 'en')\n\n\n    if (!targetLocale && typeof object === 'object' && typeof locale === 'string') {\n      targetLocale = locale;\n    } // called like req.getCatalog('en')\n\n\n    if (!targetLocale && locale === undefined && typeof object === 'string') {\n      targetLocale = object;\n    } // called like req.getCatalog()\n\n\n    if (!targetLocale && object === undefined && locale === undefined && typeof this.locale === 'string') {\n      if (register && register.global) {\n        targetLocale = '';\n      } else {\n        targetLocale = this.locale;\n      }\n    } // called like i18n.getCatalog()\n\n\n    if (targetLocale === undefined || targetLocale === '') {\n      return locales;\n    }\n\n    if (!locales[targetLocale] && fallbacks[targetLocale]) {\n      targetLocale = fallbacks[targetLocale];\n    }\n\n    if (locales[targetLocale]) {\n      return locales[targetLocale];\n    } else {\n      logWarn('No catalog found for \"' + targetLocale + '\"');\n      return false;\n    }\n  };\n\n  i18n.getLocales = function i18nGetLocales() {\n    return Object.keys(locales);\n  };\n\n  i18n.addLocale = function i18nAddLocale(locale) {\n    read(locale);\n  };\n\n  i18n.removeLocale = function i18nRemoveLocale(locale) {\n    delete locales[locale];\n  }; // ===================\n  // = private methods =\n  // ===================\n\n\n  var postProcess = function postProcess(msg, namedValues, args, count) {\n    // test for parsable interval string\n    if (/\\|/.test(msg)) {\n      msg = parsePluralInterval(msg, count);\n    } // replace the counter\n\n\n    if (typeof count === 'number') {\n      msg = vsprintf(msg, [parseInt(count, 10)]);\n    } // if the msg string contains {{Mustache}} patterns we render it as a mini tempalate\n\n\n    if (/{{.*}}/.test(msg)) {\n      msg = Mustache.render(msg, namedValues);\n    } // if we have extra arguments with values to get replaced,\n    // an additional substition injects those strings afterwards\n\n\n    if (/%/.test(msg) && args && args.length > 0) {\n      msg = vsprintf(msg, args);\n    }\n\n    return msg;\n  };\n\n  var argsEndWithNamedObject = function argsEndWithNamedObject(args) {\n    return args.length > 1 && args[args.length - 1] !== null && typeof args[args.length - 1] === 'object';\n  };\n\n  var parseArgv = function parseArgv(args) {\n    var namedValues, returnArgs;\n\n    if (argsEndWithNamedObject(args)) {\n      namedValues = args[args.length - 1];\n      returnArgs = Array.prototype.slice.call(args, 1, -1);\n    } else {\n      namedValues = {};\n      returnArgs = args.length >= 2 ? Array.prototype.slice.call(args, 1) : [];\n    }\n\n    return [namedValues, returnArgs];\n  };\n  /**\n   * registers all public API methods to a given response object when not already declared\n   */\n\n\n  var applyAPItoObject = function applyAPItoObject(object) {\n    var alreadySetted = true; // attach to itself if not provided\n\n    for (var method in api) {\n      if (api.hasOwnProperty(method)) {\n        var alias = api[method]; // be kind rewind, or better not touch anything already existing\n\n        if (!object[alias]) {\n          alreadySetted = false;\n          object[alias] = i18n[method].bind(object);\n        }\n      }\n    } // set initial locale if not set\n\n\n    if (!object.locale) {\n      object.locale = defaultLocale;\n    } // escape recursion\n\n\n    if (alreadySetted) {\n      return;\n    } // attach to response if present (ie. in express)\n\n\n    if (object.res) {\n      applyAPItoObject(object.res);\n    } // attach to locals if present (ie. in express)\n\n\n    if (object.locals) {\n      applyAPItoObject(object.locals);\n    }\n  };\n  /**\n   * tries to guess locales by scanning the given directory\n   */\n\n\n  var guessLocales = function guessLocales(directory) {\n    var entries = fs.readdirSync(directory);\n    var localesFound = [];\n\n    for (var i = entries.length - 1; i >= 0; i--) {\n      if (entries[i].match(/^\\./)) continue;\n      var localeFromFile = guessLocaleFromFile(entries[i]);\n      if (localeFromFile) localesFound.push(localeFromFile);\n    }\n\n    return localesFound.sort();\n  };\n  /**\n   * tries to guess locales from a given filename\n   */\n\n\n  var guessLocaleFromFile = function guessLocaleFromFile(filename) {\n    var extensionRegex = new RegExp(extension + '$', 'g');\n    var prefixRegex = new RegExp('^' + prefix, 'g');\n    if (!filename) return false;\n    if (prefix && !filename.match(prefixRegex)) return false;\n    if (extension && !filename.match(extensionRegex)) return false;\n    return filename.replace(prefix, '').replace(extensionRegex, '');\n  };\n  /**\n   * guess language setting based on http headers\n   */\n\n\n  var guessLanguage = function guessLanguage(request) {\n    if (typeof request === 'object') {\n      var languageHeader = request.headers ? request.headers['accept-language'] : undefined,\n          languages = [],\n          regions = [];\n      request.languages = [defaultLocale];\n      request.regions = [defaultLocale];\n      request.language = defaultLocale;\n      request.region = defaultLocale; // a query parameter overwrites all\n\n      if (queryParameter && request.url) {\n        var urlAsString = typeof request.url === 'string' ? request.url : request.url.toString();\n        var urlObj = url.parse(urlAsString, true);\n\n        if (urlObj.query[queryParameter]) {\n          logDebug('Overriding locale from query: ' + urlObj.query[queryParameter]);\n          request.language = urlObj.query[queryParameter];\n\n          if (preserveLegacyCase) {\n            request.language = request.language.toLowerCase();\n          }\n\n          return i18n.setLocale(request, request.language);\n        }\n      } // a cookie overwrites headers\n\n\n      if (cookiename && request.cookies && request.cookies[cookiename]) {\n        request.language = request.cookies[cookiename];\n        return i18n.setLocale(request, request.language);\n      } // 'accept-language' is the most common source\n\n\n      if (languageHeader) {\n        var acceptedLanguages = getAcceptedLanguagesFromHeader(languageHeader),\n            match,\n            fallbackMatch,\n            fallback;\n\n        for (var i = 0; i < acceptedLanguages.length; i++) {\n          var lang = acceptedLanguages[i],\n              lr = lang.split('-', 2),\n              parentLang = lr[0],\n              region = lr[1]; // Check if we have a configured fallback set for this language.\n\n          if (fallbacks && fallbacks[lang]) {\n            fallback = fallbacks[lang]; // Fallbacks for languages should be inserted\n            // where the original, unsupported language existed.\n\n            var acceptedLanguageIndex = acceptedLanguages.indexOf(lang);\n            var fallbackIndex = acceptedLanguages.indexOf(fallback);\n\n            if (fallbackIndex > -1) {\n              acceptedLanguages.splice(fallbackIndex, 1);\n            }\n\n            acceptedLanguages.splice(acceptedLanguageIndex + 1, 0, fallback);\n          } // Check if we have a configured fallback set for the parent language of the locale.\n\n\n          if (fallbacks && fallbacks[parentLang]) {\n            fallback = fallbacks[parentLang]; // Fallbacks for a parent language should be inserted\n            // to the end of the list, so they're only picked\n            // if there is no better match.\n\n            if (acceptedLanguages.indexOf(fallback) < 0) {\n              acceptedLanguages.push(fallback);\n            }\n          }\n\n          if (languages.indexOf(parentLang) < 0) {\n            languages.push(parentLang.toLowerCase());\n          }\n\n          if (region) {\n            regions.push(region.toLowerCase());\n          }\n\n          if (!match && locales[lang]) {\n            match = lang;\n            break;\n          }\n\n          if (!fallbackMatch && locales[parentLang]) {\n            fallbackMatch = parentLang;\n          }\n        }\n\n        request.language = match || fallbackMatch || request.language;\n        request.region = regions[0] || request.region;\n        return i18n.setLocale(request, request.language);\n      }\n    } // last resort: defaultLocale\n\n\n    return i18n.setLocale(request, defaultLocale);\n  };\n  /**\n   * Get a sorted list of accepted languages from the HTTP Accept-Language header\n   */\n\n\n  var getAcceptedLanguagesFromHeader = function getAcceptedLanguagesFromHeader(header) {\n    var languages = header.split(','),\n        preferences = {};\n    return languages.map(function parseLanguagePreference(item) {\n      var preferenceParts = item.trim().split(';q=');\n\n      if (preferenceParts.length < 2) {\n        preferenceParts[1] = 1.0;\n      } else {\n        var quality = parseFloat(preferenceParts[1]);\n        preferenceParts[1] = quality ? quality : 0.0;\n      }\n\n      preferences[preferenceParts[0]] = preferenceParts[1];\n      return preferenceParts[0];\n    }).filter(function (lang) {\n      return preferences[lang] > 0;\n    }).sort(function sortLanguages(a, b) {\n      return preferences[b] - preferences[a];\n    });\n  };\n  /**\n   * searches for locale in given object\n   */\n\n\n  var getLocaleFromObject = function getLocaleFromObject(obj) {\n    var locale;\n\n    if (obj && obj.scope) {\n      locale = obj.scope.locale;\n    }\n\n    if (obj && obj.locale) {\n      locale = obj.locale;\n    }\n\n    return locale;\n  };\n  /**\n   * splits and parses a phrase for mathematical interval expressions\n   */\n\n\n  var parsePluralInterval = function parsePluralInterval(phrase, count) {\n    var returnPhrase = phrase;\n    var phrases = phrase.split(/\\|/); // some() breaks on 1st true\n\n    phrases.some(function (p) {\n      var matches = p.match(/^\\s*([\\(\\)\\[\\]\\d,]+)?\\s*(.*)$/); // not the same as in combined condition\n\n      if (matches[1]) {\n        if (matchInterval(count, matches[1]) === true) {\n          returnPhrase = matches[2];\n          return true;\n        }\n      } else {\n        returnPhrase = p;\n      }\n    });\n    return returnPhrase;\n  };\n  /**\n   * test a number to match mathematical interval expressions\n   * [0,2] - 0 to 2 (including, matches: 0, 1, 2)\n   * ]0,3[ - 0 to 3 (excluding, matches: 1, 2)\n   * [1]   - 1 (matches: 1)\n   * [20,] - all numbers ≥20 (matches: 20, 21, 22, ...)\n   * [,20] - all numbers ≤20 (matches: 20, 21, 22, ...)\n   */\n\n\n  var matchInterval = function matchInterval(number, interval) {\n    interval = parseInterval(interval);\n\n    if (interval && typeof number === 'number') {\n      if (interval.from.value === number) {\n        return interval.from.included;\n      }\n\n      if (interval.to.value === number) {\n        return interval.to.included;\n      }\n\n      return Math.min(interval.from.value, number) === interval.from.value && Math.max(interval.to.value, number) === interval.to.value;\n    }\n\n    return false;\n  };\n  /**\n   * read locale file, translate a msg and write to fs if new\n   */\n\n\n  var translate = function translate(locale, singular, plural, skipSyncToAllFiles) {\n    // add same key to all translations\n    if (!skipSyncToAllFiles && syncFiles) {\n      syncToAllFiles(singular, plural);\n    }\n\n    if (locale === undefined) {\n      logWarn('WARN: No locale found - check the context of the call to __(). Using ' + defaultLocale + ' as current locale');\n      locale = defaultLocale;\n    }\n\n    if (!locales[locale] && fallbacks[locale]) {\n      locale = fallbacks[locale];\n    } // attempt to read when defined as valid locale\n\n\n    if (!locales[locale]) {\n      read(locale);\n    } // fallback to default when missed\n\n\n    if (!locales[locale]) {\n      logWarn('WARN: Locale ' + locale + ' couldn\\'t be read - check the context of the call to $__. Using ' + defaultLocale + ' (default) as current locale');\n      locale = defaultLocale;\n      read(locale);\n    } // dotnotaction add on, @todo: factor out\n\n\n    var defaultSingular = singular;\n    var defaultPlural = plural;\n\n    if (objectNotation) {\n      var indexOfColon = singular.indexOf(':'); // We compare against 0 instead of -1 because\n      // we don't really expect the string to start with ':'.\n\n      if (0 < indexOfColon) {\n        defaultSingular = singular.substring(indexOfColon + 1);\n        singular = singular.substring(0, indexOfColon);\n      }\n\n      if (plural && typeof plural !== 'number') {\n        indexOfColon = plural.indexOf(':');\n\n        if (0 < indexOfColon) {\n          defaultPlural = plural.substring(indexOfColon + 1);\n          plural = plural.substring(0, indexOfColon);\n        }\n      }\n    }\n\n    var accessor = localeAccessor(locale, singular);\n    var mutator = localeMutator(locale, singular);\n\n    if (plural) {\n      if (accessor() == null) {\n        mutator({\n          'one': defaultSingular || singular,\n          'other': defaultPlural || plural\n        });\n        write(locale);\n      }\n    }\n\n    if (accessor() == null) {\n      mutator(defaultSingular || singular);\n      write(locale);\n    }\n\n    return accessor();\n  };\n  /**\n   * initialize the same key in all locales\n   * when not already existing, checked via translate\n   */\n\n\n  var syncToAllFiles = function syncToAllFiles(singular, plural) {\n    // iterate over locales and translate again\n    // this will implicitly write/sync missing keys\n    // to the rest of locales\n    for (var l in locales) {\n      translate(l, singular, plural, true);\n    }\n  };\n  /**\n   * Allows delayed access to translations nested inside objects.\n   * @param {String} locale The locale to use.\n   * @param {String} singular The singular term to look up.\n   * @param {Boolean} [allowDelayedTraversal=true] Is delayed traversal of the tree allowed?\n   * This parameter is used internally. It allows to signal the accessor that\n   * a translation was not found in the initial lookup and that an invocation\n   * of the accessor may trigger another traversal of the tree.\n   * @returns {Function} A function that, when invoked, returns the current value stored\n   * in the object at the requested location.\n   */\n\n\n  var localeAccessor = function localeAccessor(locale, singular, allowDelayedTraversal) {\n    // Bail out on non-existent locales to defend against internal errors.\n    if (!locales[locale]) return Function.prototype; // Handle object lookup notation\n\n    var indexOfDot = objectNotation && singular.lastIndexOf(objectNotation);\n\n    if (objectNotation && 0 < indexOfDot && indexOfDot < singular.length - 1) {\n      // If delayed traversal wasn't specifically forbidden, it is allowed.\n      if (typeof allowDelayedTraversal === 'undefined') allowDelayedTraversal = true; // The accessor we're trying to find and which we want to return.\n\n      var accessor = null; // An accessor that returns null.\n\n      var nullAccessor = function nullAccessor() {\n        return null;\n      }; // Do we need to re-traverse the tree upon invocation of the accessor?\n\n\n      var reTraverse = false; // Split the provided term and run the callback for each subterm.\n\n      singular.split(objectNotation).reduce(function (object, index) {\n        // Make the accessor return null.\n        accessor = nullAccessor; // If our current target object (in the locale tree) doesn't exist or\n        // it doesn't have the next subterm as a member...\n\n        if (null === object || !object.hasOwnProperty(index)) {\n          // ...remember that we need retraversal (because we didn't find our target).\n          reTraverse = allowDelayedTraversal; // Return null to avoid deeper iterations.\n\n          return null;\n        } // We can traverse deeper, so we generate an accessor for this current level.\n\n\n        accessor = function accessor() {\n          return object[index];\n        }; // Return a reference to the next deeper level in the locale tree.\n\n\n        return object[index];\n      }, locales[locale]); // Return the requested accessor.\n\n      return function () {\n        // If we need to re-traverse (because we didn't find our target term)\n        // traverse again and return the new result (but don't allow further iterations)\n        // or return the previously found accessor if it was already valid.\n        return reTraverse ? localeAccessor(locale, singular, false)() : accessor();\n      };\n    } else {\n      // No object notation, just return an accessor that performs array lookup.\n      return function () {\n        return locales[locale][singular];\n      };\n    }\n  };\n  /**\n   * Allows delayed mutation of a translation nested inside objects.\n   * @description Construction of the mutator will attempt to locate the requested term\n   * inside the object, but if part of the branch does not exist yet, it will not be\n   * created until the mutator is actually invoked. At that point, re-traversal of the\n   * tree is performed and missing parts along the branch will be created.\n   * @param {String} locale The locale to use.\n   * @param {String} singular The singular term to look up.\n   * @param [Boolean} [allowBranching=false] Is the mutator allowed to create previously\n   * non-existent branches along the requested locale path?\n   * @returns {Function} A function that takes one argument. When the function is\n   * invoked, the targeted translation term will be set to the given value inside the locale table.\n   */\n\n\n  var localeMutator = function localeMutator(locale, singular, allowBranching) {\n    // Bail out on non-existent locales to defend against internal errors.\n    if (!locales[locale]) return Function.prototype; // Handle object lookup notation\n\n    var indexOfDot = objectNotation && singular.lastIndexOf(objectNotation);\n\n    if (objectNotation && 0 < indexOfDot && indexOfDot < singular.length - 1) {\n      // If branching wasn't specifically allowed, disable it.\n      if (typeof allowBranching === 'undefined') allowBranching = false; // This will become the function we want to return.\n\n      var accessor = null; // An accessor that takes one argument and returns null.\n\n      var nullAccessor = function nullAccessor() {\n        return null;\n      }; // Fix object path.\n\n\n      var fixObject = function fixObject() {\n        return {};\n      }; // Are we going to need to re-traverse the tree when the mutator is invoked?\n\n\n      var reTraverse = false; // Split the provided term and run the callback for each subterm.\n\n      singular.split(objectNotation).reduce(function (object, index) {\n        // Make the mutator do nothing.\n        accessor = nullAccessor; // If our current target object (in the locale tree) doesn't exist or\n        // it doesn't have the next subterm as a member...\n\n        if (null === object || !object.hasOwnProperty(index)) {\n          // ...check if we're allowed to create new branches.\n          if (allowBranching) {\n            // Fix `object` if `object` is not Object.\n            if (null === object || typeof object !== 'object') {\n              object = fixObject();\n            } // If we are allowed to, create a new object along the path.\n\n\n            object[index] = {};\n          } else {\n            // If we aren't allowed, remember that we need to re-traverse later on and...\n            reTraverse = true; // ...return null to make the next iteration bail our early on.\n\n            return null;\n          }\n        } // Generate a mutator for the current level.\n\n\n        accessor = function accessor(value) {\n          object[index] = value;\n          return value;\n        }; // Generate a fixer for the current level.\n\n\n        fixObject = function fixObject() {\n          object[index] = {};\n          return object[index];\n        }; // Return a reference to the next deeper level in the locale tree.\n\n\n        return object[index];\n      }, locales[locale]); // Return the final mutator.\n\n      return function (value) {\n        // If we need to re-traverse the tree\n        // invoke the search again, but allow branching\n        // this time (because here the mutator is being invoked)\n        // otherwise, just change the value directly.\n        return reTraverse ? localeMutator(locale, singular, true)(value) : accessor(value);\n      };\n    } else {\n      // No object notation, just return a mutator that performs array lookup and changes the value.\n      return function (value) {\n        locales[locale][singular] = value;\n        return value;\n      };\n    }\n  };\n  /**\n   * try reading a file\n   */\n\n\n  var read = function read(locale) {\n    var localeFile = {},\n        file = getStorageFilePath(locale);\n\n    try {\n      logDebug('read ' + file + ' for locale: ' + locale);\n      localeFile = fs.readFileSync(file);\n\n      try {\n        // parsing filecontents to locales[locale]\n        locales[locale] = JSON.parse(localeFile);\n      } catch (parseError) {\n        logError('unable to parse locales from file (maybe ' + file + ' is empty or invalid json?): ', parseError);\n      }\n    } catch (readError) {\n      // unable to read, so intialize that file\n      // locales[locale] are already set in memory, so no extra read required\n      // or locales[locale] are empty, which initializes an empty locale.json file\n      // since the current invalid locale could exist, we should back it up\n      if (fs.existsSync(file)) {\n        logDebug('backing up invalid locale ' + locale + ' to ' + file + '.invalid');\n        fs.renameSync(file, file + '.invalid');\n      }\n\n      logDebug('initializing ' + file);\n      write(locale);\n    }\n  };\n  /**\n   * try writing a file in a created directory\n   */\n\n\n  var write = function write(locale) {\n    var stats, target, tmp; // don't write new locale information to disk if updateFiles isn't true\n\n    if (!updateFiles) {\n      return;\n    } // creating directory if necessary\n\n\n    try {\n      stats = fs.lstatSync(directory);\n    } catch (e) {\n      logDebug('creating locales dir in: ' + directory);\n      fs.mkdirSync(directory, directoryPermissions);\n    } // first time init has an empty file\n\n\n    if (!locales[locale]) {\n      locales[locale] = {};\n    } // writing to tmp and rename on success\n\n\n    try {\n      target = getStorageFilePath(locale);\n      tmp = target + '.tmp';\n      fs.writeFileSync(tmp, JSON.stringify(locales[locale], null, indent), 'utf8');\n      stats = fs.statSync(tmp);\n\n      if (stats.isFile()) {\n        fs.renameSync(tmp, target);\n      } else {\n        logError('unable to write locales to file (either ' + tmp + ' or ' + target + ' are not writeable?): ');\n      }\n    } catch (e) {\n      logError('unexpected error writing files (either ' + tmp + ' or ' + target + ' are not writeable?): ', e);\n    }\n  };\n  /**\n   * basic normalization of filepath\n   */\n\n\n  var getStorageFilePath = function getStorageFilePath(locale) {\n    // changed API to use .json as default, #16\n    var ext = extension || '.json',\n        filepath = path.normalize(directory + pathsep + prefix + locale + ext),\n        filepathJS = path.normalize(directory + pathsep + prefix + locale + '.js'); // use .js as fallback if already existing\n\n    try {\n      if (fs.statSync(filepathJS)) {\n        logDebug('using existing file ' + filepathJS);\n        extension = '.js';\n        return filepathJS;\n      }\n    } catch (e) {\n      logDebug('will use ' + filepath);\n    }\n\n    return filepath;\n  };\n  /**\n   * Logging proxies\n   */\n\n\n  function logDebug(msg) {\n    logDebugFn(msg);\n  }\n\n  function logWarn(msg) {\n    logWarnFn(msg);\n  }\n\n  function logError(msg) {\n    logErrorFn(msg);\n  }\n\n  return i18n;\n}();","map":null,"metadata":{},"sourceType":"script"}