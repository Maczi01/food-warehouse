{"ast":null,"code":"import _inheritsLoose from '@babel/runtime/helpers/inheritsLoose';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/objectWithoutPropertiesLoose';\nimport _extends from '@babel/runtime/helpers/extends';\nimport React from 'react';\nimport _regeneratorRuntime from '@babel/runtime/regenerator';\nimport _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';\nimport BlobStream from 'blob-stream';\nimport PDFDocument, { PDFFont } from '@react-pdf/pdfkit';\nimport 'is-url';\nimport fontkit from '@react-pdf/fontkit';\nimport fetch from 'cross-fetch';\nimport { match, is, when, test, compose, cond, T, mapObjIndexed, flip, curryN, either, path, propEq, hasPath, both, tap, pathOr, o, prop, splitEvery, map, slice, split as split$1, replace, trim, identity, reduce, max as max$1, min as min$1, always, pluck, pathEq, propOr, forEach, ifElse, isNil, join, juxt, toUpper, head, tail, memoizeWith, last, evolve, concat, assoc, groupBy, defaultTo, find, complement, filter, __, pick, merge, apply, equals, anyPass, unless, sort, add, then, reject, isEmpty, converge, includes, applySpec, subtract, pathSatisfies, allPass, mergeAll, dissoc, useWith, lte, all, assocPath, dissocPath, any, reverse } from 'ramda';\nimport runWidth from '@react-pdf/textkit/run/advanceWidth';\nimport lineWidth from '@react-pdf/textkit/attributedString/advanceWidth';\nimport absPath from 'abs-svg-path';\nimport parsePath from 'parse-svg-path';\nimport arcToCurve from 'svg-arc-to-cubic-bezier';\nimport PDFRenderer from '@react-pdf/textkit/renderers/pdf';\nimport layoutEngine from '@react-pdf/textkit/layout';\nimport linebreaker from '@react-pdf/textkit/engines/linebreaker';\nimport justification from '@react-pdf/textkit/engines/justification';\nimport textDecoration from '@react-pdf/textkit/engines/textDecoration';\nimport scriptItemizer from '@react-pdf/textkit/engines/scriptItemizer';\nimport wordHyphenation from '@react-pdf/textkit/engines/wordHyphenation';\nimport AttributedString from '@react-pdf/textkit/attributedString';\nimport _createClass from '@babel/runtime/helpers/createClass';\nimport colorString from 'color-string';\nimport hlsToHex from 'hsl-to-hex';\nimport PNG from '@react-pdf/png-js';\nimport emojiRegex from 'emoji-regex';\nimport matchMedia from 'media-engine';\nimport Yoga from 'yoga-layout-prebuilt';\nimport ReactFiberReconciler from 'react-reconciler';\nimport { unstable_scheduleCallback, unstable_cancelCallback } from 'scheduler';\nvar VIEW = 'VIEW';\nvar TEXT = 'TEXT';\nvar LINK = 'LINK';\nvar PAGE = 'PAGE';\nvar NOTE = 'NOTE';\nvar IMAGE = 'IMAGE';\nvar DOCUMENT = 'DOCUMENT';\nvar CANVAS = 'CANVAS';\nvar TEXT_INSTANCE = 'TEXT_INSTANCE';\nvar SVG = 'SVG';\nvar GROUP = 'G';\nvar PATH = 'PATH';\nvar RECT = 'RECT';\nvar LINE = 'LINE';\nvar CIRCLE = 'CIRCLE';\nvar ELLIPSE = 'ELLIPSE';\nvar POLYGON = 'POLYGON';\nvar POLYLINE = 'POLYLINE';\nvar DEFS = 'DEFS';\nvar TSPAN = 'TSPAN';\nvar CLIP_PATH = 'CLIP_PATH';\nvar STOP = 'STOP';\nvar LINEAR_GRADIENT = 'LINEAR_GRADIENT';\nvar RADIAL_GRADIENT = 'RADIAL_GRADIENT';\nvar DPI = 72; // 72pt per inch.\n// https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight#Common_weight_name_mapping\n\nvar FONT_WEIGHTS = {\n  thin: 100,\n  hairline: 100,\n  ultralight: 200,\n  extralight: 200,\n  light: 300,\n  normal: 400,\n  medium: 500,\n  semibold: 600,\n  demibold: 600,\n  bold: 700,\n  ultrabold: 800,\n  extrabold: 800,\n  heavy: 900,\n  black: 900\n};\nvar PAGE_SIZES = {\n  '4A0': [4767.87, 6740.79],\n  '2A0': [3370.39, 4767.87],\n  A0: [2383.94, 3370.39],\n  A1: [1683.78, 2383.94],\n  A2: [1190.55, 1683.78],\n  A3: [841.89, 1190.55],\n  A4: [595.28, 841.89],\n  A5: [419.53, 595.28],\n  A6: [297.64, 419.53],\n  A7: [209.76, 297.64],\n  A8: [147.4, 209.76],\n  A9: [104.88, 147.4],\n  A10: [73.7, 104.88],\n  B0: [2834.65, 4008.19],\n  B1: [2004.09, 2834.65],\n  B2: [1417.32, 2004.09],\n  B3: [1000.63, 1417.32],\n  B4: [708.66, 1000.63],\n  B5: [498.9, 708.66],\n  B6: [354.33, 498.9],\n  B7: [249.45, 354.33],\n  B8: [175.75, 249.45],\n  B9: [124.72, 175.75],\n  B10: [87.87, 124.72],\n  C0: [2599.37, 3676.54],\n  C1: [1836.85, 2599.37],\n  C2: [1298.27, 1836.85],\n  C3: [918.43, 1298.27],\n  C4: [649.13, 918.43],\n  C5: [459.21, 649.13],\n  C6: [323.15, 459.21],\n  C7: [229.61, 323.15],\n  C8: [161.57, 229.61],\n  C9: [113.39, 161.57],\n  C10: [79.37, 113.39],\n  RA0: [2437.8, 3458.27],\n  RA1: [1729.13, 2437.8],\n  RA2: [1218.9, 1729.13],\n  RA3: [864.57, 1218.9],\n  RA4: [609.45, 864.57],\n  SRA0: [2551.18, 3628.35],\n  SRA1: [1814.17, 2551.18],\n  SRA2: [1275.59, 1814.17],\n  SRA3: [907.09, 1275.59],\n  SRA4: [637.8, 907.09],\n  EXECUTIVE: [521.86, 756.0],\n  FOLIO: [612.0, 936.0],\n  LEGAL: [612.0, 1008.0],\n  LETTER: [612.0, 792.0],\n  TABLOID: [792.0, 1224.0]\n};\nvar PORTRAIT = 'portrait';\nvar LANDSCAPE = 'landscape';\nvar INHERITED_PROPERTIES = ['color', 'fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'letterSpacing', 'opacity', 'textDecoration', 'lineHeight', 'textAlign', 'visibility', 'wordSpacing'];\nvar SVG_INHERITED_PROPS = ['x', 'y', 'clipPath', 'clipRule', 'opacity', 'fill', 'fillOpacity', 'fillRule', 'stroke', 'strokeLinecap', 'strokeLinejoin', 'strokeOpacity', 'strokeWidth', 'textAnchor'].concat(INHERITED_PROPERTIES);\nvar RULER_WIDTH = 13;\nvar RULER_COLOR = 'white';\nvar RULER_FONT_SIZE = 6;\nvar DEFAULT_RULER_STEPS = 50;\nvar LINE_WIDTH = 0.5;\nvar LINE_COLOR = 'gray';\nvar GRID_COLOR = '#ababab';\nvar BOX_MODEL_REGEX = /\\d+(px|in|mm|cm|pt|%|vw|vh|px)?/g;\nvar OBJECT_POSITION_REGEX = /\\d+(px|in|mm|cm|pt|%|vw|vh|px)?/g;\nvar BORDER_SHORTHAND_REGEX = /(\\d+(px|in|mm|cm|pt|vw|vh|px)?)\\s(\\S+)\\s(\\S+)/;\nvar TRANSFORM_ORIGIN_REGEX = /(-?\\d+(px|in|mm|cm|pt|%|vw|vh|px)?)|top|right|bottom|left|center/g;\nvar matchBoxModel = match(BOX_MODEL_REGEX);\nvar matchObjectPosition = match(OBJECT_POSITION_REGEX);\nvar matchBorderShorthand = match(BORDER_SHORTHAND_REGEX);\nvar matchTransformOrigin = match(TRANSFORM_ORIGIN_REGEX);\nvar isNumber = is(Number);\n\nvar isFontWeightStyle = function isFontWeightStyle(key) {\n  return key.match(/^fontWeight/);\n};\n\nvar isBorderStyle = function isBorderStyle(key, value) {\n  return key.match(/^border(Top|Right|Bottom|Left)(Color|Width|Style)/) && typeof value === 'string';\n};\n\nvar isBoxModelStyle = function isBoxModelStyle(key, value) {\n  return key.match(/^(margin)|(padding)/) && typeof value === 'string';\n};\n\nvar isObjectPositionStyle = function isObjectPositionStyle(key, value) {\n  return key.match(/^objectPosition/) && typeof value === 'string';\n};\n\nvar isTransformOriginStyle = function isTransformOriginStyle(key, value) {\n  return key.match(/^transformOrigin/) && typeof value === 'string';\n};\n\nvar isFlexGrow = function isFlexGrow(key) {\n  return key === 'flexGrow';\n};\n\nvar isFlexShrink = function isFlexShrink(key) {\n  return key === 'flexShrink';\n};\n\nvar isFlexBasis = function isFlexBasis(key) {\n  return key === 'flexBasis';\n};\n\nvar processBorders = function processBorders(key, value) {\n  var match = matchBorderShorthand(value);\n\n  if (match) {\n    if (key.match(/Color$/)) {\n      return match[4] || value;\n    } else if (key.match(/Style$/)) {\n      return match[3] || value;\n    } else if (key.match(/Width$/)) {\n      return match[1] || value;\n    } else {\n      throw new Error(\"StyleSheet: Invalid '\" + value + \"' for '\" + key + \"'\");\n    }\n  }\n\n  return value;\n};\n\nvar processBoxModel = function processBoxModel(key, value) {\n  var match = matchBoxModel(value);\n\n  if (match) {\n    if (key.match(/Top$/)) {\n      return match[0];\n    } else if (key.match(/Right$/)) {\n      return match[1] || match[0];\n    } else if (key.match(/Bottom$/)) {\n      return match[2] || match[0];\n    } else if (key.match(/Left$/)) {\n      return match[3] || match[1] || match[0];\n    } else {\n      throw new Error(\"StyleSheet: Invalid '\" + value + \"' for '\" + key + \"'\");\n    }\n  }\n\n  return value;\n};\n\nvar processFontWeight = function processFontWeight(key, value) {\n  if (!value) return FONT_WEIGHTS.normal;\n  if (typeof value === 'number') return value;\n  return FONT_WEIGHTS[value.toLowerCase()];\n};\n\nvar processObjectPosition = function processObjectPosition(key, value) {\n  var match = matchObjectPosition(value);\n\n  if (match) {\n    if (key.match(/X$/)) {\n      return match[0] || value;\n    } else if (key.match(/Y$/)) {\n      return match[1] || value;\n    } else {\n      throw new Error(\"StyleSheet: Invalid '\" + value + \"' for '\" + key + \"'\");\n    }\n  }\n\n  return value;\n};\n\nvar transformOffsetKeywords = function transformOffsetKeywords(value) {\n  switch (value) {\n    case 'top':\n    case 'left':\n      return '0%';\n\n    case 'right':\n    case 'bottom':\n      return '100%';\n\n    case 'center':\n      return '50%';\n\n    default:\n      return value;\n  }\n}; // Transforms shorthand transformOrigin values\n\n\nvar processTransformOrigin = function processTransformOrigin(key, value) {\n  var match = matchTransformOrigin(value);\n\n  if (match) {\n    var result;\n\n    if (key.match(/X$/)) {\n      result = match[0] || value;\n    } else if (key.match(/Y$/)) {\n      result = match[1] || match[0] || value;\n    } else {\n      throw new Error(\"StyleSheet: Invalid '\" + value + \"' for '\" + key + \"'\");\n    }\n\n    return transformOffsetKeywords(result);\n  }\n\n  return value;\n};\n\nvar processFlexGrow = function processFlexGrow(key, value) {\n  if (isNumber(value)) return value;\n  var matches = value.split(' ');\n  return matches[0];\n};\n\nvar processFlexShrink = function processFlexShrink(key, value) {\n  if (isNumber(value)) return value;\n  var matches = value.split(' ');\n  return matches[1];\n};\n\nvar processFlexBasis = function processFlexBasis(key, value) {\n  if (isNumber(value)) return value;\n  var matches = value.split(' ');\n  return matches[2];\n};\n\nvar keepSame = function keepSame(key, value) {\n  return value;\n};\n\nvar matchNumber = when(is(String), test(/^-?\\d*\\.?\\d*$/));\nvar castFloat = when(matchNumber, function (v) {\n  return parseFloat(v, 10);\n});\n/**\n * Transforms style key-value\n *\n * @param {String} key style key\n * @param {String} value style value\n * @returns {String | Number} transformed style values\n */\n\nvar transformStyle = compose(castFloat, cond([[isBorderStyle, processBorders], [isBoxModelStyle, processBoxModel], [isObjectPositionStyle, processObjectPosition], [isTransformOriginStyle, processTransformOrigin], [isFontWeightStyle, processFontWeight], [isFlexGrow, processFlexGrow], [isFlexShrink, processFlexShrink], [isFlexBasis, processFlexBasis], [T, keepSame]]));\n/**\n * Transforms already expanded styles shortcuts into appropiate values\n * Ex. marginTopWidth: '2 solid red' -> marginTopWidth: 2\n *\n * @param {Object} styles expanded object\n * @returns {Object} transformed styles\n */\n\nvar transformStyles = mapObjIndexed(flip(transformStyle));\n\nvar fetchFont = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(src, options) {\n    var response, buffer;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return fetch(src, options);\n\n          case 2:\n            response = _context.sent;\n            _context.next = 5;\n            return response.buffer ? response.buffer() : response.arrayBuffer();\n\n          case 5:\n            buffer = _context.sent;\n            return _context.abrupt(\"return\", buffer.constructor.name === 'Buffer' ? buffer : Buffer.from(buffer));\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function fetchFont(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar FontSource = /*#__PURE__*/function () {\n  function FontSource(src, fontFamily, fontStyle, fontWeight, options) {\n    this.src = src;\n    this.fontFamily = fontFamily;\n    this.fontStyle = fontStyle || 'normal';\n    this.fontWeight = processFontWeight(fontWeight) || 400;\n    this.data = null;\n    this.loading = false;\n    this.options = options;\n  }\n\n  var _proto = FontSource.prototype;\n\n  _proto.load = /*#__PURE__*/function () {\n    var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      var _this = this;\n\n      var _this$options, headers, body, _this$options$method, method, data;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              this.loading = true;\n              _this$options = this.options, headers = _this$options.headers, body = _this$options.body, _this$options$method = _this$options.method, method = _this$options$method === void 0 ? 'GET' : _this$options$method;\n              _context2.next = 5;\n              return fetchFont(this.src, {\n                method: method,\n                body: body,\n                headers: headers\n              });\n\n            case 5:\n              data = _context2.sent;\n              this.data = fontkit.create(data);\n              _context2.next = 12;\n              break;\n\n            case 9:\n              _context2.next = 11;\n              return new Promise(function (resolve, reject) {\n                return fontkit.open(_this.src, function (err, data) {\n                  return err ? reject(err) : resolve(data);\n                });\n              });\n\n            case 11:\n              this.data = _context2.sent;\n\n            case 12:\n              this.loading = false;\n\n            case 13:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this);\n    }));\n\n    function load() {\n      return _load.apply(this, arguments);\n    }\n\n    return load;\n  }();\n\n  return FontSource;\n}();\n\nvar Font = /*#__PURE__*/function () {\n  Font.create = function create(family) {\n    return new Font(family);\n  };\n\n  function Font(family) {\n    this.family = family;\n    this.sources = [];\n  }\n\n  var _proto2 = Font.prototype;\n\n  _proto2.register = function register(_ref2) {\n    var src = _ref2.src,\n        fontWeight = _ref2.fontWeight,\n        fontStyle = _ref2.fontStyle,\n        options = _objectWithoutPropertiesLoose(_ref2, [\"src\", \"fontWeight\", \"fontStyle\"]);\n\n    this.sources.push(new FontSource(src, this.fontFamily, fontStyle, fontWeight, options));\n  };\n\n  _proto2.resolve = function resolve(descriptor) {\n    var _descriptor$fontWeigh = descriptor.fontWeight,\n        fontWeight = _descriptor$fontWeigh === void 0 ? 400 : _descriptor$fontWeigh,\n        _descriptor$fontStyle = descriptor.fontStyle,\n        fontStyle = _descriptor$fontStyle === void 0 ? 'normal' : _descriptor$fontStyle;\n    var styleSources = this.sources.filter(function (s) {\n      return s.fontStyle === fontStyle;\n    }); // Weight resolution. https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight#Fallback_weights\n\n    var exactFit = styleSources.find(function (s) {\n      return s.fontWeight === fontWeight;\n    });\n    if (exactFit) return exactFit;\n    var res;\n\n    if (fontWeight >= 400 && fontWeight <= 500) {\n      var leftOffset = styleSources.filter(function (s) {\n        return s.fontWeight <= fontWeight;\n      });\n      var rightOffset = styleSources.filter(function (s) {\n        return s.fontWeight > 500;\n      });\n      var fit = styleSources.filter(function (s) {\n        return s.fontWeight >= fontWeight && s.fontWeight < 500;\n      });\n      res = fit[0] || leftOffset[leftOffset.length - 1] || rightOffset[0];\n    }\n\n    var lt = styleSources.filter(function (s) {\n      return s.fontWeight < fontWeight;\n    });\n    var gt = styleSources.filter(function (s) {\n      return s.fontWeight > fontWeight;\n    });\n\n    if (fontWeight < 400) {\n      res = lt[lt.length - 1] || gt[0];\n    }\n\n    if (fontWeight > 500) {\n      res = gt[0] || lt[lt.length - 1];\n    }\n\n    if (!res) {\n      throw new Error(\"Could not resolve font for \" + this.fontFamily + \", fontWeight \" + fontWeight);\n    }\n\n    return res;\n  };\n\n  return Font;\n}();\n\nvar emojiSource;\n\nvar registerEmojiSource = function registerEmojiSource(_ref) {\n  var url = _ref.url,\n      _ref$format = _ref.format,\n      format = _ref$format === void 0 ? 'png' : _ref$format;\n  emojiSource = {\n    url: url,\n    format: format\n  };\n};\n\nvar getEmojiSource = function getEmojiSource() {\n  return emojiSource;\n};\n\nvar emoji = {\n  registerEmojiSource: registerEmojiSource,\n  getEmojiSource: getEmojiSource\n};\nvar standardFonts = ['Courier', 'Courier-Bold', 'Courier-Oblique', 'Helvetica', 'Helvetica-Bold', 'Helvetica-Oblique', 'Times-Roman', 'Times-Bold', 'Times-Italic'];\nvar hyphenationCallback;\n\nvar registerHyphenationCallback = function registerHyphenationCallback(callback) {\n  hyphenationCallback = callback;\n};\n\nvar getHyphenationCallback = function getHyphenationCallback() {\n  return hyphenationCallback;\n};\n\nvar hyphenation = {\n  registerHyphenationCallback: registerHyphenationCallback,\n  getHyphenationCallback: getHyphenationCallback\n};\nvar fonts = {};\n\nvar register = function register(data) {\n  var family = data.family;\n\n  if (!fonts[family]) {\n    fonts[family] = Font.create(family);\n  } // Bulk loading\n\n\n  if (data.fonts) {\n    for (var i = 0; i < data.fonts.length; i++) {\n      fonts[family].register(_extends({\n        family: family\n      }, data.fonts[i]));\n    }\n  } else {\n    fonts[family].register(data);\n  }\n};\n\nvar getRegisteredFonts = function getRegisteredFonts() {\n  return fonts;\n};\n\nvar getRegisteredFontFamilies = function getRegisteredFontFamilies() {\n  return Object.keys(fonts);\n};\n\nvar getFont = function getFont(descriptor) {\n  var fontFamily = descriptor.fontFamily;\n  var isStandard = standardFonts.includes(fontFamily);\n  if (isStandard) return null;\n\n  if (!fonts[fontFamily]) {\n    throw new Error(\"Font family not registered: \" + fontFamily + \". Please register it calling Font.register() method.\");\n  }\n\n  return fonts[fontFamily].resolve(descriptor);\n};\n\nvar load = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(descriptor) {\n    var fontFamily, isStandard, font;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            fontFamily = descriptor.fontFamily;\n            isStandard = standardFonts.includes(fontFamily);\n\n            if (!isStandard) {\n              _context.next = 4;\n              break;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 4:\n            font = getFont(descriptor); // We cache the font to avoid fetching it many times\n\n            if (!(!font.data && !font.loading)) {\n              _context.next = 8;\n              break;\n            }\n\n            _context.next = 8;\n            return font.load();\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function load(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar reset = function reset() {\n  for (var _font in fonts) {\n    if (fonts.hasOwnProperty(_font)) {\n      fonts[_font].data = null;\n    }\n  }\n};\n\nvar clear = function clear() {\n  fonts = {};\n};\n\nvar Font$1 = _extends({\n  register: register,\n  getRegisteredFonts: getRegisteredFonts,\n  getRegisteredFontFamilies: getRegisteredFontFamilies,\n  getFont: getFont,\n  load: load,\n  clear: clear,\n  reset: reset\n}, emoji, hyphenation);\n\nvar save = function save(ctx, node) {\n  ctx.save();\n  return node;\n};\n\nvar save$1 = curryN(2, save);\nvar PROTOCOL_REGEXP = /^([a-z]+\\:(\\/\\/)?)/i;\nvar DEST_REGEXP = /^#.+/;\n/**\n * Add protocol th URL if valid\n *\n * @param {String} value url\n * @returns {String} corrected url\n */\n\nvar getURL = function getURL(value) {\n  if (!value) return '';\n  if (isSrcId(value)) return value; // don't modify it if it is an id\n\n  if (typeof value === 'string' && !value.match(PROTOCOL_REGEXP)) {\n    return \"http://\" + value;\n  }\n\n  return value;\n};\n\nvar isSrcId = function isSrcId(src) {\n  return src.match(DEST_REGEXP);\n};\n\nvar DEST_REGEXP$1 = /^#.+/;\nvar isSrcId$1 = test(DEST_REGEXP$1);\nvar getSource = compose(either(path(['props', 'src']), path(['props', 'href'])));\n\nvar setLink = function setLink(ctx, node) {\n  var _node$box = node.box,\n      top = _node$box.top,\n      left = _node$box.left,\n      width = _node$box.width,\n      height = _node$box.height;\n  var src = getSource(node);\n  var instanceMethod = isSrcId$1(src) ? 'goTo' : 'link';\n  var value = isSrcId$1(src) ? src.slice(1) : getURL(src);\n\n  if (value) {\n    ctx[instanceMethod](left, top, width, height, value);\n  }\n\n  return node;\n};\n\nvar setLink$1 = curryN(2, setLink);\n\nvar restore = function restore(ctx, node) {\n  ctx.restore();\n  return node;\n};\n\nvar restore$1 = curryN(2, restore);\n/**\n * Checks if node is svg\n *\n * @param {Object} node\n * @returns {Boolean} is node svg?\n */\n\nvar isSvg = propEq('type', SVG);\n/**\n * Checks if node is text\n *\n * @param {Object} node\n * @returns {Boolean} is node text?\n */\n\nvar isText = propEq('type', TEXT);\n/**\n * Checks if node is page\n *\n * @param {Object} node\n * @returns {Boolean} is node page?\n */\n\nvar isPage = propEq('type', PAGE);\n/**\n * Checks if node has valid source prop\n *\n * @param {Object} node\n * @returns {Boolean} does node have source prop?\n */\n\nvar hasSource = either(hasPath(['props', 'src']), hasPath(['props', 'href']));\n/**\n * Checks if node is link\n *\n * @param {Object} node\n * @returns {Boolean} is node link?\n */\n\nvar isLink = either(propEq('type', LINK), both(propEq('type', TEXT), hasSource));\n/**\n * Checks if node is note\n *\n * @param {Object} node\n * @returns {Boolean} is node note?\n */\n\nvar isNote = propEq('type', NOTE);\n/**\n * Checks if node is image\n *\n * @param {Object} node\n * @returns {Boolean} is node image?\n */\n\nvar isImage = propEq('type', IMAGE);\n/**\n * Checks if node is canvas\n *\n * @param {Object} node\n * @returns {Boolean} is node canvas?\n */\n\nvar isCanvas = propEq('type', CANVAS); // Bezier curve.\n\nvar KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nvar clipNode = function clipNode(ctx, node) {\n  var _node$box = node.box,\n      top = _node$box.top,\n      left = _node$box.left,\n      width = _node$box.width,\n      height = _node$box.height;\n  var _node$style = node.style,\n      _node$style$borderTop = _node$style.borderTopLeftRadius,\n      borderTopLeftRadius = _node$style$borderTop === void 0 ? 0 : _node$style$borderTop,\n      _node$style$borderTop2 = _node$style.borderTopRightRadius,\n      borderTopRightRadius = _node$style$borderTop2 === void 0 ? 0 : _node$style$borderTop2,\n      _node$style$borderBot = _node$style.borderBottomRightRadius,\n      borderBottomRightRadius = _node$style$borderBot === void 0 ? 0 : _node$style$borderBot,\n      _node$style$borderBot2 = _node$style.borderBottomLeftRadius,\n      borderBottomLeftRadius = _node$style$borderBot2 === void 0 ? 0 : _node$style$borderBot2; // Border top\n\n  var rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  var ctr = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left + rtr, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - ctr, top, left + width, top + ctr, left + width, top + rtr); // Border right\n\n  var rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  var cbr = rbr * (1.0 - KAPPA);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - cbr, left + width - cbr, top + height, left + width - rbr, top + height); // Border bottom\n\n  var rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  var cbl = rbl * (1.0 - KAPPA);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + cbl, top + height, left, top + height - cbl, left, top + height - rbl); // Border left\n\n  var rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  var ctl = rtl * (1.0 - KAPPA);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n  return node;\n};\n\nvar clipNode$1 = curryN(2, clipNode);\n\nvar renderPath = function renderPath(ctx) {\n  return tap(function (node) {\n    var d = path(['props', 'd'], node);\n    if (d) ctx.path(node.props.d);\n  });\n};\n\nvar KAPPA$1 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nvar getProp = function getProp(d, p, v) {\n  return pathOr(d, ['props', p], v);\n};\n\nvar renderRect = function renderRect(ctx) {\n  return function (node) {\n    var x = getProp(0, 'x', node);\n    var y = getProp(0, 'y', node);\n    var rx = getProp(0, 'rx', node);\n    var ry = getProp(0, 'ry', node);\n    var width = getProp(0, 'width', node);\n    var height = getProp(0, 'height', node);\n    if (!width || !height) return node;\n\n    if (rx && ry) {\n      var krx = rx * KAPPA$1;\n      var kry = ry * KAPPA$1;\n      ctx.moveTo(x + rx, y);\n      ctx.lineTo(x - rx + width, y);\n      ctx.bezierCurveTo(x - rx + width + krx, y, x + width, y + ry - kry, x + width, y + ry);\n      ctx.lineTo(x + width, y + height - ry);\n      ctx.bezierCurveTo(x + width, y + height - ry + kry, x - rx + width + krx, y + height, x - rx + width, y + height);\n      ctx.lineTo(x + rx, y + height);\n      ctx.bezierCurveTo(x + rx - krx, y + height, x, y + height - ry + kry, x, y + height - ry);\n      ctx.lineTo(x, y + ry);\n      ctx.bezierCurveTo(x, y + ry - kry, x + rx - krx, y, x + rx, y);\n    } else {\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + width, y);\n      ctx.lineTo(x + width, y + height);\n      ctx.lineTo(x, y + height);\n    }\n\n    ctx.closePath();\n    return node;\n  };\n};\n\nvar getProp$1 = function getProp(p, v) {\n  return path(['props', p], v);\n};\n\nvar renderLine = function renderLine(ctx) {\n  return function (node) {\n    var x1 = getProp$1('x1', node);\n    var y1 = getProp$1('y1', node);\n    var x2 = getProp$1('x2', node);\n    var y2 = getProp$1('y2', node);\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    return node;\n  };\n};\n\nvar KAPPA$2 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nvar getProp$2 = function getProp(p, v) {\n  return path(['props', p], v);\n};\n\nvar drawEllipse = function drawEllipse(ctx, cx, cy, rx, ry) {\n  var x = cx - rx;\n  var y = cy - ry;\n  var ox = rx * KAPPA$2;\n  var oy = ry * KAPPA$2;\n  var xe = x + rx * 2;\n  var ye = y + ry * 2;\n  var xm = x + rx;\n  var ym = y + ry;\n  ctx.moveTo(x, ym);\n  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n  ctx.closePath();\n};\n\nvar renderEllipse = function renderEllipse(ctx) {\n  return tap(function (node) {\n    var cx = getProp$2('cx', node);\n    var cy = getProp$2('cy', node);\n    var rx = getProp$2('rx', node);\n    var ry = getProp$2('ry', node);\n    drawEllipse(ctx, cx, cy, rx, ry);\n  });\n};\n\nvar getProp$3 = function getProp(p, v) {\n  return path(['props', p], v);\n};\n\nvar renderCircle = function renderCircle(ctx) {\n  return tap(function (node) {\n    var cx = getProp$3('cx', node);\n    var cy = getProp$3('cy', node);\n    var r = getProp$3('r', node);\n    drawEllipse(ctx, cx, cy, r, r);\n  });\n};\n\nvar renderRun = function renderRun(ctx, run) {\n  var runAdvanceWidth = runWidth(run);\n  var _run$attributes = run.attributes,\n      font = _run$attributes.font,\n      fontSize = _run$attributes.fontSize,\n      color = _run$attributes.color,\n      opacity = _run$attributes.opacity;\n  ctx.fillColor(color);\n  ctx.fillOpacity(opacity);\n\n  if (font.sbix || font.COLR && font.CPAL) {\n    ctx.save();\n    ctx.translate(0, -run.ascent);\n\n    for (var i = 0; i < run.glyphs.length; i++) {\n      var position = run.positions[i];\n      var glyph = run.glyphs[i];\n      ctx.save();\n      ctx.translate(position.xOffset, position.yOffset);\n      glyph.render(ctx, fontSize);\n      ctx.restore();\n      ctx.translate(position.xAdvance, position.yAdvance);\n    }\n\n    ctx.restore();\n  } else {\n    ctx.font(typeof font.name === 'string' ? font.name : font, fontSize);\n\n    try {\n      ctx._addGlyphs(run.glyphs, run.positions, 0, 0);\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  ctx.translate(runAdvanceWidth, 0);\n};\n\nvar renderSpan = function renderSpan(ctx, line, textAnchor) {\n  ctx.save();\n  var x = pathOr(0, ['box', 'x'], line);\n  var y = pathOr(0, ['box', 'y'], line);\n  var width = lineWidth(line);\n\n  switch (textAnchor) {\n    case 'middle':\n      ctx.translate(x - width / 2, y);\n      break;\n\n    case 'end':\n      ctx.translate(x - width, y);\n      break;\n\n    default:\n      ctx.translate(x, y);\n      break;\n  }\n\n  for (var _iterator = line.runs, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var run = _ref;\n    renderRun(ctx, run);\n  }\n\n  ctx.restore();\n};\n\nvar renderSvgText = function renderSvgText(ctx) {\n  return function (node) {\n    for (var _iterator2 = node.children, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var span = _ref2;\n      renderSpan(ctx, span.lines[0], span.props.textAnchor);\n    }\n\n    return node;\n  };\n};\n\nvar isOdd = function isOdd(x) {\n  return x % 2 !== 0;\n};\n\nvar lengthIsOdd = o(isOdd, prop('length'));\nvar parsePoints = compose(splitEvery(2), map(parseFloat), when(lengthIsOdd, slice(0, -1)), split$1(/\\s+/), replace(/(\\d)-(\\d)/g, '$1 -$2'), replace(/,/g, ' '), trim);\n\nvar drawPolyline = function drawPolyline(ctx) {\n  return function (points) {\n    if (points.length > 0) {\n      ctx.moveTo(points[0][0], points[0][1]);\n      points.slice(1).forEach(function (p) {\n        return ctx.lineTo(p[0], p[1]);\n      });\n    }\n  };\n};\n\nvar renderPolyline = function renderPolyline(ctx) {\n  return tap(compose(drawPolyline(ctx), parsePoints, pathOr('', ['props', 'points'])));\n};\n\nvar closePath = function closePath(ctx) {\n  return tap(function () {\n    return ctx.closePath();\n  });\n};\n\nvar renderPolygon = function renderPolygon(ctx) {\n  return compose(closePath(ctx), renderPolyline(ctx));\n};\n\nfunction printWarning(format) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  var argIndex = 0;\n  var message = 'Warning: ' + format.replace(/%s/g, function () {\n    return args[argIndex++];\n  });\n\n  if (typeof console !== 'undefined') {\n    console.error(message);\n  }\n\n  try {\n    throw new Error(message);\n  } catch (x) {}\n}\n\nvar __DEV__ = process.env.NODE_ENV !== 'production';\n\nvar warning = __DEV__ ? function (condition, format) {\n  if (format === undefined) {\n    throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n  }\n\n  if (!condition) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      args[_key2 - 2] = arguments[_key2];\n    }\n\n    printWarning.apply(void 0, [format].concat(args));\n  }\n} : function () {};\n\nvar drawImage = function drawImage(ctx) {\n  return function (node) {\n    var _node$props = node.props,\n        x = _node$props.x,\n        y = _node$props.y;\n    var _node$style = node.style,\n        width = _node$style.width,\n        height = _node$style.height,\n        opacity = _node$style.opacity;\n    var paddingTop = node.box.paddingLeft || 0;\n    var paddingLeft = node.box.paddingLeft || 0;\n\n    if (node.image.data) {\n      if (width !== 0 && height !== 0) {\n        ctx.fillOpacity(opacity || 1).image(node.image.data, x + paddingLeft, y + paddingTop, {\n          width: width,\n          height: height\n        });\n      } else {\n        warning(false, \"Image with src '\" + node.props.href + \"' skipped due to invalid dimensions\");\n      }\n    }\n\n    return node;\n  };\n};\n\nvar renderImage = function renderImage(ctx, node) {\n  compose(restore$1(ctx), drawImage(ctx), save$1(ctx))(node);\n  return node;\n};\n\nvar renderSvgImage = curryN(2, renderImage);\n\nvar getRotation = function getRotation(transform) {\n  var match = /rotate\\((-?\\d+.?\\d+)(.+)\\)/g.exec(transform);\n\n  if (match && match[1] && match[2]) {\n    var value = match[1];\n    return match[2] === 'rad' ? value * 180 / Math.PI : value;\n  }\n\n  return 0;\n};\n\nvar getTranslateX = function getTranslateX(transform) {\n  var matchX = /translateX\\((-?\\d+\\.?d*)\\)/g.exec(transform);\n  var matchGeneric = /translate\\((-?\\d+\\.?d*).*(,|\\s)\\s*(-?\\d+\\.?d*).*\\)/g.exec(transform);\n  if (matchX && matchX[1]) return matchX[1];\n  if (matchGeneric && matchGeneric[1]) return matchGeneric[1];\n  return 0;\n};\n\nvar getTranslateY = function getTranslateY(transform) {\n  var matchY = /translateY\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  var matchGeneric = /translate\\((-?\\d+\\.?\\d*).*(,|\\s)\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(transform);\n  if (matchY && matchY[1]) return matchY[1];\n  if (matchGeneric && matchGeneric[3]) return matchGeneric[3];\n  return 0;\n};\n\nvar getScaleX = function getScaleX(transform) {\n  var matchX = /scaleX\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  var matchGeneric = /scale\\((-?\\d+\\.?\\d*).*,?\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(transform);\n  if (matchX && matchX[1]) return matchX[1];\n  if (matchGeneric && matchGeneric[1]) return matchGeneric[1];\n  return 1;\n};\n\nvar getScaleY = function getScaleY(transform) {\n  var matchY = /scaleY\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  var matchGeneric = /scale\\((-?\\d+\\.?\\d*).*,?\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(transform);\n  if (matchY && matchY[1]) return matchY[1];\n  if (matchGeneric && matchGeneric[2]) return matchGeneric[2];\n  return 1;\n};\n\nvar getMatrix = function getMatrix(transform) {\n  var match = /matrix\\(([^,]+),([^,]+),([^,]+),([^,]+),([^,]+),([^,]+)\\)/g.exec(transform);\n  if (match) return match.slice(1, 7);\n  return null;\n};\n\nvar applySingleTransformation = function applySingleTransformation(ctx, transform, origin) {\n  if (/rotate/g.test(transform)) {\n    ctx.rotate(getRotation(transform), {\n      origin: origin\n    });\n  } else if (/scaleX/g.test(transform)) {\n    ctx.scale(getScaleX(transform), 1, {\n      origin: origin\n    });\n  } else if (/scaleY/g.test(transform)) {\n    ctx.scale(1, getScaleY(transform), {\n      origin: origin\n    });\n  } else if (/scale/g.test(transform)) {\n    ctx.scale(getScaleX(transform), getScaleY(transform), {\n      origin: origin\n    });\n  } else if (/translateX/g.test(transform)) {\n    ctx.translate(getTranslateX(transform), 1, {\n      origin: origin\n    });\n  } else if (/translateY/g.test(transform)) {\n    ctx.translate(1, getTranslateY(transform), {\n      origin: origin\n    });\n  } else if (/translate/g.test(transform)) {\n    ctx.translate(getTranslateX(transform), getTranslateY(transform), {\n      origin: origin\n    });\n  } else if (/matrix/g.test(transform)) {\n    ctx.transform.apply(ctx, getMatrix(transform));\n  }\n};\n\nvar applyTransformations = function applyTransformations(ctx, node) {\n  if (!node.origin) return node;\n  var match;\n  var re = /[a-zA-Z]+\\([^)]+\\)/g;\n  var origin = [node.origin.left, node.origin.top];\n  var transform = node.style && node.style.transform || node.props && node.props.transform || '';\n\n  while ((match = re.exec(transform)) != null) {\n    applySingleTransformation(ctx, match[0], origin);\n  }\n\n  return node;\n};\n\nvar applyTransformations$1 = curryN(2, applyTransformations);\n/**\n * Checks if node is path\n *\n * @param {Object} node\n * @returns {Boolean} is node path?\n */\n\nvar isPath = propEq('type', PATH);\n/**\n * Checks if node is rect\n *\n * @param {Object} node\n * @returns {Boolean} is node rect?\n */\n\nvar isRect = propEq('type', RECT);\n/**\n * Checks if node is line\n *\n * @param {Object} node\n * @returns {Boolean} is node line?\n */\n\nvar isLine = propEq('type', LINE);\n/**\n * Checks if node is tspan\n *\n * @param {Object} node\n * @returns {Boolean} is node tspan?\n */\n\nvar isTspan = propEq('type', TSPAN);\n/**\n * Checks if node is group\n *\n * @param {Object} node\n * @returns {Boolean} is node group?\n */\n\nvar isGroup = propEq('type', GROUP);\n/**\n * Checks if node is circle\n *\n * @param {Object} node\n * @returns {Boolean} is node circle?\n */\n\nvar isCircle = propEq('type', CIRCLE);\n/**\n * Checks if node is text intance\n *\n * @param {Object} node\n * @returns {Boolean} is node text intance?\n */\n\nvar isTextInstance = propEq('type', TEXT_INSTANCE);\n\nvar renderGroup = function renderGroup() {\n  return identity;\n};\n/**\n * Checks if node is ellipse\n *\n * @param {Object} node\n * @returns {Boolean} is node ellipse?\n */\n\n\nvar isEllipse = propEq('type', ELLIPSE);\n/**\n * Checks if node is polygon\n *\n * @param {Object} node\n * @returns {Boolean} is node polygon?\n */\n\nvar isPolygon = propEq('type', POLYGON);\n/**\n * Checks if node is polyline\n *\n * @param {Object} node\n * @returns {Boolean} is node polyline?\n */\n\nvar isPolyline = propEq('type', POLYLINE); // Copied here because an import issue with 'svg-arc-to-cubic-bezier'\n\nvar normalizePath = function normalizePath(path) {\n  var result = [];\n  var prev;\n  var bezierX = 0;\n  var bezierY = 0;\n  var startX = 0;\n  var startY = 0;\n  var quadX = null;\n  var quadY = null;\n  var x = 0;\n  var y = 0;\n\n  for (var i = 0, len = path.length; i < len; i++) {\n    var seg = path[i];\n    var command = seg[0];\n\n    switch (command) {\n      case 'M':\n        startX = seg[1];\n        startY = seg[2];\n        break;\n\n      case 'A':\n        var curves = arcToCurve({\n          px: x,\n          py: y,\n          cx: seg[6],\n          cy: seg[7],\n          rx: seg[1],\n          ry: seg[2],\n          xAxisRotation: seg[3],\n          largeArcFlag: seg[4],\n          sweepFlag: seg[5]\n        }); // null-curves\n\n        if (!curves.length) continue;\n\n        for (var j = 0, c; j < curves.length; j++) {\n          c = curves[j];\n          seg = ['C', c.x1, c.y1, c.x2, c.y2, c.x, c.y];\n          if (j < curves.length - 1) result.push(seg);\n        }\n\n        break;\n\n      case 'S':\n        // default control point\n        var cx = x;\n        var cy = y;\n\n        if (prev === 'C' || prev === 'S') {\n          cx += cx - bezierX; // reflect the previous command's control\n\n          cy += cy - bezierY; // point relative to the current point\n        }\n\n        seg = ['C', cx, cy, seg[1], seg[2], seg[3], seg[4]];\n        break;\n\n      case 'T':\n        if (prev === 'Q' || prev === 'T') {\n          quadX = x * 2 - quadX; // as with 'S' reflect previous control point\n\n          quadY = y * 2 - quadY;\n        } else {\n          quadX = x;\n          quadY = y;\n        }\n\n        seg = quadratic(x, y, quadX, quadY, seg[1], seg[2]);\n        break;\n\n      case 'Q':\n        quadX = seg[1];\n        quadY = seg[2];\n        seg = quadratic(x, y, seg[1], seg[2], seg[3], seg[4]);\n        break;\n\n      case 'L':\n        seg = line(x, y, seg[1], seg[2]);\n        break;\n\n      case 'H':\n        seg = line(x, y, seg[1], y);\n        break;\n\n      case 'V':\n        seg = line(x, y, x, seg[1]);\n        break;\n\n      case 'Z':\n        seg = line(x, y, startX, startY);\n        break;\n\n      default:\n        break;\n    } // update state\n\n\n    prev = command;\n    x = seg[seg.length - 2];\n    y = seg[seg.length - 1];\n\n    if (seg.length > 4) {\n      bezierX = seg[seg.length - 4];\n      bezierY = seg[seg.length - 3];\n    } else {\n      bezierX = x;\n      bezierY = y;\n    }\n\n    result.push(seg);\n  }\n\n  return result;\n};\n\nvar line = function line(x1, y1, x2, y2) {\n  return ['C', x1, y1, x2, y2, x2, y2];\n};\n\nvar quadratic = function quadratic(x1, y1, cx, cy, x2, y2) {\n  return ['C', x1 / 3 + 2 / 3 * cx, y1 / 3 + 2 / 3 * cy, x2 / 3 + 2 / 3 * cx, y2 / 3 + 2 / 3 * cy, x2, y2];\n};\n\nvar getPathBoundingBox = function getPathBoundingBox(node) {\n  var path = compose(normalizePath, absPath, parsePath, pathOr('', ['props', 'd']))(node);\n  if (!path.length) return [0, 0, 0, 0];\n  var bounds = [Infinity, Infinity, -Infinity, -Infinity];\n\n  for (var i = 0, l = path.length; i < l; i++) {\n    var points = path[i].slice(1);\n\n    for (var j = 0; j < points.length; j += 2) {\n      if (points[j + 0] < bounds[0]) bounds[0] = points[j + 0];\n      if (points[j + 1] < bounds[1]) bounds[1] = points[j + 1];\n      if (points[j + 0] > bounds[2]) bounds[2] = points[j + 0];\n      if (points[j + 1] > bounds[3]) bounds[3] = points[j + 1];\n    }\n  }\n\n  return bounds;\n};\n\nvar getCircleBoundingBox = function getCircleBoundingBox(node) {\n  var r = pathOr(0, ['props', 'r'], node);\n  var cx = pathOr(0, ['props', 'cx'], node);\n  var cy = pathOr(0, ['props', 'cy'], node);\n  return [cx - r, cy - r, cx + r, cy + r];\n};\n\nvar getEllipseBoundingBox = function getEllipseBoundingBox(node) {\n  var cx = pathOr(0, ['props', 'cx'], node);\n  var cy = pathOr(0, ['props', 'cy'], node);\n  var rx = pathOr(0, ['props', 'rx'], node);\n  var ry = pathOr(0, ['props', 'ry'], node);\n  return [cx - rx, cy - ry, cx + rx, cy + ry];\n};\n\nvar getLineBoundingBox = function getLineBoundingBox(node) {\n  var x1 = pathOr(0, ['props', 'x1'], node);\n  var y1 = pathOr(0, ['props', 'y1'], node);\n  var x2 = pathOr(0, ['props', 'x2'], node);\n  var y2 = pathOr(0, ['props', 'y2'], node);\n  return [min$1(x1, x2), min$1(y1, y2), max$1(x1, x2), max$1(y1, y2)];\n};\n\nvar getRectBoundingBox = function getRectBoundingBox(node) {\n  var x = pathOr(0, ['props', 'x'], node);\n  var y = pathOr(0, ['props', 'y'], node);\n  var width = pathOr(0, ['props', 'width'], node);\n  var height = pathOr(0, ['props', 'height'], node);\n  return [x, y, x + width, y + height];\n};\n\nvar max = reduce(max$1, -Infinity);\nvar min = reduce(min$1, Infinity);\n\nvar getPolylineBoundingBox = function getPolylineBoundingBox(node) {\n  var points = compose(parsePoints, pathOr([], ['props', 'points']))(node);\n  var xValues = pluck(0, points);\n  var yValues = pluck(1, points);\n  return [min(xValues), min(yValues), max(xValues), max(yValues)];\n};\n\nvar getBoundingBox = cond([[isRect, getRectBoundingBox], [isLine, getLineBoundingBox], [isPath, getPathBoundingBox], [isCircle, getCircleBoundingBox], [isEllipse, getEllipseBoundingBox], [isPolygon, getPolylineBoundingBox], [isPolyline, getPolylineBoundingBox], [T, always([0, 0, 0, 0])]]);\nvar warnUnsupportedNode = tap(function (node) {\n  console.warn(\"SVG node of type \" + node.type + \" is not currenty supported\");\n});\n\nvar getProp$4 = function getProp(d, p, v) {\n  return pathOr(d, ['props', p], v);\n};\n\nvar setStrokeWidth = function setStrokeWidth(ctx) {\n  return function (node) {\n    var lineWidth = getProp$4(0, 'strokeWidth', node);\n    if (lineWidth) ctx.lineWidth(lineWidth);\n    return node;\n  };\n};\n\nvar setStrokeColor = function setStrokeColor(ctx) {\n  return function (node) {\n    var strokeColor = getProp$4(null, 'stroke', node);\n    if (strokeColor) ctx.strokeColor(strokeColor);\n    return node;\n  };\n};\n\nvar setOpacity = function setOpacity(ctx) {\n  return function (node) {\n    var opacity = getProp$4(null, 'opacity', node);\n    if (opacity) ctx.opacity(opacity);\n    return node;\n  };\n};\n\nvar setFillOpacity = function setFillOpacity(ctx) {\n  return function (node) {\n    var fillOpacity = getProp$4(null, 'fillOpacity', node);\n    if (fillOpacity) ctx.fillOpacity(fillOpacity);\n    return node;\n  };\n};\n\nvar setStrokeOpacity = function setStrokeOpacity(ctx) {\n  return function (node) {\n    var strokeOpacity = getProp$4(null, 'strokeOpacity', node);\n    if (strokeOpacity) ctx.strokeOpacity(strokeOpacity);\n    return node;\n  };\n};\n\nvar setLineJoin = function setLineJoin(ctx) {\n  return function (node) {\n    var lineJoin = getProp$4(null, 'strokeLinejoin', node);\n    if (lineJoin) ctx.lineJoin(lineJoin);\n    return node;\n  };\n};\n\nvar setLineCap = function setLineCap(ctx) {\n  return function (node) {\n    var lineCap = getProp$4(null, 'strokeLinecap', node);\n    if (lineCap) ctx.lineCap(lineCap);\n    return node;\n  };\n};\n\nvar setLineDash = function setLineDash(ctx) {\n  return function (node) {\n    var value = getProp$4(null, 'strokeDasharray', node);\n\n    if (value) {\n      var dashArray = compose(map(o(parseFloat, trim)), split$1(','))(value);\n      ctx.dash(dashArray[0], {\n        space: dashArray[1]\n      });\n    }\n\n    return node;\n  };\n};\n\nvar hasLinearGradientFill = pathEq(['props', 'fill', 'type'], LINEAR_GRADIENT);\nvar hasRadialGradientFill = pathEq(['props', 'fill', 'type'], RADIAL_GRADIENT); // Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L104\n\nvar setLinearGradientFill = function setLinearGradientFill(ctx) {\n  return tap(function (node) {\n    var bbox = getBoundingBox(node);\n    var gradient = getProp$4(null, 'fill', node);\n    var x1 = pathOr(0, ['props', 'x1'], gradient);\n    var y1 = pathOr(0, ['props', 'y1'], gradient);\n    var x2 = pathOr(1, ['props', 'x2'], gradient);\n    var y2 = pathOr(0, ['props', 'y2'], gradient);\n    var m0 = bbox[2] - bbox[0];\n    var m3 = bbox[3] - bbox[1];\n    var m4 = bbox[0];\n    var m5 = bbox[1];\n    var gx1 = m0 * x1 + m4;\n    var gy1 = m3 * y1 + m5;\n    var gx2 = m0 * x2 + m4;\n    var gy2 = m3 * y2 + m5;\n    var grad = ctx.linearGradient(gx1, gy1, gx2, gy2);\n    gradient.children.forEach(function (stop) {\n      grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n    });\n    ctx.fill(grad);\n  });\n}; // Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L155\n\n\nvar setRadialGradientFill = function setRadialGradientFill(ctx) {\n  return tap(function (node) {\n    var bbox = getBoundingBox(node);\n    var gradient = getProp$4(null, 'fill', node);\n    var cx = pathOr(0.5, ['props', 'cx'], gradient);\n    var cy = pathOr(0.5, ['props', 'cy'], gradient);\n    var fx = pathOr(cx, ['props', 'fx'], gradient);\n    var fy = pathOr(cy, ['props', 'fy'], gradient);\n    var r = pathOr(0.5, ['props', 'r'], gradient);\n    var m0 = bbox[2] - bbox[0];\n    var m3 = bbox[3] - bbox[1];\n    var m4 = bbox[0];\n    var m5 = bbox[1];\n    var gr = r * m0;\n    var gcx = m0 * cx + m4;\n    var gcy = m3 * cy + m5;\n    var gfx = m0 * fx + m4;\n    var gfy = m3 * fy + m5;\n    var grad = ctx.radialGradient(gfx, gfy, 0, gcx, gcy, gr);\n    gradient.children.forEach(function (stop) {\n      grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n    });\n    ctx.fill(grad);\n  });\n};\n\nvar setFillColor = function setFillColor(ctx) {\n  return tap(function (node) {\n    var fillColor = getProp$4(null, 'fill', node);\n    if (fillColor) ctx.fillColor(fillColor);\n  });\n};\n\nvar setFill = function setFill(ctx) {\n  return cond([[hasLinearGradientFill, setLinearGradientFill(ctx)], [hasRadialGradientFill, setRadialGradientFill(ctx)], [T, setFillColor(ctx)]]);\n};\n\nvar draw = function draw(ctx) {\n  return function (node) {\n    var props = propOr({}, 'props', node);\n\n    if (props.fill && props.stroke) {\n      ctx.fillAndStroke(props.fillRule);\n    } else if (props.fill) {\n      ctx.fill(props.fillRule);\n    } else if (props.stroke) {\n      ctx.stroke();\n    } else {\n      ctx.save();\n      ctx.opacity(0);\n      ctx.fill(null);\n      ctx.restore();\n    }\n\n    return node;\n  };\n};\n\nvar renderNode = function renderNode(ctx) {\n  return cond([[isTspan, identity], [isTextInstance, identity], [isPath, renderPath(ctx)], [isRect, renderRect(ctx)], [isLine, renderLine(ctx)], [isGroup, renderGroup(ctx)], [isText, renderSvgText(ctx)], [isCircle, renderCircle(ctx)], [isImage, renderSvgImage(ctx)], [isEllipse, renderEllipse(ctx)], [isPolygon, renderPolygon(ctx)], [isPolyline, renderPolyline(ctx)], [T, warnUnsupportedNode]]);\n};\n\nvar drawNode = function drawNode(ctx) {\n  return compose(draw(ctx), renderNode(ctx), applyTransformations$1(ctx), setOpacity(ctx), setFillOpacity(ctx), setStrokeOpacity(ctx), setFill(ctx), setStrokeColor(ctx), setStrokeWidth(ctx), setLineJoin(ctx), setLineDash(ctx), setLineCap(ctx));\n};\n\nvar clipPath = function clipPath(ctx) {\n  return function (node) {\n    var value = path(['props', 'clipPath'], node);\n\n    if (value) {\n      compose(function () {\n        return ctx.clip();\n      }, forEach(renderNode(ctx)), propOr([], 'children'))(value);\n    }\n\n    return node;\n  };\n};\n\nvar drawChildren = function drawChildren(ctx) {\n  return function (node) {\n    return compose(map(compose(restore$1(ctx), drawChildren(ctx), drawNode(ctx), clipPath(ctx), save$1(ctx))), propOr([], 'children'))(node);\n  };\n};\n\nvar defaultsZero = pathOr(0);\n\nvar preserveAspectRatio = function preserveAspectRatio(ctx) {\n  return function (node) {\n    var _node$box = node.box,\n        width = _node$box.width,\n        height = _node$box.height;\n    var _node$props = node.props,\n        viewBox = _node$props.viewBox,\n        _node$props$preserveA = _node$props.preserveAspectRatio,\n        preserveAspectRatio = _node$props$preserveA === void 0 ? {} : _node$props$preserveA;\n    var _preserveAspectRatio$ = preserveAspectRatio.meetOrSlice,\n        meetOrSlice = _preserveAspectRatio$ === void 0 ? 'meet' : _preserveAspectRatio$,\n        _preserveAspectRatio$2 = preserveAspectRatio.align,\n        align = _preserveAspectRatio$2 === void 0 ? 'xMidYMid' : _preserveAspectRatio$2;\n    if (viewBox == null || width == null || height == null) return node;\n    var x = viewBox ? viewBox.minX : 0;\n    var y = viewBox ? viewBox.minY : 0;\n    var logicalWidth = viewBox ? viewBox.maxX : width;\n    var logicalHeight = viewBox ? viewBox.maxY : height;\n    var logicalRatio = logicalWidth / logicalHeight;\n    var physicalRatio = width / height;\n    var scaleX = width / logicalWidth;\n    var scaleY = height / logicalHeight;\n\n    if (align === 'none') {\n      ctx.scale(scaleX, scaleY);\n      ctx.translate(-x, -y);\n      return node;\n    }\n\n    if (logicalRatio < physicalRatio && meetOrSlice === 'meet' || logicalRatio >= physicalRatio && meetOrSlice === 'slice') {\n      ctx.scale(scaleY, scaleY);\n\n      switch (align) {\n        case 'xMinYMin':\n        case 'xMinYMid':\n        case 'xMinYMax':\n          ctx.translate(-x, -y);\n          break;\n\n        case 'xMidYMin':\n        case 'xMidYMid':\n        case 'xMidYMax':\n          ctx.translate(-x - (logicalWidth - width * logicalHeight / height) / 2, -y);\n          break;\n\n        default:\n          ctx.translate(-x - (logicalWidth - width * logicalHeight / height), -y);\n      }\n    } else {\n      ctx.scale(scaleX, scaleX);\n\n      switch (align) {\n        case 'xMinYMin':\n        case 'xMidYMin':\n        case 'xMaxYMin':\n          ctx.translate(-x, -y);\n          break;\n\n        case 'xMinYMid':\n        case 'xMidYMid':\n        case 'xMaxYMid':\n          ctx.translate(-x, -y - (logicalHeight - height * logicalWidth / width) / 2);\n          break;\n\n        default:\n          ctx.translate(-x, -y - (logicalHeight - height * logicalWidth / width));\n      }\n    }\n\n    return node;\n  };\n};\n\nvar moveToOrigin = function moveToOrigin(ctx) {\n  return function (node) {\n    var _node$box2 = node.box,\n        top = _node$box2.top,\n        left = _node$box2.left;\n    var paddingLeft = defaultsZero('paddingLeft', node.box);\n    var paddingTop = defaultsZero('paddingTop', node.box);\n    ctx.translate(left + paddingLeft, top + paddingTop);\n    return node;\n  };\n};\n\nvar renderSvg = function renderSvg(ctx, node) {\n  compose(restore$1(ctx), drawChildren(ctx), preserveAspectRatio(ctx), moveToOrigin(ctx), clipNode$1(ctx), save$1(ctx))(node);\n  return node;\n};\n\nvar renderSvg$1 = curryN(2, renderSvg);\n\nvar renderText = function renderText(ctx, node) {\n  var _node$box = node.box,\n      top = _node$box.top,\n      left = _node$box.left;\n  var paddingTop = pathOr(0, ['box', 'paddingTop'], node);\n  var paddingLeft = pathOr(0, ['box', 'paddingLeft'], node);\n  var initialY = node.lines[0] ? node.lines[0].box.y : 0;\n  ctx.save();\n  ctx.translate(left + paddingLeft, top + paddingTop - initialY);\n  PDFRenderer.render(ctx, [node.lines]);\n  ctx.restore();\n  return node;\n};\n\nvar renderText$1 = curryN(2, renderText);\n\nvar renderPage = function renderPage(ctx, node) {\n  var _node$box = node.box,\n      width = _node$box.width,\n      height = _node$box.height;\n  ctx.addPage({\n    size: [width, height],\n    margin: 0\n  });\n  return node;\n};\n\nvar renderPage$1 = curryN(2, renderPage);\n\nvar renderNote = function renderNote(ctx, node) {\n  var _node$box = node.box,\n      top = _node$box.top,\n      left = _node$box.left;\n  var value = node.children[0] ? node.children[0].value : '';\n  ctx.note(left, top, 0, 0, value);\n  return node;\n};\n\nvar renderNote$1 = curryN(2, renderNote);\n\nvar isPercent = function isPercent(value) {\n  return /((-)?\\d+\\.?\\d*)%/g.exec(value);\n};\n/**\n * Get percentage value of input\n *\n * @param {String} value\n * @returns {Object} percent value (if matches)\n */\n\n\nvar matchPercent = function matchPercent(value) {\n  var match = isPercent(value);\n\n  if (match) {\n    var _value = parseFloat(match[1], 10);\n\n    var percent = _value / 100;\n    return {\n      value: _value,\n      percent: percent,\n      absValue: Math.abs(_value),\n      absPercent: Math.abs(percent)\n    };\n  }\n\n  return null;\n};\n\nvar isNumeric = function isNumeric(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n};\n\nvar applyContainObjectFit = function applyContainObjectFit(cw, ch, iw, ih, px, py) {\n  var cr = cw / ch;\n  var ir = iw / ih;\n  var pxp = matchPercent(px);\n  var pyp = matchPercent(py);\n  var pxv = pxp ? pxp.percent : 0.5;\n  var pyv = pyp ? pyp.percent : 0.5;\n\n  if (cr > ir) {\n    var height = ch;\n    var width = height * ir;\n    var yOffset = isNumeric(py) ? py : 0;\n    var xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n    return {\n      width: width,\n      height: height,\n      xOffset: xOffset,\n      yOffset: yOffset\n    };\n  } else {\n    var _width = cw;\n\n    var _height = _width / ir;\n\n    var _xOffset = isNumeric(px) ? px : 0;\n\n    var _yOffset = isNumeric(py) ? py : (ch - _height) * pyv;\n\n    return {\n      width: _width,\n      height: _height,\n      yOffset: _yOffset,\n      xOffset: _xOffset\n    };\n  }\n};\n\nvar applyNoneObjectFit = function applyNoneObjectFit(cw, ch, iw, ih, px, py) {\n  var width = iw;\n  var height = ih;\n  var pxp = matchPercent(px);\n  var pyp = matchPercent(py);\n  var pxv = pxp ? pxp.percent : 0.5;\n  var pyv = pyp ? pyp.percent : 0.5;\n  var xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n  var yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n  return {\n    width: width,\n    height: height,\n    xOffset: xOffset,\n    yOffset: yOffset\n  };\n};\n\nvar applyCoverObjectFit = function applyCoverObjectFit(cw, ch, iw, ih, px, py) {\n  var ir = iw / ih;\n  var cr = cw / ch;\n  var pxp = matchPercent(px);\n  var pyp = matchPercent(py);\n  var pxv = pxp ? pxp.percent : 0.5;\n  var pyv = pyp ? pyp.percent : 0.5;\n\n  if (cr > ir) {\n    var width = cw;\n    var height = width / ir;\n    var xOffset = isNumeric(px) ? px : 0;\n    var yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n    return {\n      width: width,\n      height: height,\n      yOffset: yOffset,\n      xOffset: xOffset\n    };\n  } else {\n    var _height2 = ch;\n\n    var _width2 = _height2 * ir;\n\n    var _xOffset2 = isNumeric(px) ? px : (cw - _width2) * pxv;\n\n    var _yOffset2 = isNumeric(py) ? py : 0;\n\n    return {\n      width: _width2,\n      height: _height2,\n      xOffset: _xOffset2,\n      yOffset: _yOffset2\n    };\n  }\n};\n\nvar applyScaleDownObjectFit = function applyScaleDownObjectFit(cw, ch, iw, ih, px, py) {\n  var containDimension = applyContainObjectFit(cw, ch, iw, ih, px, py);\n  var noneDimension = applyNoneObjectFit(cw, ch, iw, ih, px, py);\n  return containDimension.width < noneDimension.width ? containDimension : noneDimension;\n};\n\nvar applyFillObjectFit = function applyFillObjectFit(cw, ch, px, py) {\n  return {\n    width: cw,\n    height: ch,\n    xOffset: matchPercent(px) ? 0 : px || 0,\n    yOffset: matchPercent(py) ? 0 : py || 0\n  };\n};\n\nvar resolveObjectFit = function resolveObjectFit(type, cw, ch, iw, ih, px, py) {\n  if (type === void 0) {\n    type = 'fill';\n  }\n\n  switch (type) {\n    case 'contain':\n      return applyContainObjectFit(cw, ch, iw, ih, px, py);\n\n    case 'cover':\n      return applyCoverObjectFit(cw, ch, iw, ih, px, py);\n\n    case 'none':\n      return applyNoneObjectFit(cw, ch, iw, ih, px, py);\n\n    case 'scale-down':\n      return applyScaleDownObjectFit(cw, ch, iw, ih, px, py);\n\n    default:\n      return applyFillObjectFit(cw, ch, px, py);\n  }\n};\n\nvar drawImage$1 = function drawImage(ctx) {\n  return function (node) {\n    var _node$box = node.box,\n        left = _node$box.left,\n        top = _node$box.top;\n    var _node$style = node.style,\n        opacity = _node$style.opacity,\n        objectPositionX = _node$style.objectPositionX,\n        objectPositionY = _node$style.objectPositionY;\n    var paddingTop = node.box.paddingLeft || 0;\n    var paddingRight = node.box.paddingRight || 0;\n    var paddingBottom = node.box.paddingBottom || 0;\n    var paddingLeft = node.box.paddingLeft || 0;\n\n    var _resolveObjectFit = resolveObjectFit(node.style.objectFit, node.box.width - paddingLeft - paddingRight, node.box.height - paddingTop - paddingBottom, node.image.width, node.image.height, objectPositionX, objectPositionY),\n        width = _resolveObjectFit.width,\n        height = _resolveObjectFit.height,\n        xOffset = _resolveObjectFit.xOffset,\n        yOffset = _resolveObjectFit.yOffset;\n\n    if (node.image.data) {\n      if (width !== 0 && height !== 0) {\n        ctx.fillOpacity(opacity || 1).image(node.image.data, left + paddingLeft + xOffset, top + paddingTop + yOffset, {\n          width: width,\n          height: height\n        });\n      } else {\n        warning(false, \"Image with src '\" + node.props.src + \"' skipped due to invalid dimensions\");\n      }\n    }\n\n    return node;\n  };\n};\n\nvar renderImage$1 = function renderImage(ctx, node) {\n  compose(restore$1(ctx), drawImage$1(ctx), clipNode$1(ctx), save$1(ctx))(node);\n  return node;\n};\n\nvar renderImage$2 = curryN(2, renderImage$1);\nvar availableMethods = ['dash', 'clip', 'save', 'path', 'fill', 'font', 'text', 'rect', 'scale', 'moveTo', 'lineTo', 'stroke', 'rotate', 'circle', 'lineCap', 'opacity', 'ellipse', 'polygon', 'restore', 'lineJoin', 'fontSize', 'fillColor', 'lineWidth', 'translate', 'miterLimit', 'strokeColor', 'fillOpacity', 'roundedRect', 'strokeOpacity', 'bezierCurveTo', 'quadraticCurveTo', 'linearGradient', 'radialGradient'];\n\nvar painter = function painter(ctx) {\n  var p = availableMethods.reduce(function (acc, prop) {\n    var _extends2;\n\n    return _extends({}, acc, (_extends2 = {}, _extends2[prop] = function () {\n      ctx[prop].apply(ctx, arguments);\n      return p;\n    }, _extends2));\n  }, {});\n  return p;\n};\n\nvar defaultsZero$1 = pathOr(0);\n\nvar renderCanvas = function renderCanvas(ctx, node) {\n  var _node$box = node.box,\n      top = _node$box.top,\n      left = _node$box.left,\n      width = _node$box.width,\n      height = _node$box.height;\n  var paddingLeft = defaultsZero$1('paddingLeft', node.box);\n  var paddingRight = defaultsZero$1('paddingRight', node.box);\n  var paddingTop = defaultsZero$1('paddingTop', node.box);\n  var paddingBottom = defaultsZero$1('paddingBottom', node.box);\n  var availableWidth = width - paddingLeft - paddingRight;\n  var availableHeight = height - paddingTop - paddingBottom;\n  warning(availableWidth && availableHeight, 'Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it.');\n  ctx.save().translate(left + paddingLeft, top + paddingTop);\n\n  if (node.props.paint) {\n    node.props.paint(painter(ctx), availableWidth, availableHeight);\n  }\n\n  ctx.restore();\n  return node;\n};\n\nvar renderCanvas$1 = curryN(2, renderCanvas);\n/**\n * Checks if page should render vertical ruler\n *\n * @param {Object} page\n * @returns {boolean} has vertical ruler\n */\n\nvar hasVerticalRuler = either(hasPath(['props', 'ruler']), hasPath(['props', 'verticalRuler']));\n/**\n * Checks if page should render horizontal ruler\n *\n * @param {Object} page\n * @returns {boolean} has horizontal ruler\n */\n\nvar hasHorizontalRuler = either(hasPath(['props', 'ruler']), hasPath(['props', 'horizontalRuler']));\n\nvar range = function range(max, steps) {\n  return Array.from({\n    length: Math.ceil(max / steps)\n  }, function (_, i) {\n    return i * steps;\n  });\n};\n\nvar matchPercentage = function matchPercentage(value) {\n  var match = matchPercent(value);\n  return match ? 100 / match.value : null;\n};\n\nvar getVerticalSteps = function getVerticalSteps(page) {\n  var value = page.props.horizontalRulerSteps || page.props.rulerSteps || DEFAULT_RULER_STEPS;\n\n  if (typeof value === 'string') {\n    var percentage = matchPercentage(value);\n\n    if (percentage) {\n      var width = page.box.width - (hasVerticalRuler(page) ? RULER_WIDTH : 0);\n      return width / percentage;\n    }\n\n    throw new Error('Page: Invalid horizontal steps value');\n  }\n\n  return value;\n};\n\nvar getHorizontalSteps = function getHorizontalSteps(page) {\n  var value = page.props.verticalRulerSteps || page.props.rulerSteps || DEFAULT_RULER_STEPS;\n\n  if (typeof value === 'string') {\n    var percentage = matchPercentage(value);\n\n    if (percentage) {\n      var height = page.box.height - (hasVerticalRuler(page) ? RULER_WIDTH : 0);\n      return height / percentage;\n    }\n\n    throw new Error('Page: Invalid horizontal steps value');\n  }\n\n  return value;\n};\n\nvar renderVerticalRuler = function renderVerticalRuler(ctx) {\n  return function (page) {\n    var width = page.box.width;\n    var height = page.box.height;\n    var offset = hasHorizontalRuler(page) ? RULER_WIDTH : 0;\n    var hRange = range(width, getVerticalSteps(page));\n    ctx.rect(offset, 0, width, RULER_WIDTH).fill(RULER_COLOR).moveTo(offset, RULER_WIDTH).lineTo(width, RULER_WIDTH).stroke(LINE_COLOR);\n    hRange.map(function (step) {\n      ctx.moveTo(offset + step, 0).lineTo(offset + step, RULER_WIDTH).stroke(LINE_COLOR).fillColor('black').text(\"\" + Math.round(step), offset + step + 1, 1);\n\n      if (step !== 0) {\n        ctx.moveTo(offset + step, RULER_WIDTH).lineTo(offset + step, height).stroke(GRID_COLOR);\n      }\n    });\n    return page;\n  };\n};\n\nvar renderHorizontalRuler = function renderHorizontalRuler(ctx) {\n  return function (page) {\n    var width = page.box.width;\n    var height = page.box.height;\n    var offset = hasVerticalRuler(page) ? RULER_WIDTH : 0;\n    var hRange = range(height, getHorizontalSteps(page));\n    ctx.rect(0, offset, RULER_WIDTH, height).fill(RULER_COLOR).moveTo(RULER_WIDTH, hasHorizontalRuler(page) ? RULER_WIDTH : 0).lineTo(RULER_WIDTH, height).stroke(LINE_COLOR);\n    hRange.map(function (step) {\n      ctx.moveTo(0, offset + step).lineTo(RULER_WIDTH, offset + step).stroke(LINE_COLOR).fillColor('black').text(\"\" + Math.round(step), 1, offset + step + 1);\n\n      if (step !== 0) {\n        ctx.moveTo(RULER_WIDTH, offset + step).lineTo(width, offset + step).stroke(GRID_COLOR);\n      }\n    });\n    return page;\n  };\n};\n\nvar renderRulers = function renderRulers(ctx, page) {\n  ctx.save().lineWidth(LINE_WIDTH).fontSize(RULER_FONT_SIZE).opacity(1);\n  compose(when(hasVerticalRuler, renderVerticalRuler(ctx)), when(hasHorizontalRuler, renderHorizontalRuler(ctx)))(page);\n  ctx.restore();\n  return page;\n};\n\nvar renderRulers$1 = curryN(2, renderRulers);\n\nvar getDocumentProp = function getDocumentProp(target) {\n  return function (or, prop) {\n    return pathOr(or, ['props', prop], target);\n  };\n};\n\nvar setPDFMetadata = function setPDFMetadata(target) {\n  return function (key, value) {\n    if (value) target.info[key] = value;\n  };\n};\n/**\n * Set document instance metadata\n *\n * @param {Object} ctx document instance\n * @param {Object} doc document root\n */\n\n\nvar addMetadata = function addMetadata(ctx, doc) {\n  var getProp = getDocumentProp(doc);\n  var setProp = setPDFMetadata(ctx);\n  var title = getProp(null, 'title');\n  var author = getProp(null, 'author');\n  var subject = getProp(null, 'subject');\n  var keywords = getProp(null, 'keywords');\n  var creator = getProp('react-pdf', 'creator');\n  var producer = getProp('react-pdf', 'producer');\n  setProp('Title', title);\n  setProp('Author', author);\n  setProp('Subject', subject);\n  setProp('Keywords', keywords);\n  setProp('Creator', creator);\n  setProp('Producer', producer);\n  return doc;\n};\n\nvar addMetadata$1 = curryN(2, addMetadata);\nvar CONTENT_COLOR = '#a1c6e7';\nvar PADDING_COLOR = '#c4deb9';\nvar MARGIN_COLOR = '#f8cca1';\nvar shouldDebug = pathEq(['props', 'debug'], true); // TODO: Draw debug boxes using clipping to enhance quality\n\nvar debugContent = function debugContent(ctx) {\n  return tap(function (node) {\n    var _node$box = node.box,\n        left = _node$box.left,\n        top = _node$box.top,\n        width = _node$box.width,\n        height = _node$box.height,\n        paddingLeft = _node$box.paddingLeft,\n        paddingTop = _node$box.paddingTop,\n        paddingRight = _node$box.paddingRight,\n        paddingBottom = _node$box.paddingBottom,\n        borderLeftWidth = _node$box.borderLeftWidth,\n        borderTopWidth = _node$box.borderTopWidth,\n        borderRightWidth = _node$box.borderRightWidth,\n        borderBottomWidth = _node$box.borderBottomWidth;\n    ctx.fillColor(CONTENT_COLOR).opacity(0.5).rect(left + paddingLeft + borderLeftWidth, top + paddingTop + borderTopWidth, width - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth, height - paddingTop - paddingBottom - borderTopWidth - borderBottomWidth).fill();\n  });\n};\n\nvar debugPadding = function debugPadding(ctx) {\n  return tap(function (node) {\n    var _node$box2 = node.box,\n        left = _node$box2.left,\n        top = _node$box2.top,\n        width = _node$box2.width,\n        height = _node$box2.height,\n        paddingLeft = _node$box2.paddingLeft,\n        paddingTop = _node$box2.paddingTop,\n        paddingRight = _node$box2.paddingRight,\n        paddingBottom = _node$box2.paddingBottom,\n        borderLeftWidth = _node$box2.borderLeftWidth,\n        borderTopWidth = _node$box2.borderTopWidth,\n        borderRightWidth = _node$box2.borderRightWidth,\n        borderBottomWidth = _node$box2.borderBottomWidth;\n    ctx.fillColor(PADDING_COLOR).opacity(0.5); // Padding top\n\n    ctx.rect(left + paddingLeft + borderLeftWidth, top + borderTopWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingTop).fill(); // Padding left\n\n    ctx.rect(left + borderLeftWidth, top + borderTopWidth, paddingLeft, height - borderTopWidth - borderBottomWidth).fill(); // Padding right\n\n    ctx.rect(left + width - paddingRight - borderRightWidth, top + borderTopWidth, paddingRight, height - borderTopWidth - borderBottomWidth).fill(); // Padding bottom\n\n    ctx.rect(left + paddingLeft + borderLeftWidth, top + height - paddingBottom - borderBottomWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingBottom).fill();\n  });\n};\n\nvar debugMargin = function debugMargin(ctx) {\n  return tap(function (node) {\n    var _node$box3 = node.box,\n        left = _node$box3.left,\n        top = _node$box3.top,\n        width = _node$box3.width,\n        height = _node$box3.height,\n        marginLeft = _node$box3.marginLeft,\n        marginTop = _node$box3.marginTop,\n        marginRight = _node$box3.marginRight,\n        marginBottom = _node$box3.marginBottom;\n    ctx.fillColor(MARGIN_COLOR).opacity(0.5); // Margin top\n\n    ctx.rect(left, top - marginTop, width, marginTop).fill(); // Margin left\n\n    ctx.rect(left - marginLeft, top - marginTop, marginLeft, height + marginTop + marginBottom).fill(); // Margin right\n\n    ctx.rect(left + width, top - marginTop, marginRight, height + marginTop + marginBottom).fill(); // Margin bottom\n\n    ctx.rect(left, top + height, width, marginBottom).fill();\n  });\n};\n\nvar debugText = function debugText(ctx) {\n  return tap(function (node) {\n    var _node$box4 = node.box,\n        left = _node$box4.left,\n        top = _node$box4.top,\n        width = _node$box4.width,\n        height = _node$box4.height,\n        marginLeft = _node$box4.marginLeft,\n        marginTop = _node$box4.marginTop,\n        marginRight = _node$box4.marginRight,\n        marginBottom = _node$box4.marginBottom;\n    var roundedWidth = Math.round(width + marginLeft + marginRight);\n    var roundedHeight = Math.round(height + marginTop + marginBottom);\n    ctx.fontSize(4).opacity(1).fillColor('black').text(roundedWidth + \" x \" + roundedHeight, left - marginLeft, Math.max(top - marginTop - 4, 1));\n  });\n};\n\nvar debugOrigin = function debugOrigin(ctx) {\n  return tap(function (node) {\n    if (node.origin) {\n      ctx.circle(node.origin.left, node.origin.top, 3).fill('red').circle(node.origin.left, node.origin.top, 5).stroke('red');\n    }\n  });\n};\n\nvar renderDebug = function renderDebug(ctx) {\n  return tap(when(shouldDebug, compose(restore$1(ctx), debugOrigin(ctx), debugText(ctx), debugMargin(ctx), debugPadding(ctx), debugContent(ctx), save$1(ctx))));\n}; // This constant is used to approximate a symmetrical arc using a cubic Bezier curve.\n\n\nvar KAPPA$3 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nvar clipBorderTop = function clipBorderTop(ctx, layout, style, rtr, rtl) {\n  var top = layout.top,\n      left = layout.left,\n      width = layout.width,\n      height = layout.height;\n  var borderTopWidth = style.borderTopWidth,\n      borderRightWidth = style.borderRightWidth,\n      borderLeftWidth = style.borderLeftWidth; // Clip outer top border edge\n\n  ctx.moveTo(left + rtl, top);\n  ctx.lineTo(left + width - rtr, top); // Ellipse coefficients outer top right cap\n\n  var c0 = rtr * (1.0 - KAPPA$3); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + width - c0, top, left + width, top + c0, left + width, top + rtr); // Move down in case the margin exceedes the radius\n\n  var topRightYCoord = top + Math.max(borderTopWidth, rtr);\n  ctx.lineTo(left + width, topRightYCoord); // Clip inner top right cap\n\n  ctx.lineTo(left + width - borderRightWidth, topRightYCoord); // Ellipse coefficients inner top right cap\n\n  var innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  var innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  var c1 = innerTopRightRadiusX * (1.0 - KAPPA$3);\n  var c2 = innerTopRightRadiusY * (1.0 - KAPPA$3); // Clip inner top right cap\n\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c2, left + width - borderRightWidth - c1, top + borderTopWidth, left + width - borderRightWidth - innerTopRightRadiusX, top + borderTopWidth); // Clip inner top border edge\n\n  ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth); // Ellipse coefficients inner top left cap\n\n  var innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  var innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  var c3 = innerTopLeftRadiusX * (1.0 - KAPPA$3);\n  var c4 = innerTopLeftRadiusY * (1.0 - KAPPA$3);\n  var topLeftYCoord = top + Math.max(borderTopWidth, rtl); // Clip inner top left cap\n\n  ctx.bezierCurveTo(left + borderLeftWidth + c3, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c4, left + borderLeftWidth, topLeftYCoord);\n  ctx.lineTo(left, topLeftYCoord); // Move down in case the margin exceedes the radius\n\n  ctx.lineTo(left, top + rtl); // Ellipse coefficients outer top left cap\n\n  var c5 = rtl * (1.0 - KAPPA$3); // Clip outer top left cap\n\n  ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip(); // Clip border top cap joins\n\n  if (borderRightWidth) {\n    var trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderLeftWidth) {\n    var _trSlope = -borderTopWidth / borderLeftWidth;\n\n    ctx.moveTo(left + width / 2, _trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nvar fillBorderTop = function fillBorderTop(ctx, layout, style, rtr, rtl) {\n  var top = layout.top,\n      left = layout.left,\n      width = layout.width;\n  var borderTopColor = style.borderTopColor,\n      borderTopWidth = style.borderTopWidth,\n      borderTopStyle = style.borderTopStyle,\n      borderRightWidth = style.borderRightWidth,\n      borderLeftWidth = style.borderLeftWidth;\n  var c0 = rtl * (1.0 - KAPPA$3);\n  var c1 = rtr * (1.0 - KAPPA$3);\n  ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.strokeColor(borderTopColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2);\n\n  if (borderTopStyle === 'dashed') {\n    ctx.dash(borderTopWidth * 2, {\n      space: borderTopWidth * 1.2\n    });\n  } else if (borderTopStyle === 'dotted') {\n    ctx.dash(borderTopWidth, {\n      space: borderTopWidth * 1.2\n    });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nvar clipBorderRight = function clipBorderRight(ctx, layout, style, rtr, rbr) {\n  var top = layout.top,\n      left = layout.left,\n      width = layout.width,\n      height = layout.height;\n  var borderTopWidth = style.borderTopWidth,\n      borderRightWidth = style.borderRightWidth,\n      borderBottomWidth = style.borderBottomWidth; // Clip outer right border edge\n\n  ctx.moveTo(left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr); // Ellipse coefficients outer bottom right cap\n\n  var c0 = rbr * (1.0 - KAPPA$3); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height); // Move left in case the margin exceedes the radius\n\n  var topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);\n  ctx.lineTo(topBottomXCoord, top + height); // Clip inner bottom right cap\n\n  ctx.lineTo(topBottomXCoord, top + height - borderBottomWidth); // Ellipse coefficients inner bottom right cap\n\n  var innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  var innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  var c1 = innerBottomRightRadiusX * (1.0 - KAPPA$3);\n  var c2 = innerBottomRightRadiusY * (1.0 - KAPPA$3); // Clip inner top right cap\n\n  ctx.bezierCurveTo(left + width - borderRightWidth - c1, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c2, left + width - borderRightWidth, top + height - Math.max(rbr, borderBottomWidth)); // Clip inner right border edge\n\n  ctx.lineTo(left + width - borderRightWidth, top + Math.max(rtr, borderTopWidth)); // Ellipse coefficients inner top right cap\n\n  var innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  var innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  var c3 = innerTopRightRadiusX * (1.0 - KAPPA$3);\n  var c4 = innerTopRightRadiusY * (1.0 - KAPPA$3);\n  var topRightXCoord = left + width - Math.max(rtr, borderRightWidth); // Clip inner top left cap\n\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c4, left + width - borderRightWidth - c3, top + borderTopWidth, topRightXCoord, top + borderTopWidth);\n  ctx.lineTo(topRightXCoord, top); // Move right in case the margin exceedes the radius\n\n  ctx.lineTo(left + width - rtr, top); // Ellipse coefficients outer top right cap\n\n  var c5 = rtr * (1.0 - KAPPA$3); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + width - c5, top, left + width, top + c5, left + width, top + rtr);\n  ctx.closePath();\n  ctx.clip(); // Clip border right cap joins\n\n  if (borderTopWidth) {\n    var trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderBottomWidth) {\n    var brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nvar fillBorderRight = function fillBorderRight(ctx, layout, style, rtr, rbr) {\n  var top = layout.top,\n      left = layout.left,\n      width = layout.width,\n      height = layout.height;\n  var borderRightColor = style.borderRightColor,\n      borderRightStyle = style.borderRightStyle,\n      borderRightWidth = style.borderRightWidth,\n      borderTopWidth = style.borderTopWidth,\n      borderBottomWidth = style.borderBottomWidth;\n  var c0 = rbr * (1.0 - KAPPA$3);\n  var c1 = rtr * (1.0 - KAPPA$3);\n  ctx.moveTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n  ctx.strokeColor(borderRightColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2);\n\n  if (borderRightStyle === 'dashed') {\n    ctx.dash(borderRightWidth * 2, {\n      space: borderRightWidth * 1.2\n    });\n  } else if (borderRightStyle === 'dotted') {\n    ctx.dash(borderRightWidth, {\n      space: borderRightWidth * 1.2\n    });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nvar clipBorderBottom = function clipBorderBottom(ctx, layout, style, rbl, rbr) {\n  var top = layout.top,\n      left = layout.left,\n      width = layout.width,\n      height = layout.height;\n  var borderBottomWidth = style.borderBottomWidth,\n      borderRightWidth = style.borderRightWidth,\n      borderLeftWidth = style.borderLeftWidth; // Clip outer top border edge\n\n  ctx.moveTo(left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height); // Ellipse coefficients outer top right cap\n\n  var c0 = rbl * (1.0 - KAPPA$3); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl); // Move up in case the margin exceedes the radius\n\n  var bottomLeftYCoord = top + height - Math.max(borderBottomWidth, rbl);\n  ctx.lineTo(left, bottomLeftYCoord); // Clip inner bottom left cap\n\n  ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord); // Ellipse coefficients inner top right cap\n\n  var innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  var innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  var c1 = innerBottomLeftRadiusX * (1.0 - KAPPA$3);\n  var c2 = innerBottomLeftRadiusY * (1.0 - KAPPA$3); // Clip inner bottom left cap\n\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c2, left + borderLeftWidth + c1, top + height - borderBottomWidth, left + borderLeftWidth + innerBottomLeftRadiusX, top + height - borderBottomWidth); // Clip inner bottom border edge\n\n  ctx.lineTo(left + width - Math.max(rbr, borderRightWidth), top + height - borderBottomWidth); // Ellipse coefficients inner top left cap\n\n  var innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  var innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  var c3 = innerBottomRightRadiusX * (1.0 - KAPPA$3);\n  var c4 = innerBottomRightRadiusY * (1.0 - KAPPA$3);\n  var bottomRightYCoord = top + height - Math.max(borderBottomWidth, rbr); // Clip inner top left cap\n\n  ctx.bezierCurveTo(left + width - borderRightWidth - c3, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c4, left + width - borderRightWidth, bottomRightYCoord);\n  ctx.lineTo(left + width, bottomRightYCoord); // Move down in case the margin exceedes the radius\n\n  ctx.lineTo(left + width, top + height - rbr); // Ellipse coefficients outer top left cap\n\n  var c5 = rbr * (1.0 - KAPPA$3); // Clip outer top left cap\n\n  ctx.bezierCurveTo(left + width, top + height - c5, left + width - c5, top + height, left + width - rbr, top + height);\n  ctx.closePath();\n  ctx.clip(); // Clip border bottom cap joins\n\n  if (borderRightWidth) {\n    var brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderLeftWidth) {\n    var trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nvar fillBorderBottom = function fillBorderBottom(ctx, layout, style, rbl, rbr) {\n  var top = layout.top,\n      left = layout.left,\n      width = layout.width,\n      height = layout.height;\n  var borderBottomColor = style.borderBottomColor,\n      borderBottomStyle = style.borderBottomStyle,\n      borderBottomWidth = style.borderBottomWidth,\n      borderRightWidth = style.borderRightWidth,\n      borderLeftWidth = style.borderLeftWidth;\n  var c0 = rbl * (1.0 - KAPPA$3);\n  var c1 = rbr * (1.0 - KAPPA$3);\n  ctx.moveTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c1, left + width - c1, top + height, left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.strokeColor(borderBottomColor);\n  ctx.lineWidth(Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2);\n\n  if (borderBottomStyle === 'dashed') {\n    ctx.dash(borderBottomWidth * 2, {\n      space: borderBottomWidth * 1.2\n    });\n  } else if (borderBottomStyle === 'dotted') {\n    ctx.dash(borderBottomWidth, {\n      space: borderBottomWidth * 1.2\n    });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nvar clipBorderLeft = function clipBorderLeft(ctx, layout, style, rbl, rtl) {\n  var top = layout.top,\n      left = layout.left,\n      width = layout.width,\n      height = layout.height;\n  var borderTopWidth = style.borderTopWidth,\n      borderLeftWidth = style.borderLeftWidth,\n      borderBottomWidth = style.borderBottomWidth; // Clip outer left border edge\n\n  ctx.moveTo(left, top + height - rbl);\n  ctx.lineTo(left, top + rtl); // Ellipse coefficients outer top left cap\n\n  var c0 = rtl * (1.0 - KAPPA$3); // Clip outer top left cap\n\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top); // Move right in case the margin exceedes the radius\n\n  var topLeftCoordX = left + Math.max(borderLeftWidth, rtl);\n  ctx.lineTo(topLeftCoordX, top); // Clip inner top left cap\n\n  ctx.lineTo(topLeftCoordX, top + borderTopWidth); // Ellipse coefficients inner top left cap\n\n  var innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  var innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  var c1 = innerTopLeftRadiusX * (1.0 - KAPPA$3);\n  var c2 = innerTopLeftRadiusY * (1.0 - KAPPA$3); // Clip inner top right cap\n\n  ctx.bezierCurveTo(left + borderLeftWidth + c1, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c2, left + borderLeftWidth, top + Math.max(rtl, borderTopWidth)); // Clip inner left border edge\n\n  ctx.lineTo(left + borderLeftWidth, top + height - Math.max(rbl, borderBottomWidth)); // Ellipse coefficients inner bottom left cap\n\n  var innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  var innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  var c3 = innerBottomLeftRadiusX * (1.0 - KAPPA$3);\n  var c4 = innerBottomLeftRadiusY * (1.0 - KAPPA$3);\n  var bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth); // Clip inner top left cap\n\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c4, left + borderLeftWidth + c3, top + height - borderBottomWidth, bottomLeftXCoord, top + height - borderBottomWidth);\n  ctx.lineTo(bottomLeftXCoord, top + height); // Move left in case the margin exceedes the radius\n\n  ctx.lineTo(left + rbl, top + height); // Ellipse coefficients outer top right cap\n\n  var c5 = rbl * (1.0 - KAPPA$3); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + c5, top + height, left, top + height - c5, left, top + height - rbl);\n  ctx.closePath();\n  ctx.clip(); // Clip border right cap joins\n\n  if (borderBottomWidth) {\n    var trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderBottomWidth) {\n    var _trSlope2 = -borderTopWidth / borderLeftWidth;\n\n    ctx.moveTo(left + width / 2, _trSlope2 * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nvar fillBorderLeft = function fillBorderLeft(ctx, layout, style, rbl, rtl) {\n  var top = layout.top,\n      left = layout.left,\n      height = layout.height;\n  var borderLeftColor = style.borderLeftColor,\n      borderLeftStyle = style.borderLeftStyle,\n      borderLeftWidth = style.borderLeftWidth,\n      borderTopWidth = style.borderTopWidth,\n      borderBottomWidth = style.borderBottomWidth;\n  var c0 = rbl * (1.0 - KAPPA$3);\n  var c1 = rtl * (1.0 - KAPPA$3);\n  ctx.moveTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);\n  ctx.strokeColor(borderLeftColor);\n  ctx.lineWidth(Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2);\n\n  if (borderLeftStyle === 'dashed') {\n    ctx.dash(borderLeftWidth * 2, {\n      space: borderLeftWidth * 1.2\n    });\n  } else if (borderLeftStyle === 'dotted') {\n    ctx.dash(borderLeftWidth, {\n      space: borderLeftWidth * 1.2\n    });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nvar shouldRenderBorders = function shouldRenderBorders(node) {\n  return node.box && (node.box.borderTopWidth || node.box.borderRightWidth || node.box.borderBottomWidth || node.box.borderLeftWidth);\n};\n\nvar renderBorders = function renderBorders(ctx, node) {\n  if (!shouldRenderBorders(node)) return node;\n  var _node$box = node.box,\n      width = _node$box.width,\n      height = _node$box.height,\n      borderTopWidth = _node$box.borderTopWidth,\n      borderLeftWidth = _node$box.borderLeftWidth,\n      borderRightWidth = _node$box.borderRightWidth,\n      borderBottomWidth = _node$box.borderBottomWidth;\n  var _node$style = node.style,\n      opacity = _node$style.opacity,\n      _node$style$borderTop = _node$style.borderTopLeftRadius,\n      borderTopLeftRadius = _node$style$borderTop === void 0 ? 0 : _node$style$borderTop,\n      _node$style$borderTop2 = _node$style.borderTopRightRadius,\n      borderTopRightRadius = _node$style$borderTop2 === void 0 ? 0 : _node$style$borderTop2,\n      _node$style$borderBot = _node$style.borderBottomLeftRadius,\n      borderBottomLeftRadius = _node$style$borderBot === void 0 ? 0 : _node$style$borderBot,\n      _node$style$borderBot2 = _node$style.borderBottomRightRadius,\n      borderBottomRightRadius = _node$style$borderBot2 === void 0 ? 0 : _node$style$borderBot2,\n      _node$style$borderTop3 = _node$style.borderTopColor,\n      borderTopColor = _node$style$borderTop3 === void 0 ? 'black' : _node$style$borderTop3,\n      _node$style$borderTop4 = _node$style.borderTopStyle,\n      borderTopStyle = _node$style$borderTop4 === void 0 ? 'solid' : _node$style$borderTop4,\n      _node$style$borderLef = _node$style.borderLeftColor,\n      borderLeftColor = _node$style$borderLef === void 0 ? 'black' : _node$style$borderLef,\n      _node$style$borderLef2 = _node$style.borderLeftStyle,\n      borderLeftStyle = _node$style$borderLef2 === void 0 ? 'solid' : _node$style$borderLef2,\n      _node$style$borderRig = _node$style.borderRightColor,\n      borderRightColor = _node$style$borderRig === void 0 ? 'black' : _node$style$borderRig,\n      _node$style$borderRig2 = _node$style.borderRightStyle,\n      borderRightStyle = _node$style$borderRig2 === void 0 ? 'solid' : _node$style$borderRig2,\n      _node$style$borderBot3 = _node$style.borderBottomColor,\n      borderBottomColor = _node$style$borderBot3 === void 0 ? 'black' : _node$style$borderBot3,\n      _node$style$borderBot4 = _node$style.borderBottomStyle,\n      borderBottomStyle = _node$style$borderBot4 === void 0 ? 'solid' : _node$style$borderBot4;\n  var style = {\n    borderTopColor: borderTopColor,\n    borderTopWidth: borderTopWidth,\n    borderTopStyle: borderTopStyle,\n    borderLeftColor: borderLeftColor,\n    borderLeftWidth: borderLeftWidth,\n    borderLeftStyle: borderLeftStyle,\n    borderRightColor: borderRightColor,\n    borderRightWidth: borderRightWidth,\n    borderRightStyle: borderRightStyle,\n    borderBottomColor: borderBottomColor,\n    borderBottomWidth: borderBottomWidth,\n    borderBottomStyle: borderBottomStyle,\n    borderTopLeftRadius: borderTopLeftRadius,\n    borderTopRightRadius: borderTopRightRadius,\n    borderBottomLeftRadius: borderBottomLeftRadius,\n    borderBottomRightRadius: borderBottomRightRadius\n  };\n  var rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  var rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  var rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  var rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  ctx.save();\n  ctx.strokeOpacity(opacity);\n\n  if (borderTopWidth) {\n    ctx.save();\n    clipBorderTop(ctx, node.box, style, rtr, rtl);\n    fillBorderTop(ctx, node.box, style, rtr, rtl);\n    ctx.restore();\n  }\n\n  if (borderRightWidth) {\n    ctx.save();\n    clipBorderRight(ctx, node.box, style, rtr, rbr);\n    fillBorderRight(ctx, node.box, style, rtr, rbr);\n    ctx.restore();\n  }\n\n  if (borderBottomWidth) {\n    ctx.save();\n    clipBorderBottom(ctx, node.box, style, rbl, rbr);\n    fillBorderBottom(ctx, node.box, style, rbl, rbr);\n    ctx.restore();\n  }\n\n  if (borderLeftWidth) {\n    ctx.save();\n    clipBorderLeft(ctx, node.box, style, rbl, rtl);\n    fillBorderLeft(ctx, node.box, style, rbl, rtl);\n    ctx.restore();\n  }\n\n  ctx.restore();\n  return node;\n};\n\nvar renderBorders$1 = curryN(2, renderBorders);\n\nvar setDestination = function setDestination(ctx) {\n  return tap(function (node) {\n    if (node.props.id) {\n      ctx.addNamedDestination(node.props.id, 'XYZ', null, node.box.top, null);\n    }\n  });\n};\n\nvar drawBackground = function drawBackground(ctx) {\n  return function (node) {\n    if (node.box && node.style.backgroundColor) {\n      var _node$box = node.box,\n          top = _node$box.top,\n          left = _node$box.left,\n          width = _node$box.width,\n          height = _node$box.height;\n      ctx.fillOpacity(node.style.opacity || 1).fillColor(node.style.backgroundColor).rect(left, top, width, height).fill();\n    }\n\n    return node;\n  };\n};\n\nvar shouldRenderBackground = hasPath(['style', 'backgroundColor']);\n\nvar renderBackground = function renderBackground(ctx, node) {\n  when(shouldRenderBackground, compose(restore$1(ctx), drawBackground(ctx), clipNode$1(ctx), save$1(ctx)))(node);\n  return node;\n};\n\nvar renderBackground$1 = curryN(2, renderBackground);\n\nvar shouldRenderChildren = function shouldRenderChildren(v) {\n  return !isText(v) && !isSvg(v);\n};\n\nvar renderChildren = function renderChildren(ctx) {\n  return function (node) {\n    save$1(ctx, node);\n    ctx.translate(node.box.left, node.box.top);\n    compose(forEach(renderNode$1(ctx)), pathOr([], ['children']))(node);\n    restore$1(ctx, node);\n    return node;\n  };\n};\n\nvar renderNode$1 = function renderNode(ctx) {\n  return function (node) {\n    return compose(restore$1(ctx), renderDebug(ctx), setDestination(ctx), when(shouldRenderChildren, renderChildren(ctx)), when(either(isText, isLink), setLink$1(ctx)), cond([[isText, renderText$1(ctx)], [isNote, renderNote$1(ctx)], [isImage, renderImage$2(ctx)], [isCanvas, renderCanvas$1(ctx)], [isSvg, renderSvg$1(ctx)], [T, identity]]), renderBorders$1(ctx), renderBackground$1(ctx), applyTransformations$1(ctx), save$1(ctx), when(isPage, renderPage$1(ctx)))(node);\n  };\n};\n\nvar renderDocument = function renderDocument(ctx) {\n  return compose(forEach(compose(renderRulers$1(ctx), renderNode$1(ctx))), pathOr([], ['children']));\n};\n\nvar render = function render(ctx, doc) {\n  addMetadata$1(ctx)(doc);\n  renderDocument(ctx)(doc);\n  ctx.end();\n  Font$1.reset(); // TODO: move outside\n\n  return ctx;\n};\n/**\n * Capitalize first letter of each word\n *\n * @param {String} string\n * @returns {String} capitalized string\n */\n\n\nvar capitalize = function capitalize(value) {\n  if (!value) return value;\n  return value.replace(/(^|\\s)\\S/g, function (l) {\n    return l.toUpperCase();\n  });\n};\n/**\n * Capitalize first letter of string\n *\n * @param {String} string\n * @returns {String} capitalized string\n */\n\n\nvar upperFirst = ifElse(isNil, identity, compose(join(''), juxt([compose(toUpper, head), tail])));\nvar upperFirst$1 = memoizeWith(identity, upperFirst);\n/**\n * Apply transformation to text string\n *\n * @param {String} text\n * @param {String} transformation type\n * @returns {String} transformed text\n */\n\nvar transformText = function transformText(text, transformation) {\n  switch (transformation) {\n    case 'uppercase':\n      return text.toUpperCase();\n\n    case 'lowercase':\n      return text.toLowerCase();\n\n    case 'capitalize':\n      return capitalize(text);\n\n    case 'upperfirst':\n      return upperFirst$1(text);\n\n    default:\n      return text;\n  }\n};\n\nvar StandardFont = /*#__PURE__*/function () {\n  function StandardFont(src) {\n    this.name = src;\n    this.src = PDFFont.open(null, src);\n  }\n\n  var _proto = StandardFont.prototype;\n\n  _proto.layout = function layout(str) {\n    var _this = this;\n\n    var _this$src$encode = this.src.encode(str),\n        encoded = _this$src$encode[0],\n        positions = _this$src$encode[1];\n\n    return {\n      positions: positions,\n      stringIndices: positions.map(function (_, i) {\n        return i;\n      }),\n      glyphs: encoded.map(function (g, i) {\n        var glyph = _this.getGlyph(parseInt(g, 16));\n\n        glyph.advanceWidth = positions[i].advanceWidth;\n        return glyph;\n      })\n    };\n  };\n\n  _proto.glyphForCodePoint = function glyphForCodePoint(codePoint) {\n    var glyph = this.getGlyph(codePoint);\n    glyph.advanceWidth = 400;\n    return glyph;\n  };\n\n  _proto.getGlyph = function getGlyph(id) {\n    return {\n      id: id,\n      _font: this.src,\n      codePoints: [id],\n      isLigature: false,\n      name: this.src.font.characterToGlyph(id)\n    };\n  };\n\n  _proto.hasGlyphForCodePoint = function hasGlyphForCodePoint(codePoint) {\n    return this.src.font.characterToGlyph(codePoint) !== '.notdef';\n  } // Based on empirical observation\n  ;\n\n  _createClass(StandardFont, [{\n    key: \"ascent\",\n    get: function get() {\n      return 900;\n    } // Based on empirical observation\n\n  }, {\n    key: \"descent\",\n    get: function get() {\n      switch (this.name) {\n        case 'Times-Roman':\n        case 'Times-Bold':\n        case 'Times-Italic':\n          return -220;\n\n        case 'Courier':\n        case 'Courier-Bold':\n        case 'Courier-Oblique':\n          return -230;\n\n        default:\n          return -200;\n      }\n    }\n  }, {\n    key: \"lineGap\",\n    get: function get() {\n      return 0;\n    }\n  }, {\n    key: \"unitsPerEm\",\n    get: function get() {\n      return 1000;\n    }\n  }]);\n\n  return StandardFont;\n}();\n\nvar fontCache = {};\nvar IGNORED_CODE_POINTS = [173];\nvar getFontSize = pathOr(12, ['attributes', 'fontSize']);\n\nvar getOrCreateFont = function getOrCreateFont(name) {\n  if (fontCache[name]) return fontCache[name];\n  var font = new StandardFont(name);\n  fontCache[name] = font;\n  return font;\n};\n\nvar getFallbackFont = function getFallbackFont() {\n  return getOrCreateFont('Helvetica');\n};\n\nvar shouldFallbackToFont = function shouldFallbackToFont(codePoint, font) {\n  return !IGNORED_CODE_POINTS.includes(codePoint) && !font.hasGlyphForCodePoint(codePoint) && getFallbackFont().hasGlyphForCodePoint(codePoint);\n};\n\nvar fontSubstitution = function fontSubstitution() {\n  return function (_ref) {\n    var string = _ref.string,\n        runs = _ref.runs;\n    var lastFont = null;\n    var lastIndex = 0;\n    var index = 0;\n    var res = [];\n\n    for (var _iterator = runs, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref2 = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref2 = _i.value;\n      }\n\n      var run = _ref2;\n\n      var _fontSize = getFontSize(run);\n\n      var defaultFont = typeof run.attributes.font === 'string' ? getOrCreateFont(run.attributes.font) : run.attributes.font;\n\n      if (string.length === 0) {\n        res.push({\n          start: 0,\n          end: 0,\n          attributes: {\n            font: defaultFont\n          }\n        });\n        break;\n      }\n\n      for (var _iterator2 = string.slice(run.start, run.end), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n        var _ref3;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref3 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref3 = _i2.value;\n        }\n\n        var char = _ref3;\n        var codePoint = char.codePointAt();\n        var shouldFallback = shouldFallbackToFont(codePoint, defaultFont);\n        var font = shouldFallback ? getFallbackFont() : defaultFont; // If the default font does not have a glyph and the fallback font does, we use it\n\n        if (font !== lastFont) {\n          if (lastFont) {\n            res.push({\n              start: lastIndex,\n              end: index,\n              attributes: {\n                font: lastFont,\n                scale: lastFont ? _fontSize / lastFont.unitsPerEm : 0\n              }\n            });\n          }\n\n          lastFont = font;\n          lastIndex = index;\n        }\n\n        index += char.length;\n      }\n    }\n\n    if (lastIndex < string.length) {\n      var fontSize = getFontSize(last(runs));\n      res.push({\n        start: lastIndex,\n        end: string.length,\n        attributes: {\n          font: lastFont,\n          scale: lastFont ? fontSize / lastFont.unitsPerEm : 0\n        }\n      });\n    }\n\n    return {\n      string: string,\n      runs: res\n    };\n  };\n};\n\nvar engines = {\n  linebreaker: linebreaker,\n  justification: justification,\n  textDecoration: textDecoration,\n  scriptItemizer: scriptItemizer,\n  wordHyphenation: wordHyphenation,\n  fontSubstitution: fontSubstitution\n};\nvar engine = layoutEngine(engines);\nvar layoutOptions = {\n  hyphenationCallback: Font$1.getHyphenationCallback(),\n  shrinkWhitespaceFactor: {\n    before: -0.5,\n    after: -0.5\n  }\n};\n\nvar getFragments = function getFragments(instance) {\n  if (!instance) return [{\n    string: ''\n  }];\n  var fragments = [];\n  var _instance$props = instance.props,\n      _instance$props$fill = _instance$props.fill,\n      fill = _instance$props$fill === void 0 ? 'black' : _instance$props$fill,\n      _instance$props$fontF = _instance$props.fontFamily,\n      fontFamily = _instance$props$fontF === void 0 ? 'Helvetica' : _instance$props$fontF,\n      fontWeight = _instance$props.fontWeight,\n      fontStyle = _instance$props.fontStyle,\n      _instance$props$fontS = _instance$props.fontSize,\n      fontSize = _instance$props$fontS === void 0 ? 18 : _instance$props$fontS,\n      textDecoration = _instance$props.textDecoration,\n      textDecorationColor = _instance$props.textDecorationColor,\n      textDecorationStyle = _instance$props.textDecorationStyle,\n      textTransform = _instance$props.textTransform,\n      opacity = _instance$props.opacity;\n  var obj = Font$1.getFont({\n    fontFamily: fontFamily,\n    fontWeight: fontWeight,\n    fontStyle: fontStyle\n  });\n  var font = obj ? obj.data : fontFamily;\n  var attributes = {\n    font: font,\n    opacity: opacity,\n    fontSize: fontSize,\n    color: fill,\n    underlineStyle: textDecorationStyle,\n    underline: textDecoration === 'underline',\n    underlineColor: textDecorationColor || fill,\n    strike: textDecoration === 'line-through',\n    strikeStyle: textDecorationStyle,\n    strikeColor: textDecorationColor || fill\n  };\n  instance.children.forEach(function (child) {\n    if (isTextInstance(child)) {\n      fragments.push({\n        string: transformText(child.value, textTransform),\n        attributes: attributes\n      });\n    } else {\n      if (child) {\n        fragments.push.apply(fragments, getFragments(child));\n      }\n    }\n  });\n  return fragments;\n};\n\nvar getAttributedString = function getAttributedString(instance) {\n  return AttributedString.fromFragments(getFragments(instance));\n};\n\nvar AlmostInfinity = 999999999999;\n\nvar layoutTspan = function layoutTspan(node) {\n  var attributedString = getAttributedString(node);\n  var x = pathOr(0, ['props', 'x'], node);\n  var y = pathOr(0, ['props', 'y'], node);\n  var container = {\n    x: x,\n    y: y,\n    width: AlmostInfinity,\n    height: AlmostInfinity\n  };\n  var lines = compose(reduce(concat, []), engine)(attributedString, container, layoutOptions);\n  return assoc('lines', lines, node);\n};\n\nvar layoutText = evolve({\n  children: map(layoutTspan)\n});\n/**\n * Checks if node is svg defs\n *\n * @param {Object} node\n * @returns {Boolean} is node svg defs?\n */\n\nvar isDefs = propEq('type', DEFS);\nvar getChildren = propOr([], 'children');\nvar getId = path(['props', 'id']);\nvar getDefs = compose(map(prop(0)), groupBy(getId), getChildren, defaultTo({}), find(isDefs), getChildren);\nvar isNotDefs = complement(isDefs);\nvar detachDefs = evolve({\n  children: filter(isNotDefs)\n});\nvar URL_REGEX = /url\\(['\"]?#([^'\"]+)['\"]?\\)/;\n\nvar replaceDef = function replaceDef(defs) {\n  return compose(when(test(URL_REGEX), compose(prop(__, defs), prop(1), match(URL_REGEX))), defaultTo(''));\n};\n\nvar parseNodeDefs = function parseNodeDefs(defs) {\n  return function (node) {\n    return compose(evolve({\n      props: evolve({\n        fill: replaceDef(defs),\n        clipPath: replaceDef(defs)\n      })\n    }), evolve({\n      children: map(parseNodeDefs(defs))\n    }))(node);\n  };\n};\n\nvar parseDefs = function parseDefs(root) {\n  var defs = getDefs(root);\n  return evolve({\n    children: map(parseNodeDefs(defs))\n  }, root);\n};\n\nvar replaceDefs = compose(detachDefs, parseDefs);\n\nvar parseViewbox = function parseViewbox(value) {\n  if (!value) return null;\n  var values = value.split(/[,\\s]+/).map(parseFloat);\n  if (values.length !== 4) return null;\n  return {\n    minX: values[0],\n    minY: values[1],\n    maxX: values[2],\n    maxY: values[3]\n  };\n};\n\nvar getContainer = function getContainer(node) {\n  var viewbox = parseViewbox(node.props.viewBox);\n\n  if (viewbox) {\n    return {\n      width: viewbox.maxX,\n      height: viewbox.maxY\n    };\n  }\n\n  if (node.props.width && node.props.height) {\n    return {\n      width: parseFloat(node.props.width),\n      height: parseFloat(node.props.height)\n    };\n  }\n\n  return {\n    width: 0,\n    height: 0\n  };\n};\n\nvar getInheritProps = compose(pick(SVG_INHERITED_PROPS), propOr({}, 'props'));\n\nvar inheritProps = function inheritProps(node) {\n  var props = getInheritProps(node);\n  return evolve({\n    children: map(compose(inheritProps, evolve({\n      props: merge(props)\n    })))\n  })(node);\n};\n\nvar parseAspectRatio = function parseAspectRatio(value) {\n  var match = value.replace(/[\\s\\r\\t\\n]+/gm, ' ').replace(/^defer\\s/, '').split(' ');\n  var align = match[0] || 'xMidYMid';\n  var meetOrSlice = match[1] || 'meet';\n  return {\n    align: align,\n    meetOrSlice: meetOrSlice\n  };\n};\n\nvar isRgb = test(/rgb/g);\nvar isRgba = test(/rgba/g);\nvar isHsl = test(/hsl/g);\nvar isHsla = test(/hsla/g);\n/**\n * Transform rgb color to hexa\n *\n * @param {String} styles value\n * @returns {Object} transformed value\n */\n\nvar parseRgb = compose(colorString.to.hex, colorString.get.rgb);\n/**\n * Transform Hsl color to hexa\n *\n * @param {String} styles value\n * @returns {Object} transformed value\n */\n\nvar parseHsl = compose(toUpper, apply(hlsToHex), map(Math.round), colorString.get.hsl);\n/**\n * Transform given color to hexa\n *\n * @param {String} styles value\n * @returns {Object} transformed value\n */\n\nvar transformColor = function transformColor(value) {\n  return cond([[isRgba, parseRgb], [isRgb, parseRgb], [isHsla, parseHsl], [isHsl, parseHsl], [T, always(value)]])(value);\n};\n/**\n * Transform rbg and cmyk colors to hexa\n *\n * @param {Object} styles object\n * @returns {Object} transformed styles\n */\n\n\nvar transformColors = function transformColors(styles) {\n  return map(transformColor, styles);\n};\n\nvar STYLE_PROPS = ['width', 'height', 'color', 'stroke', 'strokeWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'fill', 'fillRule', 'clipPath', 'offset', 'transform', 'strokeLinejoin', 'strokeLinecap', 'strokeDasharray'];\nvar VERTICAL_PROPS = ['y', 'y1', 'y2', 'height', 'cy', 'ry'];\nvar HORIZONTAL_PROPS = ['x', 'x1', 'x2', 'width', 'cx', 'rx'];\n\nvar transformPercent = function transformPercent(container) {\n  return mapObjIndexed(function (value, key) {\n    var match = matchPercent(value);\n\n    if (match && VERTICAL_PROPS.includes(key)) {\n      return match.percent * container.height;\n    }\n\n    if (match && HORIZONTAL_PROPS.includes(key)) {\n      return match.percent * container.width;\n    }\n\n    return value;\n  });\n};\n\nvar parsePercent = function parsePercent(value) {\n  var match = matchPercent(value);\n  return match ? match.percent : parseFloat(value);\n};\n\nvar parseProps = function parseProps(container) {\n  return compose(evolve({\n    props: o(evolve({\n      x: parseFloat,\n      x1: parseFloat,\n      x2: parseFloat,\n      y: parseFloat,\n      y1: parseFloat,\n      y2: parseFloat,\n      r: parseFloat,\n      rx: parseFloat,\n      ry: parseFloat,\n      cx: parseFloat,\n      cy: parseFloat,\n      width: parseFloat,\n      height: parseFloat,\n      offset: parsePercent,\n      fill: transformColor,\n      opacity: parsePercent,\n      stroke: transformColor,\n      stopOpacity: parsePercent,\n      stopColor: transformColor\n    }), transformPercent(container))\n  }));\n};\n\nvar mergeStyles = function mergeStyles(node) {\n  var style = propOr({}, 'style', node);\n  return evolve({\n    props: merge(style)\n  }, node);\n};\n\nvar removeNoneValues = evolve({\n  props: map(when(equals('none'), always(null)))\n});\n\nvar pickStyleProps = function pickStyleProps(node) {\n  var styleProps = o(pick(STYLE_PROPS), propOr({}, 'props'))(node);\n  return evolve({\n    style: merge(styleProps)\n  }, node);\n};\n\nvar parseSvgProps = evolve({\n  props: evolve({\n    width: parseFloat,\n    height: parseFloat,\n    viewBox: parseViewbox,\n    preserveAspectRatio: parseAspectRatio\n  })\n});\n\nvar wrapBetweenTspan = function wrapBetweenTspan(node) {\n  return {\n    type: 'TSPAN',\n    props: {},\n    children: [node]\n  };\n};\n\nvar addMissingTspan = when(isText, evolve({\n  children: map(when(isTextInstance, wrapBetweenTspan))\n}));\n\nvar resolveSvgNode = function resolveSvgNode(container) {\n  return compose(parseProps(container), addMissingTspan, removeNoneValues, mergeStyles);\n};\n\nvar resolveChildren = function resolveChildren(container) {\n  return function (node) {\n    return evolve({\n      children: map(compose(resolveChildren(container), resolveSvgNode(container)))\n    })(node);\n  };\n};\n\nvar parseText = function parseText(node) {\n  return ifElse(isText, layoutText, evolve({\n    children: map(parseText)\n  }))(node);\n};\n\nvar resolveSvgRoot = function resolveSvgRoot(node) {\n  var container = getContainer(node);\n  return compose(replaceDefs, parseText, parseSvgProps, pickStyleProps, inheritProps, resolveChildren(container))(node);\n};\n\nvar resolveSvg = function resolveSvg(node) {\n  return compose(evolve({\n    children: map(resolveSvg)\n  }), when(isSvg, resolveSvgRoot))(node);\n};\n\nvar getZIndex = path(['style', 'zIndex']);\nvar isType = propEq('type');\nvar shouldNotSort = anyPass([isType(DOCUMENT), isType(SVG)]);\n\nvar sortZIndex = function sortZIndex(a, b) {\n  var za = getZIndex(a);\n  var zb = getZIndex(b);\n  if (!za && !zb) return 0;\n  if (!za) return 1;\n  if (!zb) return -1;\n  return zb - za;\n};\n/**\n * Sort children by zIndex value\n *\n * @param {Object} node\n * @returns {Object} node\n */\n\n\nvar resolveZIndex = function resolveZIndex(node) {\n  return compose(evolve({\n    children: map(resolveZIndex)\n  }), unless(shouldNotSort, evolve({\n    children: sort(sortZIndex)\n  })))(node);\n};\n/**\n * Adjust page size given ruler props\n *\n * @param {Object} page\n * @returns {boolean} page with size altered by ruler props\n */\n\n\nvar adjustPageSize = compose(when(hasVerticalRuler, evolve({\n  box: {\n    height: add(RULER_WIDTH)\n  },\n  children: map(evolve({\n    box: {\n      top: add(RULER_WIDTH)\n    }\n  }))\n})), when(hasHorizontalRuler, evolve({\n  box: {\n    width: add(RULER_WIDTH)\n  },\n  children: map(evolve({\n    box: {\n      left: add(RULER_WIDTH)\n    }\n  }))\n})));\n/**\n * Adjust pages size given ruler props\n *\n * @param {Object} root\n * @returns {boolean} root with pages size altered by ruler props\n */\n\nvar resolveRulers = evolve({\n  children: map(adjustPageSize)\n});\nvar fs = {};\n\nPNG.isValid = function (data) {\n  try {\n    return !!new PNG(data);\n  } catch (e) {\n    return false;\n  }\n}; // Extracted from https://github.com/devongovett/pdfkit/blob/master/lib/image/jpeg.coffee\n\n\nvar MARKERS = [0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc8, 0xffc9, 0xffca, 0xffcb, 0xffcc, 0xffcd, 0xffce, 0xffcf];\n\nvar JPEG = function JPEG(data) {\n  this.data = null;\n  this.width = null;\n  this.height = null;\n  this.data = data;\n\n  if (data.readUInt16BE(0) !== 0xffd8) {\n    throw new Error('SOI not found in JPEG');\n  }\n\n  var marker;\n  var pos = 2;\n\n  while (pos < data.length) {\n    marker = data.readUInt16BE(pos);\n    pos += 2;\n\n    if (MARKERS.includes(marker)) {\n      break;\n    }\n\n    pos += data.readUInt16BE(pos);\n  }\n\n  if (!MARKERS.includes(marker)) {\n    throw new Error('Invalid JPEG.');\n  }\n\n  pos += 3;\n  this.height = data.readUInt16BE(pos);\n  pos += 2;\n  this.width = data.readUInt16BE(pos);\n};\n\nJPEG.isValid = function (data) {\n  if (!data || !Buffer.isBuffer(data) || data.readUInt16BE(0) !== 0xffd8) {\n    return false;\n  }\n\n  var marker;\n  var pos = 2;\n\n  while (pos < data.length) {\n    marker = data.readUInt16BE(pos);\n    pos += 2;\n\n    if (MARKERS.includes(marker)) {\n      break;\n    }\n\n    pos += data.readUInt16BE(pos);\n  }\n\n  if (!MARKERS.includes(marker)) {\n    return false;\n  }\n\n  return true;\n};\n\nvar createCache = function createCache(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      _ref$limit = _ref.limit,\n      limit = _ref$limit === void 0 ? 100 : _ref$limit;\n\n  var cache = {};\n  var keys = [];\n  return {\n    get: function get(key) {\n      return cache[key];\n    },\n    set: function set(key, value) {\n      keys.push(key);\n\n      if (keys.length > limit) {\n        delete cache[keys.shift()];\n      }\n\n      cache[key] = value;\n    },\n    reset: function reset() {\n      cache = {};\n      keys = [];\n    },\n    length: function length() {\n      return keys.length;\n    }\n  };\n};\n\nvar IMAGE_CACHE = createCache({\n  limit: 30\n});\n\nvar getAbsoluteLocalPath = function getAbsoluteLocalPath(src) {\n  {\n    throw new Error('Cannot check local paths in client-side environment');\n  }\n\n  var _url$parse = fs.parse(src),\n      protocol = _url$parse.protocol,\n      auth = _url$parse.auth,\n      host = _url$parse.host,\n      port = _url$parse.port,\n      hostname = _url$parse.hostname,\n      pathname = _url$parse.path;\n\n  var absolutePath = fs.resolve(pathname);\n\n  if (protocol && protocol !== 'file:' || auth || host || port || hostname) {\n    return undefined;\n  }\n\n  return absolutePath;\n};\n\nvar fetchLocalFile = function fetchLocalFile(src) {\n  return new Promise(function (resolve, reject) {\n    try {\n      {\n        return reject(new Error('Cannot fetch local file in this environemnt'));\n      }\n      var absolutePath = getAbsoluteLocalPath(src);\n\n      if (!absolutePath) {\n        return reject(new Error(\"Cannot fetch non-local path: \" + src));\n      }\n\n      fs.readFile(absolutePath, function (err, data) {\n        return err ? reject(err) : resolve(data);\n      });\n    } catch (err) {\n      reject(err);\n    }\n  });\n};\n\nvar fetchRemoteFile = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(uri, options) {\n    var response, buffer;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return fetch(uri, options);\n\n          case 2:\n            response = _context.sent;\n            _context.next = 5;\n            return response.buffer ? response.buffer() : response.arrayBuffer();\n\n          case 5:\n            buffer = _context.sent;\n            return _context.abrupt(\"return\", buffer.constructor.name === 'Buffer' ? buffer : Buffer.from(buffer));\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function fetchRemoteFile(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar isValidFormat = function isValidFormat(format) {\n  var lower = format.toLowerCase();\n  return lower === 'jpg' || lower === 'jpeg' || lower === 'png';\n};\n\nvar guessFormat = function guessFormat(buffer) {\n  var format;\n\n  if (JPEG.isValid(buffer)) {\n    format = 'jpg';\n  } else if (PNG.isValid(buffer)) {\n    format = 'png';\n  }\n\n  return format;\n};\n\nvar isCompatibleBase64 = function isCompatibleBase64(_ref2) {\n  var uri = _ref2.uri;\n  return /^data:image\\/[a-zA-Z]*;base64,[^\"]*/g.test(uri);\n};\n\nfunction getImage(body, extension) {\n  switch (extension.toLowerCase()) {\n    case 'jpg':\n    case 'jpeg':\n      return new JPEG(body);\n\n    case 'png':\n      return new PNG(body);\n\n    default:\n      return null;\n  }\n}\n\nvar resolveBase64Image = function resolveBase64Image(_ref3) {\n  var uri = _ref3.uri;\n  var match = /^data:image\\/([a-zA-Z]*);base64,([^\"]*)/g.exec(uri);\n  var format = match[1];\n  var data = match[2];\n\n  if (!isValidFormat(format)) {\n    throw new Error(\"Base64 image invalid format: \" + format);\n  }\n\n  return new Promise(function (resolve) {\n    return resolve(getImage(Buffer.from(data, 'base64'), format));\n  });\n};\n\nvar resolveImageFromData = function resolveImageFromData(src) {\n  if (src.data && src.format) {\n    return new Promise(function (resolve) {\n      return resolve(getImage(src.data, src.format));\n    });\n  }\n\n  throw new Error(\"Invalid data given for local file: \" + JSON.stringify(src));\n};\n\nvar resolveBufferImage = function resolveBufferImage(buffer) {\n  var format = guessFormat(buffer);\n\n  if (format) {\n    return new Promise(function (resolve) {\n      return resolve(getImage(buffer, format));\n    });\n  }\n};\n\nvar getImageFormat = function getImageFormat(body) {\n  var isPng = body[0] === 137 && body[1] === 80 && body[2] === 78 && body[3] === 71 && body[4] === 13 && body[5] === 10 && body[6] === 26 && body[7] === 10;\n  var isJpg = body[0] === 255 && body[1] === 216 && body[2] === 255;\n  var extension = '';\n\n  if (isPng) {\n    extension = 'png';\n  } else if (isJpg) {\n    extension = 'jpg';\n  } else {\n    throw new Error('Not valid image extension');\n  }\n\n  return extension;\n};\n\nvar resolveImageFromUrl = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(src) {\n    var uri, body, headers, _src$method, method, data, extension;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            uri = src.uri, body = src.body, headers = src.headers, _src$method = src.method, method = _src$method === void 0 ? 'GET' : _src$method;\n            {\n              _context2.next = 7;\n              break;\n            }\n            _context2.next = 4;\n            return fetchLocalFile(uri);\n\n          case 4:\n            _context2.t0 = _context2.sent;\n            _context2.next = 10;\n            break;\n\n          case 7:\n            _context2.next = 9;\n            return fetchRemoteFile(uri, {\n              body: body,\n              headers: headers,\n              method: method\n            });\n\n          case 9:\n            _context2.t0 = _context2.sent;\n\n          case 10:\n            data = _context2.t0;\n            extension = getImageFormat(data);\n            return _context2.abrupt(\"return\", getImage(data, extension));\n\n          case 13:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function resolveImageFromUrl(_x3) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nvar resolveImage = function resolveImage(src, _temp) {\n  var _ref5 = _temp === void 0 ? {} : _temp,\n      _ref5$cache = _ref5.cache,\n      cache = _ref5$cache === void 0 ? true : _ref5$cache;\n\n  var cacheKey = src.data ? src.data.toString() : src.uri;\n\n  if (cache && IMAGE_CACHE.get(cacheKey)) {\n    return IMAGE_CACHE.get(cacheKey);\n  }\n\n  var image;\n\n  if (isCompatibleBase64(src)) {\n    image = resolveBase64Image(src);\n  } else if (Buffer.isBuffer(src)) {\n    image = resolveBufferImage(src);\n  } else if (typeof src === 'object' && src.data) {\n    image = resolveImageFromData(src);\n  } else {\n    image = resolveImageFromUrl(src);\n  }\n\n  if (!image) {\n    throw new Error('Cannot resolve image');\n  }\n\n  if (cache) {\n    IMAGE_CACHE.set(cacheKey, image);\n  }\n\n  return image;\n};\n\nvar isNotNil = complement(isNil);\n/**\n * Takes a list of predicates and returns the first predicate result that returns true for a given list of arguments\n *\n * @param  {...any} predicates\n * @param  {any} value\n */\n\nvar firstPass = function firstPass() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return function (value) {\n    var res;\n\n    for (var _i = 0; _i < fns.length; _i++) {\n      var fn = fns[_i];\n      res = fn(value);\n      if (isNotNil(res)) return res;\n    }\n\n    return res;\n  };\n};\n/**\n * Get image source\n *\n * @param {Object} image node\n * @returns {String} image src\n */\n\n\nvar getSource$1 = compose(when(is(String), function (src) {\n  return {\n    uri: src\n  };\n}), firstPass(path(['props', 'src']), path(['props', 'source']), path(['props', 'href'])));\n/**\n * Resolves async src if passed\n *\n * @param {string | Function} src\n * @returns {object} resolved src\n */\n\nvar resolveSrc = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(src) {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!(typeof src === 'function')) {\n              _context.next = 7;\n              break;\n            }\n\n            _context.next = 3;\n            return src();\n\n          case 3:\n            _context.t1 = _context.sent;\n            _context.t0 = {\n              uri: _context.t1\n            };\n            _context.next = 8;\n            break;\n\n          case 7:\n            _context.t0 = src;\n\n          case 8:\n            return _context.abrupt(\"return\", _context.t0);\n\n          case 9:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function resolveSrc(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Fetches image and append data to node\n * Ideally this fn should be immutable.\n *\n * @param {Object} node\n */\n\n\nvar fetchImage = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(node) {\n    var src, cache, source;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            src = getSource$1(node);\n            cache = node.props.cache;\n\n            if (src) {\n              _context2.next = 5;\n              break;\n            }\n\n            warning(false, 'Image should receive either a \"src\" or \"source\" prop');\n            return _context2.abrupt(\"return\");\n\n          case 5:\n            _context2.prev = 5;\n            _context2.next = 8;\n            return resolveSrc(src);\n\n          case 8:\n            source = _context2.sent;\n            _context2.next = 11;\n            return resolveImage(source, {\n              cache: cache\n            });\n\n          case 11:\n            node.image = _context2.sent;\n            _context2.next = 18;\n            break;\n\n          case 14:\n            _context2.prev = 14;\n            _context2.t0 = _context2[\"catch\"](5);\n            node.image = {\n              width: 0,\n              height: 0\n            };\n            console.warn(_context2.t0.message);\n\n          case 18:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[5, 14]]);\n  }));\n\n  return function fetchImage(_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar emojis = {};\nvar regex = emojiRegex();\n\nvar reflect = function reflect(promise) {\n  return function () {\n    return promise.apply(void 0, arguments).then(function (v) {\n      return v;\n    }, function (e) {\n      return e;\n    });\n  };\n}; // Returns a function to be able to mock resolveImage.\n\n\nvar makeFetchEmojiImage = function makeFetchEmojiImage() {\n  return reflect(resolveImage);\n};\n/**\n * When an emoji as no color, it might still have 2 parts,\n * the canonical emoji and an empty string.\n * ex.\n *   (no color) Array.from('❤️') => [\"❤\", \"️\"]\n *   (w/ color) Array.from('👍🏿') => [\"👍\", \"🏿\"]\n *\n * The empty string needs to be removed otherwise the generated\n * url will be incorect.\n */\n\n\nvar _removeNoColor = function _removeNoColor(x) {\n  return x !== '️';\n};\n\nvar getCodePoints = function getCodePoints(string) {\n  return Array.from(string).filter(_removeNoColor).map(function (char) {\n    return char.codePointAt(0).toString(16);\n  }).join('-');\n};\n\nvar buildEmojiUrl = function buildEmojiUrl(emoji) {\n  var _Font$getEmojiSource = Font$1.getEmojiSource(),\n      url = _Font$getEmojiSource.url,\n      format = _Font$getEmojiSource.format;\n\n  return \"\" + url + getCodePoints(emoji) + \".\" + format;\n};\n\nvar fetchEmojis = function fetchEmojis(string) {\n  var emojiSource = Font$1.getEmojiSource();\n  if (!emojiSource || !emojiSource.url) return [];\n  var promises = [];\n  var match;\n\n  var _loop = function _loop() {\n    var emoji = match[0];\n\n    if (!emojis[emoji] || emojis[emoji].loading) {\n      var emojiUrl = buildEmojiUrl(emoji);\n      emojis[emoji] = {\n        loading: true\n      };\n      var fetchEmojiImage = makeFetchEmojiImage();\n      promises.push(fetchEmojiImage({\n        uri: emojiUrl\n      }).then(function (image) {\n        emojis[emoji].loading = false;\n        emojis[emoji].data = image.data;\n      }));\n    }\n  };\n\n  while (match = regex.exec(string)) {\n    _loop();\n  }\n\n  return promises;\n};\n\nvar embedEmojis = function embedEmojis(fragments) {\n  var result = [];\n\n  for (var i = 0; i < fragments.length; i++) {\n    var fragment = fragments[i];\n    var match = void 0;\n    var lastIndex = 0;\n\n    while (match = regex.exec(fragment.string)) {\n      var index = match.index;\n      var emoji = match[0];\n      var emojiSize = fragment.attributes.fontSize;\n      var chunk = fragment.string.slice(lastIndex, index + match[0].length); // If emoji image was found, we create a new fragment with the\n      // correct attachment and object substitution character;\n\n      if (emojis[emoji] && emojis[emoji].data) {\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0xfffc)),\n          attributes: _extends({}, fragment.attributes, {\n            attachment: {\n              width: emojiSize,\n              height: emojiSize,\n              yOffset: Math.floor(emojiSize * 0.1),\n              image: emojis[emoji].data\n            }\n          })\n        });\n      } else {\n        // If no emoji data, we just replace the emoji with a nodef char\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0)),\n          attributes: fragment.attributes\n        });\n      }\n\n      lastIndex = index + emoji.length;\n    }\n\n    if (lastIndex < fragment.string.length) {\n      result.push({\n        string: fragment.string.slice(lastIndex),\n        attributes: fragment.attributes\n      });\n    }\n  }\n\n  return result;\n};\n/**\n * Get all asset promises that need to be resolved\n *\n * @param {Object} root node\n * @returns {Array} asset promises\n */\n\n\nvar fetchAssets = function fetchAssets(node) {\n  var promises = [];\n  var listToExplore = node.children.slice(0);\n\n  while (listToExplore.length > 0) {\n    var _node = listToExplore.shift();\n\n    if (isImage(_node)) {\n      promises.push(fetchImage(_node));\n    }\n\n    if (_node.style && _node.style.fontFamily) {\n      promises.push(Font$1.load(_node.style));\n    }\n\n    if (typeof _node === 'string') {\n      promises.push.apply(promises, fetchEmojis(_node));\n    }\n\n    if (typeof _node.value === 'string') {\n      promises.push.apply(promises, fetchEmojis(_node.value));\n    }\n\n    if (_node.children) {\n      _node.children.forEach(function (childNode) {\n        listToExplore.push(childNode);\n      });\n    }\n  }\n\n  return promises;\n};\n/**\n * Fetch image, font and emoji assets in parallel.\n * Layout process will not be resumed until promise resolves.\n *\n * @param {Object} root node\n * @returns {Object} root node\n */\n\n\nvar resolveAssets = function resolveAssets(node) {\n  return compose(then(always(node)), function (p) {\n    return Promise.all(p);\n  }, fetchAssets)(node);\n};\n/**\n * Checks if value is not an array\n *\n * @param {any} value\n * @returns {Boolean} isn't value an array\n */\n\n\nvar isNotArray = complement(is(Array));\n/**\n * Casts value to array\n *\n * @param {any} value\n * @returns {Array} casted value\n */\n\nvar castArray = when(isNotArray, function (v) {\n  return [v];\n});\n/**\n * Remove nil values from array\n *\n * @param {Array} array\n * @returns {Array} array without nils\n */\n\nvar compact = filter(Boolean);\n/**\n * Checks if value is array\n *\n * @param {any} value\n * @returns {Boolean} is value an array\n */\n\nvar isArray = is(Array);\n/**\n * Merges style objects array\n *\n * @param {Array} style objects array\n * @returns {Object} merged style object\n */\n\nvar mergeStyles$1 = function mergeStyles(styles) {\n  return styles.reduce(function (acc, style) {\n    var s = isArray(style) ? flatten(style) : style;\n    Object.keys(s).forEach(function (key) {\n      if (s[key] !== null && s[key] !== undefined) {\n        acc[key] = s[key];\n      }\n    });\n    return acc;\n  }, {});\n};\n/**\n * Flattens an array of style objects, into one aggregated style object.\n *\n * @param {Array} style objects array\n * @returns {Object} flatted style object\n */\n\n\nvar flatten = compose(mergeStyles$1, compact, castArray);\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * Expand rules\n */\n\nvar styleShorthands = {\n  margin: {\n    marginTop: true,\n    marginRight: true,\n    marginBottom: true,\n    marginLeft: true\n  },\n  marginHorizontal: {\n    marginLeft: true,\n    marginRight: true\n  },\n  marginVertical: {\n    marginTop: true,\n    marginBottom: true\n  },\n  padding: {\n    paddingTop: true,\n    paddingRight: true,\n    paddingBottom: true,\n    paddingLeft: true\n  },\n  paddingHorizontal: {\n    paddingLeft: true,\n    paddingRight: true\n  },\n  paddingVertical: {\n    paddingTop: true,\n    paddingBottom: true\n  },\n  border: {\n    borderTopColor: true,\n    borderTopStyle: true,\n    borderTopWidth: true,\n    borderRightColor: true,\n    borderRightStyle: true,\n    borderRightWidth: true,\n    borderBottomColor: true,\n    borderBottomStyle: true,\n    borderBottomWidth: true,\n    borderLeftColor: true,\n    borderLeftStyle: true,\n    borderLeftWidth: true\n  },\n  borderTop: {\n    borderTopColor: true,\n    borderTopStyle: true,\n    borderTopWidth: true\n  },\n  borderRight: {\n    borderRightColor: true,\n    borderRightStyle: true,\n    borderRightWidth: true\n  },\n  borderBottom: {\n    borderBottomColor: true,\n    borderBottomStyle: true,\n    borderBottomWidth: true\n  },\n  borderLeft: {\n    borderLeftColor: true,\n    borderLeftStyle: true,\n    borderLeftWidth: true\n  },\n  borderColor: {\n    borderTopColor: true,\n    borderRightColor: true,\n    borderBottomColor: true,\n    borderLeftColor: true\n  },\n  borderRadius: {\n    borderTopLeftRadius: true,\n    borderTopRightRadius: true,\n    borderBottomRightRadius: true,\n    borderBottomLeftRadius: true\n  },\n  borderStyle: {\n    borderTopStyle: true,\n    borderRightStyle: true,\n    borderBottomStyle: true,\n    borderLeftStyle: true\n  },\n  borderWidth: {\n    borderTopWidth: true,\n    borderRightWidth: true,\n    borderBottomWidth: true,\n    borderLeftWidth: true\n  },\n  objectPosition: {\n    objectPositionX: true,\n    objectPositionY: true\n  },\n  transformOrigin: {\n    transformOriginX: true,\n    transformOriginY: true\n  },\n  flex: {\n    flexGrow: true,\n    flexShrink: true,\n    flexBasis: true\n  }\n};\n/**\n * Expand the shorthand properties to isolate every declaration from the others.\n *\n * @param { Object } style object\n * @returns { Object } expanded style object\n */\n\nvar expandStyles = function expandStyles(style) {\n  if (!style) return style;\n  var propsArray = Object.keys(style);\n  var resolvedStyle = {};\n\n  for (var i = 0; i < propsArray.length; i++) {\n    var key = propsArray[i];\n    var value = style[key];\n\n    if (styleShorthands[key]) {\n      var expandedProps = styleShorthands[key];\n\n      for (var propName in expandedProps) {\n        if (hasOwnProperty.call(expandedProps, propName)) {\n          resolvedStyle[propName] = value;\n        }\n      }\n    } else {\n      resolvedStyle[key] = value;\n    }\n  }\n\n  return resolvedStyle;\n};\n\nvar MM_FACTOR = 1 / 25.4 * DPI;\nvar CM_FACTOR = 1 / 2.54 * DPI;\n/**\n * Parses scalar value in value and unit pairs\n *\n * @param {String} scalar value\n * @returns {Object} parsed value\n */\n\nvar parseValue = function parseValue(value) {\n  var match = /^(-?\\d*\\.?\\d+)(in|mm|cm|pt|vh|vw|px)?$/g.exec(value);\n  return match ? {\n    value: parseFloat(match[1], 10),\n    unit: match[2] || 'pt'\n  } : {\n    value: value,\n    unit: undefined\n  };\n};\n/**\n * Transform given scalar value\n *\n * @param {Object} container\n * @param {String} styles value\n * @returns {Object} transformed value\n */\n\n\nvar transformUnit = curryN(2, function (container, value) {\n  var scalar = parseValue(value);\n\n  switch (scalar.unit) {\n    case 'in':\n      return scalar.value * DPI;\n\n    case 'mm':\n      return scalar.value * MM_FACTOR;\n\n    case 'cm':\n      return scalar.value * CM_FACTOR;\n\n    case 'vh':\n      return scalar.value * (container.height / 100);\n\n    case 'vw':\n      return scalar.value * (container.width / 100);\n\n    default:\n      return scalar.value;\n  }\n});\n/**\n * Transform units on given styles object.\n * Container is given to calculate vh and vw\n *\n * @param {Object} container\n * @param {Object} styles object\n * @returns {Object} transformed styles\n */\n\nvar transformUnits = function transformUnits(container, styles) {\n  return map(transformUnit(container), styles);\n};\n\nvar transformUnits$1 = curryN(2, transformUnits);\n/**\n * Resolves media queries in styles object\n *\n * @param {Object} container\n * @param {Object} styles object\n */\n\nvar resolveMediaQueries = function resolveMediaQueries(container, styles) {\n  return Object.keys(styles).reduce(function (acc, key) {\n    var _extends2;\n\n    if (/@media/.test(key)) {\n      var _matchMedia;\n\n      return _extends({}, acc, matchMedia((_matchMedia = {}, _matchMedia[key] = styles[key], _matchMedia), container));\n    }\n\n    return _extends({}, acc, (_extends2 = {}, _extends2[key] = styles[key], _extends2));\n  }, {});\n};\n\nvar resolveMediaQueries$1 = curryN(2, resolveMediaQueries);\nvar LINK_STYLES = {\n  color: 'blue',\n  textDecoration: 'underline'\n};\n/**\n * Filter styles with `none` value\n *\n * @param {Object} style object\n * @returns {Object} style without none values\n */\n\nvar filterNoneValues = reject(equals('none'));\n/**\n * Resolves styles\n *\n * @param {Object} container\n * @param {Object} node\n * @param {Object} style object\n * @returns {Object} resolved style object\n */\n\nvar resolveStyles = function resolveStyles(container) {\n  return compose(transformUnits$1(container), transformColors, transformStyles, expandStyles, resolveMediaQueries$1(container), filterNoneValues, flatten);\n};\n/**\n * Resolves node styles\n *\n * @param {Object} container\n * @param {Object} document node\n * @returns {Object} node (and subnodes) with resolved styles\n */\n\n\nvar resolveNodeStyles = function resolveNodeStyles(container) {\n  return function (node) {\n    return o(when(isLink, evolve({\n      style: merge(LINK_STYLES)\n    })), evolve({\n      style: resolveStyles(container),\n      children: map(resolveNodeStyles(container))\n    }))(node);\n  };\n};\n/**\n * Resolves page styles\n *\n * @param {Object} document page\n * @returns {Object} document page with resolved styles\n */\n\n\nvar resolvePageStyles = function resolvePageStyles(page) {\n  var box = prop('box', page);\n  var style = prop('style', page);\n  var container = isEmpty(box) ? style : box;\n  return evolve({\n    style: resolveStyles(container),\n    children: map(resolveNodeStyles(container))\n  })(page);\n};\n/**\n * Resolves root styles\n *\n * @param {Object} document root\n * @returns {Object} document root with resolved styles\n */\n\n\nvar resolveStyles$1 = evolve({\n  children: map(resolvePageStyles)\n});\n\nvar getTransformStyle = function getTransformStyle(s) {\n  return pathOr('50%', ['style', s]);\n};\n/**\n * Get node origin\n *\n * @param {Object} node\n * @returns {Object} node origin\n */\n\n\nvar getOrigin = function getOrigin(node) {\n  if (!node.box) return {};\n  var _node$box = node.box,\n      left = _node$box.left,\n      top = _node$box.top,\n      width = _node$box.width,\n      height = _node$box.height;\n  var transformOriginX = getTransformStyle('transformOriginX')(node);\n  var transformOriginY = getTransformStyle('transformOriginY')(node);\n  var percentX = matchPercent(transformOriginX);\n  var percentY = matchPercent(transformOriginY);\n  var offsetX = percentX ? width * percentX.percent : transformOriginX;\n  var offsetY = percentY ? height * percentY.percent : transformOriginY;\n  return {\n    left: left + offsetX,\n    top: top + offsetY\n  };\n};\n/**\n * Resolve node origin\n *\n * @param {Object} node\n * @returns {Object} node with origin attribute\n */\n\n\nvar resolveNodeOrigin = function resolveNodeOrigin(node) {\n  return compose(evolve({\n    children: map(resolveNodeOrigin)\n  }), converge(assoc('origin'), [getOrigin, identity]))(node);\n};\n/**\n * Resolve document origins\n *\n * @param {Object} document root\n * @returns {Object} documrnt root\n */\n\n\nvar resolveOrigin = evolve({\n  children: map(resolveNodeOrigin)\n});\nvar VALID_ORIENTATIONS = [PORTRAIT, LANDSCAPE];\n/**\n * Get page orientation. Defaults to landscape\n *\n * @param { Object } page object\n * @returns { String } page orientation\n */\n\nvar getOrientation = compose(ifElse(includes(__, VALID_ORIENTATIONS), identity, always(PORTRAIT)), pathOr(PORTRAIT, ['props', 'orientation']));\nvar isLandscape = compose(equals(LANDSCAPE), getOrientation);\n/**\n * Transforms array into size object\n *\n * @param {Array} array\n * @returns {Object} size object with width and height\n */\n\nvar toSizeObject = applySpec({\n  width: prop(0),\n  height: prop(1)\n});\n/**\n * Flip size object\n *\n * @param {Object} size object\n * @returns {Object} flipped size object\n */\n\nvar flipSizeObject = applySpec({\n  width: prop('height'),\n  height: prop('width')\n});\n/**\n * Returns size object from a given string\n *\n * @param {String} page size string\n * @returns {Object} size object with width and height\n */\n\nvar getStringSize = compose(toSizeObject, prop(__, PAGE_SIZES), toUpper);\n/**\n * Returns size object from a single number\n *\n * @param {Number} page size number\n * @returns {Object} size object with width and height\n */\n\nvar getNumberSize = compose(toSizeObject, function (v) {\n  return [v];\n});\n/**\n * Throws invalid size error\n *\n * @param {String} invalid page size input\n */\n\nvar throwInvalidError = function throwInvalidError(size) {\n  throw new Error(\"Invalid Page size: \" + JSON.stringify(size));\n};\n/**\n * Return page size in an object { width, height }\n *\n * @param {Object} page instance\n * @returns {Object} size object with width and height\n */\n\n\nvar getSize = function getSize(page) {\n  var size = compose(cond([[is(String), getStringSize], [is(Array), toSizeObject], [is(Number), getNumberSize], [is(Object), identity], [T, throwInvalidError]]), pathOr('A4', ['props', 'size']))(page);\n  return isLandscape(page) ? flipSizeObject(size) : size;\n};\n/**\n * Add empt box prop if not present in node\n *\n * @param {Object} node\n * @returns {Object} node with box prop\n */\n\n\nvar assocIfNil = function assocIfNil(key, value, target) {\n  return when(compose(isNil, prop(key)), assoc(key, value))(target);\n};\n\nvar assocIfNil$1 = curryN(3, assocIfNil);\n/**\n * Resolves page size\n *\n * @param {Object} page\n * @returns {Object} page with resolved size in style attribute\n */\n\nvar resolvePageSize = function resolvePageSize(page) {\n  var size = getSize(page);\n  return evolve({\n    style: merge(__, size)\n  })(page);\n};\n/**\n * Resolves page sizes\n *\n * @param {Object} document root\n * @returns {Object} document root with resolved page sizes\n */\n\n\nvar resolvePageSizes = evolve({\n  children: map(compose(resolvePageSize, assocIfNil$1('style', {})))\n});\n/**\n * Get line index at given height\n *\n * @param {Object} node\n * @param {Number} height\n */\n\nvar lineIndexAtHeight = function lineIndexAtHeight(node, height) {\n  var y = 0;\n  if (!node.lines) return 0;\n\n  for (var i = 0; i < node.lines.length; i++) {\n    var line = node.lines[i];\n    if (y + line.box.height > height) return i;\n    y += line.box.height;\n  }\n\n  return node.lines.length;\n};\n/**\n * Get height for given text line index\n *\n * @param {Object} node\n * @param {Number} index\n */\n\n\nvar heightAtLineIndex = function heightAtLineIndex(node, index) {\n  var counter = 0;\n  if (!node.lines) return counter;\n\n  for (var i = 0; i < index; i++) {\n    var line = node.lines[i];\n    if (!line) break;\n    counter += line.box.height;\n  }\n\n  return counter;\n};\n\nvar zero = always(0);\nvar getTop = pathOr(0, ['box', 'top']);\nvar getWidows = pathOr(2, ['props', 'widows']);\nvar getOrphans = pathOr(2, ['props', 'orphans']);\n\nvar getLineBreak = function getLineBreak(node, height) {\n  var top = getTop(node);\n  var widows = getWidows(node);\n  var orphans = getOrphans(node);\n  var linesQuantity = node.lines.length;\n  var slicedLine = lineIndexAtHeight(node, height - top);\n\n  if (slicedLine === 0) {\n    return 0;\n  } else if (linesQuantity < orphans) {\n    return linesQuantity;\n  } else if (slicedLine < orphans || linesQuantity < orphans + widows) {\n    return 0;\n  } else if (linesQuantity === orphans + widows) {\n    return orphans;\n  } else if (linesQuantity - slicedLine < widows) {\n    return linesQuantity - widows;\n  }\n\n  return slicedLine;\n};\n\nvar splitText = function splitText(node, height) {\n  var slicedLineIndex = getLineBreak(node, height);\n  var currentHeight = heightAtLineIndex(node, slicedLineIndex);\n  var nextHeight = node.box.height - currentHeight;\n  var current = evolve({\n    lines: slice(0, slicedLineIndex),\n    style: evolve({\n      marginBottom: zero,\n      paddingBottom: zero,\n      borderBottomWidth: zero,\n      borderBottomLeftRadius: zero,\n      borderBottomRightRadius: zero\n    }),\n    box: {\n      height: always(currentHeight),\n      borderBottomWidth: zero\n    }\n  }, node);\n  var next = evolve({\n    lines: slice(slicedLineIndex, Infinity),\n    style: evolve({\n      marginTop: zero,\n      paddingTop: zero,\n      borderTopWidth: zero,\n      borderTopLeftRadius: zero,\n      borderTopRightRadius: zero\n    }),\n    box: {\n      top: zero,\n      height: always(nextHeight),\n      borderTopWidth: zero\n    }\n  }, node);\n  return [current, next];\n};\n\nvar zero$1 = always(0);\nvar getTop$1 = pathOr(0, ['box', 'top']);\nvar hasFixedHeight = hasPath(['style', 'height']);\n\nvar subtractHeight = function subtractHeight(value) {\n  return o(subtract(__, value), path(['box', 'height']));\n};\n\nvar splitNode = function splitNode(node, height) {\n  if (!node) return [null, null];\n  var nodeTop = getTop$1(node); // TODO: We should keep style untouched\n\n  var current = evolve({\n    style: evolve({\n      marginBottom: zero$1,\n      paddingBottom: zero$1,\n      borderBottomWidth: zero$1,\n      borderBottomLeftRadius: zero$1,\n      borderBottomRightRadius: zero$1\n    }),\n    box: {\n      height: always(height - nodeTop),\n      borderBottomWidth: zero$1\n    }\n  })(node);\n  var nextHeight = ifElse(hasFixedHeight, subtractHeight(height - nodeTop), always(null))(node); // TODO: We should keep style untouched\n\n  var next = evolve({\n    style: evolve({\n      marginTop: zero$1,\n      paddingTop: zero$1,\n      borderTopWidth: zero$1,\n      borderTopLeftRadius: zero$1,\n      borderTopRightRadius: zero$1\n    }),\n    box: {\n      top: zero$1,\n      height: always(nextHeight),\n      borderTopWidth: zero$1\n    }\n  })(node);\n  return [current, next];\n};\n\nvar isString = is(String);\nvar isNumber$1 = is(Number);\nvar isNotString = complement(isString);\n/**\n * Transforms a react element instance to internal element format\n *\n * @param {Object} React element\n * @returns {Object} parsed react element\n */\n\nvar createInstance = function createInstance(element) {\n  if (isString(element) || isNumber$1(element)) return {\n    type: TEXT_INSTANCE,\n    value: \"\" + element\n  };\n  if (isNotString(element.type)) return createInstance(element.type(element.props));\n\n  var type = element.type,\n      _element$props = element.props,\n      _element$props$style = _element$props.style,\n      style = _element$props$style === void 0 ? {} : _element$props$style,\n      _element$props$childr = _element$props.children,\n      children = _element$props$childr === void 0 ? [] : _element$props$childr,\n      props = _objectWithoutPropertiesLoose(_element$props, [\"style\", \"children\"]);\n\n  var nextChildren = compose(map(createInstance), castArray)(children);\n  return {\n    type: type,\n    style: style,\n    props: props,\n    box: {},\n    children: nextChildren\n  };\n};\n/**\n * Get many nodes height\n *\n * @param {Array} nodes\n * @return {number} nodes height\n */\n\n\nvar getNodesHeight = function getNodesHeight(nodes) {\n  var max = 0;\n  var min = Infinity;\n  if (isEmpty(nodes)) return 0;\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    min = Math.min(min, node.box.top);\n    max = Math.max(max, node.box.top + node.box.height);\n  }\n\n  return max - min;\n};\n\nvar getWrap = ifElse(anyPass([isSvg, isNote, isImage, isCanvas]), always(false), pathOr(true, ['props', 'wrap']));\nvar getBreak = pathOr(false, ['props', 'break']);\nvar getMinPresenceAhead = path(['props', 'minPresenceAhead']);\n\nvar defaultPresenceAhead = function defaultPresenceAhead(element) {\n  return function (height) {\n    return Math.min(element.box.height, height);\n  };\n};\n\nvar getPresenceAhead = function getPresenceAhead(elements, height) {\n  var result = 0;\n\n  for (var i = 0; i < elements.length; i++) {\n    var element = elements[i];\n    if (!element.box) continue;\n    var isElementInside = height > element.box.top;\n    var presenceAhead = element.props.presenceAhead || defaultPresenceAhead(element);\n\n    if (element && isElementInside) {\n      result += presenceAhead(height - element.box.top);\n    }\n  }\n\n  return result;\n};\n\nvar shouldBreak = function shouldBreak(child, futureElements, height) {\n  var minPresenceAhead = getMinPresenceAhead(child);\n  var presenceAhead = getPresenceAhead(futureElements, height);\n  var futureHeight = getNodesHeight(futureElements);\n  var shouldSplit = height < child.box.top + child.box.height;\n  var shouldWrap = getWrap(child);\n  return getBreak(child) || !shouldWrap && shouldSplit || minPresenceAhead < futureHeight && presenceAhead < minPresenceAhead;\n};\n\nvar getComputedPadding = function getComputedPadding(edge) {\n  return function (node) {\n    var yogaNode = node._yogaNode;\n    return yogaNode ? yogaNode.getComputedPadding(edge) : null;\n  };\n};\n/**\n * Get Yoga computed paddings. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} paddings\n */\n\n\nvar getPadding = applySpec({\n  paddingTop: firstPass(getComputedPadding(Yoga.EDGE_TOP), path(['box', 'paddingTop']), path(['style', 'paddingTop']), path(['style', 'paddingVertical']), path(['style', 'padding']), always(0)),\n  paddingRight: firstPass(getComputedPadding(Yoga.EDGE_RIGHT), path(['box', 'paddingRight']), path(['style', 'paddingRight']), path(['style', 'paddingHorizontal']), path(['style', 'padding']), always(0)),\n  paddingBottom: firstPass(getComputedPadding(Yoga.EDGE_BOTTOM), path(['box', 'paddingBottom']), path(['style', 'paddingBottom']), path(['style', 'paddingVertical']), path(['style', 'padding']), always(0)),\n  paddingLeft: firstPass(getComputedPadding(Yoga.EDGE_LEFT), path(['box', 'paddingLeft']), path(['style', 'paddingLeft']), path(['style', 'paddingHorizontal']), path(['style', 'padding']), always(0))\n});\n\nvar getContentArea = function getContentArea(page) {\n  var _getPadding = getPadding(page),\n      paddingTop = _getPadding.paddingTop;\n\n  var height = path(['style', 'height'], page);\n  return height - paddingTop;\n};\n\nvar IGNORABLE_CODEPOINTS = [8232, // LINE_SEPARATOR\n8233];\n\nvar buildSubsetForFont = function buildSubsetForFont(font) {\n  return IGNORABLE_CODEPOINTS.reduce(function (acc, codePoint) {\n    if (font.hasGlyphForCodePoint && font.hasGlyphForCodePoint(codePoint)) {\n      return acc;\n    }\n\n    return [].concat(acc, [String.fromCharCode(codePoint)]);\n  }, []);\n};\n\nvar ignoreChars = function ignoreChars(fragments) {\n  return fragments.map(function (fragment) {\n    var charSubset = buildSubsetForFont(fragment.attributes.font);\n    var subsetRegex = new RegExp(charSubset.join('|'));\n    return {\n      string: fragment.string.replace(subsetRegex, ''),\n      attributes: fragment.attributes\n    };\n  });\n};\n\nvar PREPROCESSORS = [ignoreChars, embedEmojis];\n/**\n * Get textkit framgents of given node object\n *\n * @param {Object} instance node\n * @returns {Array} text fragments\n */\n\nvar getFragments$1 = function getFragments(instance) {\n  if (!instance) return [{\n    string: ''\n  }];\n  var fragments = [];\n  var _instance$style = instance.style,\n      _instance$style$color = _instance$style.color,\n      color = _instance$style$color === void 0 ? 'black' : _instance$style$color,\n      backgroundColor = _instance$style.backgroundColor,\n      _instance$style$fontF = _instance$style.fontFamily,\n      fontFamily = _instance$style$fontF === void 0 ? 'Helvetica' : _instance$style$fontF,\n      fontWeight = _instance$style.fontWeight,\n      fontStyle = _instance$style.fontStyle,\n      _instance$style$fontS = _instance$style.fontSize,\n      fontSize = _instance$style$fontS === void 0 ? 18 : _instance$style$fontS,\n      _instance$style$textA = _instance$style.textAlign,\n      textAlign = _instance$style$textA === void 0 ? 'left' : _instance$style$textA,\n      lineHeight = _instance$style.lineHeight,\n      textDecoration = _instance$style.textDecoration,\n      textDecorationColor = _instance$style.textDecorationColor,\n      textDecorationStyle = _instance$style.textDecorationStyle,\n      textTransform = _instance$style.textTransform,\n      letterSpacing = _instance$style.letterSpacing,\n      textIndent = _instance$style.textIndent,\n      opacity = _instance$style.opacity;\n  var obj = Font$1.getFont({\n    fontFamily: fontFamily,\n    fontWeight: fontWeight,\n    fontStyle: fontStyle\n  });\n  var font = obj ? obj.data : fontFamily;\n  var attributes = {\n    font: font,\n    color: color,\n    opacity: opacity,\n    fontSize: fontSize,\n    backgroundColor: backgroundColor,\n    align: textAlign,\n    indent: textIndent,\n    link: instance.src,\n    characterSpacing: letterSpacing,\n    underlineStyle: textDecorationStyle,\n    underline: textDecoration === 'underline',\n    underlineColor: textDecorationColor || color,\n    strike: textDecoration === 'line-through',\n    strikeStyle: textDecorationStyle,\n    strikeColor: textDecorationColor || color,\n    lineHeight: lineHeight ? lineHeight * fontSize : null\n  };\n  instance.children.forEach(function (child) {\n    if (isImage(child)) {\n      fragments.push({\n        string: String.fromCharCode(0xfffc),\n        attributes: _extends({}, attributes, {\n          attachment: {\n            width: child.style.width || fontSize,\n            height: child.style.height || fontSize,\n            image: child.image.data\n          }\n        })\n      });\n    } else if (isTextInstance(child)) {\n      fragments.push({\n        string: transformText(child.value, textTransform),\n        attributes: attributes\n      });\n    } else {\n      if (child) {\n        var _fragments;\n\n        (_fragments = fragments).push.apply(_fragments, getFragments(child));\n      }\n    }\n  });\n\n  for (var _i = 0; _i < PREPROCESSORS.length; _i++) {\n    var preprocessor = PREPROCESSORS[_i];\n    fragments = preprocessor(fragments);\n  }\n\n  return fragments;\n};\n/**\n * Get textkit attributed string from text node\n *\n * @param {Object} instance node\n * @returns {Object} attributed string\n */\n\n\nvar getAttributedString$1 = function getAttributedString(instance) {\n  return AttributedString.fromFragments(getFragments$1(instance));\n};\n\nvar engines$1 = {\n  linebreaker: linebreaker,\n  justification: justification,\n  textDecoration: textDecoration,\n  scriptItemizer: scriptItemizer,\n  wordHyphenation: wordHyphenation,\n  fontSubstitution: fontSubstitution\n};\nvar engine$1 = layoutEngine(engines$1);\n/**\n * Get layout container for specific text node\n *\n * @param {Object} node\n * @param {Number} width\n * @param {Number} height\n * @returns {Object} layout container\n */\n\nvar getContainer$1 = function getContainer(node, width, height) {\n  var maxLines = path(['style', 'maxLines'], node);\n  var textOverflow = path(['style', 'textOverflow'], node);\n  return {\n    x: 0,\n    y: 0,\n    width: width,\n    maxLines: maxLines,\n    height: height || Infinity,\n    truncateMode: textOverflow\n  };\n};\n/**\n * Get text layout options for specific text node\n *\n * @param {Object} node instance\n * @returns {Object} layout options\n */\n\n\nvar getLayoutOptions = function getLayoutOptions(node) {\n  return {\n    hyphenationPenalty: node.props.hyphenationPenalty,\n    hyphenationCallback: Font$1.getHyphenationCallback(),\n    shrinkWhitespaceFactor: {\n      before: -0.5,\n      after: -0.5\n    }\n  };\n};\n/**\n * Get text lines for given node\n *\n * @param {Object} node\n * @param {Number} container width\n * @param {Number} container height\n * @returns {Array} layout lines\n */\n\n\nvar layoutText$1 = compose(reduce(concat, []), converge(engine$1, [getAttributedString$1, getContainer$1, getLayoutOptions]));\nvar isNotSvg = complement(isSvg);\n\nvar hasLines = function hasLines(node) {\n  return node.props.fixed ? !isEmpty(node.lines) : !!node.lines;\n};\n\nvar shouldLayoutText = function shouldLayoutText(node) {\n  return isText(node) && !hasLines(node);\n};\n/**\n * Performs text layout on text node if wasn't calculated before.\n * Text layout is usually performed on Yoga's layout process (via setMeasureFunc),\n * but we need to layout those nodes with fixed width and height.\n *\n * @param {Object} node\n * @returns {Object} layouted node\n */\n\n\nvar resolveTextLayout = function resolveTextLayout(node) {\n  return compose(evolve({\n    children: map(when(isNotSvg, resolveTextLayout))\n  }), when(shouldLayoutText, compose(converge(assoc('lines'), [converge(layoutText$1, [identity, path(['box', 'width']), path(['box', 'height'])]), identity]))))(node);\n};\n/**\n * Get styles sub group of inherited properties\n *\n * @param {Object} style object\n * @returns {Object} style object only with inherited properties\n */\n\n\nvar getInheritStyles = compose(pick(INHERITED_PROPERTIES), propOr({}, 'style'));\n/**\n * Merges styles with node\n *\n * @param {Object} style object\n * @param {Object} node\n * @returns {Object} node with styles merged\n */\n\nvar mergeStyles$2 = function mergeStyles(styles) {\n  return evolve({\n    style: merge(styles)\n  });\n};\n/**\n * Inherit style values from the root to the leafs\n *\n * @param {Object} document root\n * @returns {Object} document root with inheritance\n *\n */\n\n\nvar resolveInheritance = function resolveInheritance(node) {\n  if (isSvg(node)) return node;\n  var inheritStyles = getInheritStyles(node);\n  return evolve({\n    children: map(compose(resolveInheritance, mergeStyles$2(inheritStyles)))\n  })(node);\n};\n\nvar getComputedMargin = function getComputedMargin(edge) {\n  return function (node) {\n    var yogaNode = node._yogaNode;\n    return yogaNode ? yogaNode.getComputedMargin(edge) : null;\n  };\n};\n/**\n * Get Yoga computed magins. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} margins\n */\n\n\nvar getMargin = applySpec({\n  marginTop: firstPass(getComputedMargin(Yoga.EDGE_TOP), path(['box', 'marginTop']), path(['style', 'marginTop']), path(['style', 'marginVertical']), path(['style', 'margin']), always(0)),\n  marginRight: firstPass(getComputedMargin(Yoga.EDGE_RIGHT), path(['box', 'marginRight']), path(['style', 'marginRight']), path(['style', 'marginHorizontal']), path(['style', 'margin']), always(0)),\n  marginBottom: firstPass(getComputedMargin(Yoga.EDGE_BOTTOM), path(['box', 'marginBottom']), path(['style', 'marginBottom']), path(['style', 'marginVertical']), path(['style', 'margin']), always(0)),\n  marginLeft: firstPass(getComputedMargin(Yoga.EDGE_LEFT), path(['box', 'marginLeft']), path(['style', 'marginLeft']), path(['style', 'marginHorizontal']), path(['style', 'margin']), always(0))\n});\n\nvar getTop$2 = function getTop(yogaNode) {\n  return yogaNode ? yogaNode.getComputedTop() : 0;\n};\n\nvar getRight = function getRight(yogaNode) {\n  return yogaNode ? yogaNode.getComputedRight() : 0;\n};\n\nvar getBottom = function getBottom(yogaNode) {\n  return yogaNode ? yogaNode.getComputedBottom() : 0;\n};\n\nvar getLeft = function getLeft(yogaNode) {\n  return yogaNode ? yogaNode.getComputedLeft() : 0;\n};\n/**\n * Get Yoga computed position. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} position\n */\n\n\nvar getPosition = function getPosition(node) {\n  var yogaNode = node._yogaNode;\n  return applySpec({\n    top: getTop$2,\n    right: getRight,\n    bottom: getBottom,\n    left: getLeft\n  })(yogaNode);\n};\n\nvar DEFAULT_DIMENSION = {\n  width: 0,\n  height: 0\n};\n/**\n * Get Yoga computed dimensions. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} dimensions\n */\n\nvar getDimension = function getDimension(node) {\n  var yogaNode = node._yogaNode;\n  if (!yogaNode) return DEFAULT_DIMENSION;\n  return {\n    width: yogaNode.getComputedWidth(),\n    height: yogaNode.getComputedHeight()\n  };\n};\n\nvar getComputedBorder = function getComputedBorder(edge) {\n  return function (yogaNode) {\n    return yogaNode ? yogaNode.getComputedBorder(edge) : 0;\n  };\n};\n/**\n * Get Yoga computed border width. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} border widths\n */\n\n\nvar getBorderWidth = function getBorderWidth(node) {\n  var yogaNode = node._yogaNode;\n  return applySpec({\n    borderTopWidth: getComputedBorder(Yoga.EDGE_TOP),\n    borderRightWidth: getComputedBorder(Yoga.EDGE_RIGHT),\n    borderBottomWidth: getComputedBorder(Yoga.EDGE_BOTTOM),\n    borderLeftWidth: getComputedBorder(Yoga.EDGE_LEFT)\n  })(yogaNode);\n};\n/**\n * Set display attribute to node's Yoga instance\n *\n * @param {String} display\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\n\nvar setDisplay = function setDisplay(value) {\n  return tap(function (node) {\n    var yogaNode = node._yogaNode;\n\n    if (yogaNode) {\n      yogaNode.setDisplay(value === 'none' ? Yoga.DISPLAY_NONE : Yoga.DISPLAY_FLEX);\n    }\n  });\n};\n/**\n * Set overflow attribute to node's Yoga instance\n *\n * @param {String} overflow value\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\n\nvar setOverflow = function setOverflow(value) {\n  return tap(function (node) {\n    var yogaNode = node._yogaNode;\n\n    if (!isNil(value) && yogaNode) {\n      var yogaValue = cond([[equals('hidden'), always(Yoga.OVERFLOW_HIDDEN)], [equals('scroll'), always(Yoga.OVERFLOW_SCROLL)], [T, always(Yoga.OVERFLOW_VISIBLE)]])(value);\n      yogaNode.setOverflow(yogaValue);\n    }\n  });\n};\n/**\n * Set flex wrap attribute to node's Yoga instance\n *\n * @param {String} flex wrap value\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\n\nvar setFlexWrap = function setFlexWrap(value) {\n  return tap(function (node) {\n    var yogaNode = node._yogaNode;\n\n    if (yogaNode) {\n      var yogaValue = cond([[equals('wrap'), always(Yoga.WRAP_WRAP)], [equals('wrap-reverse'), always(Yoga.WRAP_WRAP_REVERSE)], [T, always(Yoga.WRAP_NO_WRAP)]])(value);\n      yogaNode.setFlexWrap(yogaValue);\n    }\n  });\n};\n\nvar isNotNil$1 = complement(isNil);\n/**\n * Set generic yoga attribute to node's Yoga instance, handing `auto`, edges and percentage cases\n *\n * @param {String} property\n * @param {Number} edge\n * @param {any} value\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setYogaValue = function setYogaValue(attr, edge) {\n  return function (value) {\n    return tap(function (node) {\n      var yogaNode = node._yogaNode;\n\n      if (!isNil(value) && yogaNode) {\n        var hasEdge = isNotNil$1(edge);\n        var fixedMethod = \"set\" + upperFirst$1(attr);\n        var autoMethod = fixedMethod + \"Auto\";\n        var percentMethod = fixedMethod + \"Percent\";\n        var percent = matchPercent(value);\n\n        if (percent && !yogaNode[percentMethod]) {\n          throw new Error(\"You can't pass percentage values to \" + attr + \" property\");\n        }\n\n        if (percent) {\n          hasEdge ? yogaNode[percentMethod](edge, percent.value) : yogaNode[percentMethod](percent.value);\n        } else if (value === 'auto') {\n          hasEdge ? yogaNode[autoMethod](edge) : yogaNode[autoMethod]();\n        } else {\n          hasEdge ? yogaNode[fixedMethod](edge, value) : yogaNode[fixedMethod](value);\n        }\n      }\n    });\n  };\n};\n/**\n * Set flex grow attribute to node's Yoga instance\n *\n * @param {Number} flex grow value\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\n\nvar setFlexGrow = compose(setYogaValue('flexGrow'), defaultTo(0));\n/**\n * Set flex basis attribute to node's Yoga instance\n *\n * @param {Number} flex basis value\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setFlexBasis = setYogaValue('flexBasis');\n/**\n * Set generic align attribute to node's Yoga instance\n *\n * @param {String} specific align property\n * @param {String} align value\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setAlign = function setAlign(attr) {\n  return function (value) {\n    return tap(function (node) {\n      var yogaNode = node._yogaNode;\n\n      if (yogaNode) {\n        var yogaValue = cond([[equals('flex-start'), always(Yoga.ALIGN_FLEX_START)], [equals('center'), always(Yoga.ALIGN_CENTER)], [equals('flex-end'), always(Yoga.ALIGN_FLEX_END)], [equals('stretch'), always(Yoga.ALIGN_STRETCH)], [equals('baseline'), always(Yoga.ALIGN_BASELINE)], [equals('space-between'), always(Yoga.ALIGN_SPACE_BETWEEN)], [equals('space-around'), always(Yoga.ALIGN_SPACE_AROUND)], [T, always(attr === 'items' ? Yoga.ALIGN_STRETCH : Yoga.ALIGN_AUTO)]])(value);\n        yogaNode[\"setAlign\" + upperFirst$1(attr)](yogaValue);\n      }\n    });\n  };\n};\n/**\n * Set align self attribute to node's Yoga instance\n *\n * @param {String} align value\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\n\nvar setAlignSelf = setAlign('self');\n/**\n * Set align items attribute to node's Yoga instance\n *\n * @param {String} align value\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setAlignItems = setAlign('items');\n/**\n * Set flex shrink attribute to node's Yoga instance\n *\n * @param {Number} flex shrink value\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setFlexShrink = compose(setYogaValue('flexShrink'), defaultTo(1));\n/**\n * Set aspect ratio attribute to node's Yoga instance\n *\n * @param {Number} ratio\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setAspectRatio = function setAspectRatio(value) {\n  return tap(function (node) {\n    var yogaNode = node._yogaNode;\n\n    if (!isNil(value) && yogaNode) {\n      yogaNode.setAspectRatio(value);\n    }\n  });\n};\n/**\n * Set align content attribute to node's Yoga instance\n *\n * @param {String} align value\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\n\nvar setAlignContent = setAlign('content');\n/**\n * Set position type attribute to node's Yoga instance\n *\n * @param {String} position type\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setPositionType = function setPositionType(value) {\n  return tap(function (node) {\n    var yogaNode = node._yogaNode;\n\n    if (!isNil(value) && yogaNode) {\n      yogaNode.setPositionType(value === 'absolute' ? Yoga.POSITION_TYPE_ABSOLUTE : Yoga.POSITION_TYPE_RELATIVE);\n    }\n  });\n};\n\nvar isRow = equals('row');\nvar isRowReverse = equals('row-reverse');\nvar isColumnReverse = equals('column-reverse');\n/**\n * Set flex direction attribute to node's Yoga instance\n *\n * @param {String} flex direction value\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setFlexDirection = function setFlexDirection(value) {\n  return tap(function (node) {\n    var yogaNode = node._yogaNode;\n\n    if (yogaNode) {\n      var yogaValue = cond([[isRow, always(Yoga.FLEX_DIRECTION_ROW)], [isRowReverse, always(Yoga.FLEX_DIRECTION_ROW_REVERSE)], [isColumnReverse, always(Yoga.FLEX_DIRECTION_COLUMN_REVERSE)], [T, always(Yoga.FLEX_DIRECTION_COLUMN)]])(value);\n      yogaNode.setFlexDirection(yogaValue);\n    }\n  });\n};\n/**\n * Set justify content attribute to node's Yoga instance\n *\n * @param {String} justify content value\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\n\nvar setJustifyContent = function setJustifyContent(value) {\n  return tap(function (node) {\n    var yogaNode = node._yogaNode;\n\n    if (!isNil(value) && yogaNode) {\n      var yogaValue = cond([[equals('center'), always(Yoga.JUSTIFY_CENTER)], [equals('flex-end'), always(Yoga.JUSTIFY_FLEX_END)], [equals('space-between'), always(Yoga.JUSTIFY_SPACE_BETWEEN)], [equals('space-around'), always(Yoga.JUSTIFY_SPACE_AROUND)], [equals('space-evenly'), always(Yoga.JUSTIFY_SPACE_EVENLY)], [T, always(Yoga.JUSTIFY_FLEX_START)]])(value);\n      yogaNode.setJustifyContent(yogaValue);\n    }\n  });\n};\n/**\n * Set margin top attribute to node's Yoga instance\n *\n * @param {Number} margin top\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\n\nvar setMarginTop = setYogaValue('margin', Yoga.EDGE_TOP);\n/**\n * Set margin right attribute to node's Yoga instance\n *\n * @param {Number} margin right\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setMarginRight = setYogaValue('margin', Yoga.EDGE_RIGHT);\n/**\n * Set margin bottom attribute to node's Yoga instance\n *\n * @param {Number} margin bottom\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setMarginBottom = setYogaValue('margin', Yoga.EDGE_BOTTOM);\n/**\n * Set margin left attribute to node's Yoga instance\n *\n * @param {Number} margin left\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setMarginLeft = setYogaValue('margin', Yoga.EDGE_LEFT);\n/**\n * Set padding top attribute to node's Yoga instance\n *\n * @param {Number} padding top\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setPaddingTop = setYogaValue('padding', Yoga.EDGE_TOP);\n/**\n * Set padding right attribute to node's Yoga instance\n *\n * @param {Number} padding right\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setPaddingRight = setYogaValue('padding', Yoga.EDGE_RIGHT);\n/**\n * Set padding bottom attribute to node's Yoga instance\n *\n * @param {Number} padding bottom\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setPaddingBottom = setYogaValue('padding', Yoga.EDGE_BOTTOM);\n/**\n * Set padding left attribute to node's Yoga instance\n *\n * @param {Number} padding left\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setPaddingLeft = setYogaValue('padding', Yoga.EDGE_LEFT);\n/**\n * Set border top attribute to node's Yoga instance\n *\n * @param {Number} border top width\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setBorderTop = setYogaValue('border', Yoga.EDGE_TOP);\n/**\n * Set border right attribute to node's Yoga instance\n *\n * @param {Number} border right width\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setBorderRight = setYogaValue('border', Yoga.EDGE_RIGHT);\n/**\n * Set border bottom attribute to node's Yoga instance\n *\n * @param {Number} border bottom width\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setBorderBottom = setYogaValue('border', Yoga.EDGE_BOTTOM);\n/**\n * Set border left attribute to node's Yoga instance\n *\n * @param {Number} border left width\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setBorderLeft = setYogaValue('border', Yoga.EDGE_LEFT);\n/**\n * Set position top attribute to node's Yoga instance\n *\n * @param {Number} position top\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setPositionTop = setYogaValue('position', Yoga.EDGE_TOP);\n/**\n * Set position right attribute to node's Yoga instance\n *\n * @param {Number} position right\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setPositionRight = setYogaValue('position', Yoga.EDGE_RIGHT);\n/**\n * Set position bottom attribute to node's Yoga instance\n *\n * @param {Number} position bottom\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setPositionBottom = setYogaValue('position', Yoga.EDGE_BOTTOM);\n/**\n * Set position left attribute to node's Yoga instance\n *\n * @param {Number} position left\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setPositionLeft = setYogaValue('position', Yoga.EDGE_LEFT);\n/**\n * Set width to node's Yoga instance\n *\n * @param {Number} width\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setWidth = setYogaValue('width');\n/**\n * Set min width to node's Yoga instance\n *\n * @param {Number} min width\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setMinWidth = setYogaValue('minWidth');\n/**\n * Set max width to node's Yoga instance\n *\n * @param {Number} max width\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setMaxWidth = setYogaValue('maxWidth');\n/**\n * Set height to node's Yoga instance\n *\n * @param {Number} height\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setHeight = setYogaValue('height');\n/**\n * Set min height to node's Yoga instance\n *\n * @param {Number} min height\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setMinHeight = setYogaValue('minHeight');\n/**\n * Set max height to node's Yoga instance\n *\n * @param {Number} max height\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setMaxHeight = setYogaValue('maxHeight');\n\nvar getAspectRatio = function getAspectRatio(viewbox) {\n  if (!viewbox) return null;\n  return (viewbox.maxX - viewbox.minX) / (viewbox.maxY - viewbox.minY);\n};\n/**\n * Yoga svg measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @param {Number} width\n * @param {Number} widthMode\n * @param {Number} height\n * @param {Number} heightMode\n * @returns {Object} canvas width and height\n */\n\n\nvar measureCanvas = function measureCanvas(page, node, width, widthMode, height, heightMode) {\n  var aspectRatio = getAspectRatio(node.props.viewBox) || 1;\n\n  if (widthMode === Yoga.MEASURE_MODE_EXACTLY || widthMode === Yoga.MEASURE_MODE_AT_MOST) {\n    return {\n      width: width,\n      height: width / aspectRatio\n    };\n  }\n\n  if (heightMode === Yoga.MEASURE_MODE_EXACTLY) {\n    return {\n      width: height * aspectRatio\n    };\n  }\n\n  return {};\n};\n\nvar measureSvg = curryN(6, measureCanvas);\n/**\n * Get lines width (if any)\n *\n * @param {Object} node\n * @returns {Number} lines width\n */\n\nvar linesWidth = function linesWidth(node) {\n  if (!node.lines) return -1;\n  return Math.max.apply(Math, node.lines.map(function (line) {\n    return AttributedString.advanceWidth(line);\n  }));\n};\n/**\n * Get lines height (if any)\n *\n * @param {Object} node\n * @returns {Number} lines height\n */\n\n\nvar linesHeight = function linesHeight(node) {\n  if (!node.lines) return -1;\n  return node.lines.reduce(function (acc, line) {\n    return acc + line.box.height;\n  }, 0);\n};\n/**\n * Yoga text measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @param {Number} width\n * @param {Number} widthMode\n * @param {Number} height\n * @param {Number} heightMode\n * @returns {Object} text width and height\n */\n\n\nvar measureText = function measureText(page, node, width, widthMode, height, heightMode) {\n  if (widthMode === Yoga.MEASURE_MODE_EXACTLY) {\n    if (!node.lines) node.lines = layoutText$1(node, width, height);\n    return {\n      height: linesHeight(node)\n    };\n  }\n\n  if (widthMode === Yoga.MEASURE_MODE_AT_MOST) {\n    if (!node.lines) node.lines = layoutText$1(node, width, height);\n    return {\n      height: linesHeight(node),\n      width: Math.min(width, linesWidth(node))\n    };\n  }\n\n  return {};\n};\n\nvar measureText$1 = curryN(6, measureText);\n/**\n * Get image ratio\n *\n * @param {Object} image node\n * @returns {Number} image ratio\n */\n\nvar getRatio = ifElse(hasPath(['image', 'data']), function (node) {\n  return node.image.width / node.image.height;\n}, always(1));\n/**\n * Checks if page has auto height\n *\n * @param {Object} page\n * @returns {Boolean} is page height auto\n */\n\nvar isHeightAuto = pathSatisfies(isNil, ['box', 'height']);\nvar SAFETY_HEIGHT = 10;\n/**\n * Yoga image measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @param {Number} width\n * @param {Number} widthMode\n * @param {Number} height\n * @param {Number} heightMode\n * @returns {Object} image width and height\n */\n\nvar measureImage = function measureImage(page, node, width, widthMode, height, heightMode) {\n  var imageRatio = getRatio(node);\n  var imageMargin = getMargin(node);\n  var pagePadding = getPadding(page);\n  var pageArea = isHeightAuto(page) ? Infinity : page.box.height - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT; // Skip measure if image data not present yet\n\n  if (!node.image) return {\n    width: 0,\n    height: 0\n  };\n\n  if (widthMode === Yoga.MEASURE_MODE_EXACTLY && heightMode === Yoga.MEASURE_MODE_UNDEFINED) {\n    var scaledHeight = width / imageRatio;\n    return {\n      height: Math.min(pageArea, scaledHeight)\n    };\n  }\n\n  if (heightMode === Yoga.MEASURE_MODE_EXACTLY && (widthMode === Yoga.MEASURE_MODE_AT_MOST || widthMode === Yoga.MEASURE_MODE_UNDEFINED)) {\n    return {\n      width: Math.min(height * imageRatio, width)\n    };\n  }\n\n  if (widthMode === Yoga.MEASURE_MODE_EXACTLY && heightMode === Yoga.MEASURE_MODE_AT_MOST) {\n    var _scaledHeight = width / imageRatio;\n\n    return {\n      height: Math.min(height, pageArea, _scaledHeight)\n    };\n  }\n\n  if (widthMode === Yoga.MEASURE_MODE_AT_MOST && heightMode === Yoga.MEASURE_MODE_AT_MOST) {\n    if (imageRatio > 1) {\n      return {\n        width: width,\n        height: Math.min(width / imageRatio, height)\n      };\n    } else {\n      return {\n        width: Math.min(height * imageRatio, width),\n        height: height\n      };\n    }\n  }\n\n  return {\n    height: height,\n    width: width\n  };\n};\n\nvar measureImage$1 = curryN(6, measureImage);\nvar SAFETY_HEIGHT$1 = 10;\nvar getMax = reduce(max$1, -Infinity);\n/**\n * Helper object to predict canvas size\n * TODO: Implement remaining functions (as close as possible);\n */\n\nvar measureCtx = function measureCtx() {\n  var ctx = {};\n  var points = [];\n\n  var nil = function nil() {\n    return ctx;\n  };\n\n  var addPoint = function addPoint(x, y) {\n    return points.push([x, y]);\n  };\n\n  var moveTo = compose(nil, addPoint);\n\n  var rect = function rect(x, y, w, h) {\n    addPoint(x, y);\n    addPoint(x + w, y);\n    addPoint(x, y + h);\n    addPoint(x + w, y + h);\n    return ctx;\n  };\n\n  var ellipse = function ellipse(x, y, rx, ry) {\n    ry = ry || rx;\n    addPoint(x - rx, y - ry);\n    addPoint(x + rx, y - ry);\n    addPoint(x + rx, y + ry);\n    addPoint(x - rx, y + ry);\n    return ctx;\n  };\n\n  var polygon = function polygon() {\n    points.push.apply(points, arguments);\n    return nil();\n  }; // Change dimensions\n\n\n  ctx.rect = rect;\n  ctx.moveTo = moveTo;\n  ctx.lineTo = moveTo;\n  ctx.circle = ellipse;\n  ctx.polygon = polygon;\n  ctx.ellipse = ellipse;\n  ctx.roundedRect = rect; // To be implemented\n\n  ctx.text = nil;\n  ctx.path = nil;\n  ctx.lineWidth = nil;\n  ctx.bezierCurveTo = nil;\n  ctx.quadraticCurveTo = nil;\n  ctx.scale = nil;\n  ctx.rotate = nil;\n  ctx.translate = nil; // These don't change dimensions\n\n  ctx.dash = nil;\n  ctx.clip = nil;\n  ctx.save = nil;\n  ctx.fill = nil;\n  ctx.font = nil;\n  ctx.stroke = nil;\n  ctx.lineCap = nil;\n  ctx.opacity = nil;\n  ctx.restore = nil;\n  ctx.lineJoin = nil;\n  ctx.fontSize = nil;\n  ctx.fillColor = nil;\n  ctx.miterLimit = nil;\n  ctx.strokeColor = nil;\n  ctx.fillOpacity = nil;\n  ctx.strokeOpacity = nil;\n  ctx.linearGradient = nil;\n  ctx.radialGradient = nil;\n\n  ctx.getWidth = function () {\n    return compose(getMax, pluck(0))(points);\n  };\n\n  ctx.getHeight = function () {\n    return compose(getMax, pluck(1))(points);\n  };\n\n  return ctx;\n};\n/**\n * Yoga canvas measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @param {Number} width\n * @param {Number} widthMode\n * @param {Number} height\n * @param {Number} heightMode\n * @returns {Object} canvas width and height\n */\n\n\nvar measureCanvas$1 = function measureCanvas(page, node) {\n  var imageMargin = getMargin(node);\n  var pagePadding = getPadding(page);\n  var pageArea = isHeightAuto(page) ? Infinity : page.box.height - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT$1;\n  var ctx = measureCtx();\n  node.props.paint(ctx);\n  var width = ctx.getWidth();\n  var height = Math.min(pageArea, ctx.getHeight());\n  return {\n    height: height,\n    width: width\n  };\n};\n\nvar measureCanvas$2 = curryN(6, measureCanvas$1);\nvar YOGA_NODE = '_yogaNode';\nvar YOGA_CONFIG = Yoga.Config.create();\nYOGA_CONFIG.setPointScaleFactor(0);\n\nvar setNodeHeight = function setNodeHeight(node) {\n  return ifElse(isPage, setHeight(node.box.height), setHeight(node.box.height || node.style.height));\n};\n/**\n * Set styles valeus into yoga node before layout calculation\n *\n * @param {Object} node\n * @returns {Object} node\n */\n\n\nvar setYogaValues = tap(function (node) {\n  compose(setNodeHeight(node), setWidth(node.style.width), setMinWidth(node.style.minWidth), setMaxWidth(node.style.maxWidth), setMinHeight(node.style.minHeight), setMaxHeight(node.style.maxHeight), setMarginTop(node.style.marginTop), setMarginRight(node.style.marginRight), setMarginBottom(node.style.marginBottom), setMarginLeft(node.style.marginLeft), setPaddingTop(node.style.paddingTop), setPaddingRight(node.style.paddingRight), setPaddingBottom(node.style.paddingBottom), setPaddingLeft(node.style.paddingLeft), setPositionType(node.style.position), setPositionTop(node.style.top), setPositionRight(node.style.right), setPositionBottom(node.style.bottom), setPositionLeft(node.style.left), setBorderTop(node.style.borderTopWidth), setBorderRight(node.style.borderRightWidth), setBorderBottom(node.style.borderBottomWidth), setBorderLeft(node.style.borderLeftWidth), setDisplay(node.style.display), setFlexDirection(node.style.flexDirection), setAlignSelf(node.style.alignSelf), setAlignContent(node.style.alignContent), setAlignItems(node.style.alignItems), setJustifyContent(node.style.justifyContent), setFlexWrap(node.style.flexWrap), setOverflow(node.style.overflow), setAspectRatio(node.style.aspectRatio), setFlexBasis(node.style.flexBasis), setFlexGrow(node.style.flexGrow), setFlexShrink(node.style.flexShrink))(node);\n});\n/**\n * Inserts child into parent' yoga node\n *\n * @param {Object} parent\n * @param {Object} node\n * @param {Object} node\n */\n\nvar insertYogaNodes = function insertYogaNodes(parent) {\n  return tap(function (child) {\n    return parent.insertChild(child[YOGA_NODE], parent.getChildCount());\n  });\n};\n\nvar setMeasureFunc = function setMeasureFunc(page) {\n  return function (node) {\n    var yogaNode = node[YOGA_NODE];\n\n    if (isText(node)) {\n      yogaNode.setMeasureFunc(measureText$1(page, node));\n    }\n\n    if (isImage(node)) {\n      yogaNode.setMeasureFunc(measureImage$1(page, node));\n    }\n\n    if (isCanvas(node)) {\n      yogaNode.setMeasureFunc(measureCanvas$2(page, node));\n    }\n\n    if (isSvg(node)) {\n      yogaNode.setMeasureFunc(measureSvg(page, node));\n    }\n\n    return node;\n  };\n};\n\nvar isNotText = complement(isText);\nvar isNotNote = complement(isNote);\nvar isNotSvg$1 = complement(isSvg);\nvar isNotTextInstance = complement(isTextInstance);\nvar isLayoutElement = allPass([isNotText, isNotNote, isNotSvg$1]);\n/**\n * Creates and add yoga node to document tree\n * Handles measure function for text and image nodes\n *\n * @param {Object} node\n * @returns {Object} node with appended yoga node\n */\n\nvar createYogaNodes = function createYogaNodes(page) {\n  return function (node) {\n    var yogaNode = Yoga.Node.createWithConfig(YOGA_CONFIG);\n    return compose(setMeasureFunc(page), when(isLayoutElement, evolve({\n      children: map(compose(insertYogaNodes(yogaNode), createYogaNodes(page)))\n    })), setYogaValues, assoc(YOGA_NODE, yogaNode))(node);\n  };\n};\n/**\n * Performs yoga calculation\n *\n * @param {Object} node\n * @returns {Object} node\n */\n\n\nvar calculateLayout = tap(function (page) {\n  return page[YOGA_NODE].calculateLayout();\n});\n/**\n * Saves Yoga layout result into 'box' attribute of node\n *\n * @param {Object} node\n * @returns {Object} node with box data\n */\n\nvar persistDimensions = function persistDimensions(node) {\n  return evolve({\n    children: map(when(isNotTextInstance, persistDimensions)),\n    box: always(mergeAll([getPadding(node), getMargin(node), getBorderWidth(node), getPosition(node), getDimension(node)]))\n  })(node);\n};\n/**\n * Removes and destroys yoga node frm document tree\n *\n * @param {Object} node\n * @returns {Object} node without yoga node\n */\n\n\nvar destroyYogaNodes = function destroyYogaNodes(node) {\n  return compose(dissoc(YOGA_NODE), tap(function (n) {\n    return Yoga.Node.destroy(n[YOGA_NODE]);\n  }), evolve({\n    children: map(when(isLayoutElement, destroyYogaNodes))\n  }))(node);\n};\n/**\n * Calculates page object layout using Yoga.\n * Takes node values from 'box' and 'style' attributes, and persist them back into 'box'\n * Destroy yoga values at the end.\n *\n * @param {Object} page object\n * @returns {Object} page object with correct 'box' layout attributes\n */\n\n\nvar resolvePageDimensions = function resolvePageDimensions(page) {\n  return ifElse(isNil, always(null), compose(destroyYogaNodes, persistDimensions, calculateLayout, createYogaNodes(page)))(page);\n};\n/**\n * Calculates root object layout using Yoga.\n *\n * @param {Object} root object\n * @returns {Object} root object with correct 'box' layout attributes\n */\n\n\nvar resolveDimensions = function resolveDimensions(node) {\n  return evolve({\n    children: map(resolvePageDimensions)\n  })(node);\n};\n\nvar SAFTY_THRESHOLD = 0.001;\nvar assingChildren = assoc('children');\nvar getTop$3 = pathOr(0, ['box', 'top']);\nvar getHeight = path(['box', 'height']);\nvar getChildren$1 = propOr([], 'children');\nvar isElementOutside = useWith(lte, [identity, getTop$3]);\nvar isFixed = pathEq(['props', 'fixed'], true);\nvar allFixed = all(isFixed);\nvar isDynamic = hasPath(['props', 'render']);\nvar relayoutPage = compose(resolveTextLayout, resolveInheritance, resolvePageDimensions);\n\nvar splitView = function splitView(node, height) {\n  var _splitNode = splitNode(node, height),\n      currentNode = _splitNode[0],\n      nextNode = _splitNode[1];\n\n  var _splitChildren = splitChildren(height, node),\n      currentChilds = _splitChildren[0],\n      nextChildren = _splitChildren[1];\n\n  return [assingChildren(currentChilds)(currentNode), assingChildren(nextChildren)(nextNode)];\n};\n\nvar split = ifElse(isText, splitText, splitView);\n\nvar splitNodes = function splitNodes(height, nodes) {\n  var currentChildren = [];\n  var nextChildren = [];\n\n  for (var i = 0; i < nodes.length; i++) {\n    var child = nodes[i];\n    var futureNodes = nodes.slice(i + 1);\n    var futureFixedNodes = filter(isFixed, futureNodes);\n    var nodeTop = getTop$3(child);\n    var nodeHeight = getHeight(child);\n    var isOutside = isElementOutside(height, child);\n    var shouldBreak$1 = shouldBreak(child, futureNodes, height);\n    var shouldSplit = height + SAFTY_THRESHOLD < nodeTop + nodeHeight;\n\n    if (isFixed(child)) {\n      nextChildren.push(child);\n      currentChildren.push(child);\n      continue;\n    }\n\n    if (isOutside) {\n      var next = evolve({\n        box: {\n          top: subtract(__, height)\n        }\n      })(child);\n      nextChildren.push(next);\n      continue;\n    }\n\n    if (shouldBreak$1) {\n      var _next = evolve({\n        box: {\n          top: subtract(__, height)\n        },\n        props: evolve({\n          break: always(false)\n        })\n      })(child);\n\n      currentChildren.push.apply(currentChildren, futureFixedNodes);\n      nextChildren.push.apply(nextChildren, [_next].concat(futureNodes));\n      break;\n    }\n\n    if (shouldSplit) {\n      var _split = split(child, height),\n          currentChild = _split[0],\n          nextChild = _split[1];\n\n      if (currentChild) currentChildren.push(currentChild);\n      if (nextChild) nextChildren.push(nextChild);\n      continue;\n    }\n\n    currentChildren.push(child);\n  }\n\n  return [currentChildren, nextChildren];\n};\n\nvar splitChildren = function splitChildren(height, node) {\n  var children = getChildren$1(node);\n  var availableHeight = height - getTop$3(node);\n  return splitNodes(availableHeight, children);\n};\n\nvar splitPage = function splitPage(page, pageNumber) {\n  var contentArea = getContentArea(page);\n  var height = path(['style', 'height'], page);\n  var dynamicPage = resolveDynamicPage({\n    pageNumber: pageNumber\n  }, page);\n\n  var _splitNodes = splitNodes(contentArea, dynamicPage.children),\n      currentChilds = _splitNodes[0],\n      nextChilds = _splitNodes[1];\n\n  var currentPage = compose(relayoutPage, assingChildren(currentChilds), assocPath(['box', 'height'], height))(page);\n  if (isEmpty(nextChilds) || allFixed(nextChilds)) return [currentPage, null];\n  var nextPage = compose(relayoutPage, assingChildren(nextChilds), dissocPath(['box', 'height']))(page);\n  return [currentPage, nextPage];\n};\n\nvar shouldResolveDynamicNodes = function shouldResolveDynamicNodes(node) {\n  return either(isDynamic, compose(any(shouldResolveDynamicNodes), propOr([], 'children')))(node);\n};\n\nvar resolveDynamicPage = function resolveDynamicPage(props, page) {\n  return when(shouldResolveDynamicNodes, compose(relayoutPage, resolveDynamicNodes(props)))(page);\n};\n\nvar resolveDynamicNodes = function resolveDynamicNodes(props) {\n  return function (node) {\n    var isNodeDynamic = always(isDynamic(node));\n\n    var resolveRender = function resolveRender() {\n      var res = node.props.render(props);\n      return [createInstance(res)];\n    };\n\n    return evolve({\n      children: ifElse(isNodeDynamic, resolveRender, map(resolveDynamicNodes(props))),\n      lines: when(isNodeDynamic, always([]))\n    }, node);\n  };\n};\n\nvar paginate = function paginate(page, pageNumber) {\n  if (!page) return [];\n  var splittedPage = splitPage(page, pageNumber);\n  var pages = [splittedPage[0]];\n  var nextPage = splittedPage[1];\n\n  while (nextPage !== null) {\n    splittedPage = splitPage(nextPage, pageNumber + pages.length);\n    pages.push(splittedPage[0]);\n    nextPage = splittedPage[1];\n  }\n\n  return pages;\n};\n\nvar resolvePageIndices = function resolvePageIndices(page, pageNumber, pages) {\n  var totalPages = pages.length;\n  return resolveDynamicPage({\n    pageNumber: pageNumber + 1,\n    totalPages: totalPages\n  }, page);\n};\n\nvar resolvePagination = function resolvePagination(doc) {\n  var pages = [];\n  var pageNumber = 1;\n\n  for (var i = 0; i < doc.children.length; i++) {\n    var page = doc.children[i];\n    var subpages = paginate(page, pageNumber);\n    pageNumber += subpages.length;\n    pages = pages.concat(subpages);\n  }\n\n  pages = pages.map(resolvePageIndices);\n  return assingChildren(pages, doc);\n};\n/**\n * Removes margins on node\n *\n * @param {Object} node\n * @returns {Object} node without margins\n */\n\n\nvar removeMargins = compose(dissocPath(['style', 'margin']), dissocPath(['style', 'marginTop']), dissocPath(['style', 'marginRight']), dissocPath(['style', 'marginBottom']), dissocPath(['style', 'marginLeft']), dissocPath(['style', 'marginHorizontal']), dissocPath(['style', 'marginVertical']));\n/**\n * Remove page margins\n *\n * @param {Object} document root\n * @returns {Object} document root without margins on pages\n */\n\nvar resolvePageMargins = evolve({\n  children: map(removeMargins)\n});\n/**\n * Get node underlying text value\n *\n * @param {Object} node\n * @returns {String} node text content\n */\n\nvar getNodeText = function getNodeText(node) {\n  return cond([[is(String), identity], [isTextInstance, prop('value')], [T, compose(getNodesText, propOr([], 'children'))]])(node);\n};\n/**\n * Get underlying text value of several nodes\n *\n * @param {Array} nodes\n * @returns {String} nodes text content\n */\n\n\nvar getNodesText = compose(join(''), map(getNodeText));\n/**\n * Transforms string to text instance\n *\n * @param {String} value\n * @returns {Array} text intance\n */\n\nvar wrapTextInstance = function wrapTextInstance(value) {\n  return [{\n    type: 'TEXT_INSTANCE',\n    value: value\n  }];\n};\n/**\n * Cast Note children as a text instance\n *\n * @param {Object} node\n * @returns {Object} node with resolved note children\n */\n\n\nvar resolveNoteChildren = function resolveNoteChildren(node) {\n  return ifElse(isNote, evolve({\n    children: compose(wrapTextInstance, getNodesText)\n  }), evolve({\n    children: map(resolveNoteChildren)\n  }))(node);\n};\n/*\n * Translates page percentage horizontal paddings in fixed ones\n *\n * @param {Object} page container\n * @param {String} padding value\n * @returns {Object} translated padding value\n */\n\n\nvar resolvePageHorizontalPadding = function resolvePageHorizontalPadding(container) {\n  return function (value) {\n    var match = matchPercent(value);\n    return match ? match.percent * container.width : value;\n  };\n};\n/**\n * Translates page percentage vertical paddings in fixed ones\n *\n * @param {Object} page container\n * @param {String} padding value\n * @returns {Object} translated padding value\n */\n\n\nvar resolvePageVerticalPadding = function resolvePageVerticalPadding(container) {\n  return function (value) {\n    var match = matchPercent(value);\n    return match ? match.percent * container.height : value;\n  };\n};\n/**\n * Translates page percentage paddings in fixed ones\n *\n * @param {Object} page\n * @returns {Object} page with fixed paddings\n */\n\n\nvar resolvePagePaddings = function resolvePagePaddings(page) {\n  var container = pathOr({}, ['props', 'size'], page);\n  return evolve({\n    style: evolve({\n      paddingLeft: resolvePageHorizontalPadding(container),\n      paddingRight: resolvePageHorizontalPadding(container),\n      paddingTop: resolvePageVerticalPadding(container),\n      paddingBottom: resolvePageVerticalPadding(container)\n    })\n  })(page);\n};\n/**\n * Translates all pages percentage paddings in fixed ones\n * This has to be computed from pages calculated size and not by Yoga\n * because at this point we didn't performed pagination yet.\n *\n * @param {Object} document root\n * @returns {Object} document root with translated page paddings\n */\n\n\nvar resolvePagePaddings$1 = evolve({\n  children: map(resolvePagePaddings)\n});\n/**\n *\n * @param {Object} container width and height\n * @param {String | Number} value border radius value\n * @returns {Number} fixed border radius value\n */\n\nvar resolveRadius = function resolveRadius(container) {\n  return function (value) {\n    var match = matchPercent(value);\n    return match ? match.percent * Math.min(container.width, container.height) : value;\n  };\n};\n/**\n * Transforms percent border radius into fixed values\n *\n * @param {Object} node\n * @returns {Object} node\n */\n\n\nvar resolvePercentRadius = function resolvePercentRadius(node) {\n  return evolve({\n    children: map(resolvePercentRadius),\n    style: evolve({\n      borderTopLeftRadius: resolveRadius(node.box),\n      borderTopRightRadius: resolveRadius(node.box),\n      borderBottomRightRadius: resolveRadius(node.box),\n      borderBottomLeftRadius: resolveRadius(node.box)\n    })\n  })(node);\n};\n/**\n * Transform percent height into fixed\n *\n * @param {String | number} height\n * @return {number} height\n */\n\n\nvar transformHeight = function transformHeight(pageArea) {\n  return function (height) {\n    var match = matchPercent(height);\n    return match ? match.percent * pageArea : height;\n  };\n};\n/**\n * Get page area (height minus paddings)\n *\n * @param {Object} page\n * @return {number} page area\n */\n\n\nvar getPageArea = function getPageArea(page) {\n  var pageHeight = path(['style', 'height'], page);\n  var pagePaddingTop = pathOr(0, ['style', 'paddingTop'], page);\n  var pagePaddingBottom = pathOr(0, ['style', 'paddingBottom'], page);\n  return pageHeight - pagePaddingTop - pagePaddingBottom;\n};\n/**\n * Checks if page has height\n *\n * @param {Object} page\n * @return {boolean} page has height\n */\n\n\nvar hasHeight = hasPath(['style', 'height']);\n/**\n * Transform node percent height to fixed\n *\n * @param {Object} page\n * @param {Object} node\n * @return {Object} transformed node\n */\n\nvar resolveNodePercentHeight = function resolveNodePercentHeight(page) {\n  return function (node) {\n    if (hasHeight(page)) {\n      var pageArea = getPageArea(page);\n      return evolve({\n        style: {\n          height: transformHeight(pageArea)\n        }\n      })(node);\n    }\n\n    return node;\n  };\n};\n/**\n * Transform page immediate children with percent height to fixed\n *\n * @param {Object} page\n * @return {Object} transformed page\n */\n\n\nvar resolvePagePercentHeight = function resolvePagePercentHeight(page) {\n  return evolve({\n    children: map(resolveNodePercentHeight(page))\n  })(page);\n};\n/**\n * Transform all page immediate children with percent height to fixed\n *\n * @param {Object} document root\n * @return {Object} transformed document root\n */\n\n\nvar resolvePercentHeight = evolve({\n  children: map(resolvePagePercentHeight)\n});\n/**\n * Checks if node has render prop\n *\n * @param {Object} node\n * @returns {Boolean} has render prop?\n */\n\nvar hasRenderProp = hasPath(['props', 'render']);\n/**\n * Checks if all children of node are text instances\n *\n * @param {Object} node\n * @returns {Boolean} are all children text instances?\n */\n\nvar hasTextInstanceChilds = compose(all(isTextInstance), propOr([], 'children'));\n/**\n * If the Link has a string child or render prop, substitute the instance by a Text,\n * that will ultimately render the inline Link via the textkit PDF renderer.\n *\n * @param {Object} node\n * @returns {Object} node with link substitution\n */\n\nvar resolveLinkSubstitution = function resolveLinkSubstitution(node) {\n  return evolve({\n    children: map(ifElse(both(isLink, either(hasRenderProp, hasTextInstanceChilds)), assoc('type', TEXT), resolveLinkSubstitution))\n  })(node);\n};\n/**\n * Performs right-to-left function composition with async functions support\n *\n * @param  {...any} functions\n */\n\n\nvar asyncCompose = function asyncCompose() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(value) {\n      var _iterator, _isArray, _i, _ref2, fn;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _iterator = reverse(fns), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();\n\n            case 1:\n              if (!_isArray) {\n                _context.next = 7;\n                break;\n              }\n\n              if (!(_i >= _iterator.length)) {\n                _context.next = 4;\n                break;\n              }\n\n              return _context.abrupt(\"break\", 17);\n\n            case 4:\n              _ref2 = _iterator[_i++];\n              _context.next = 11;\n              break;\n\n            case 7:\n              _i = _iterator.next();\n\n              if (!_i.done) {\n                _context.next = 10;\n                break;\n              }\n\n              return _context.abrupt(\"break\", 17);\n\n            case 10:\n              _ref2 = _i.value;\n\n            case 11:\n              fn = _ref2;\n              _context.next = 14;\n              return fn(value);\n\n            case 14:\n              value = _context.sent;\n\n            case 15:\n              _context.next = 1;\n              break;\n\n            case 17:\n              return _context.abrupt(\"return\", value);\n\n            case 18:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}; // import * as R from 'ramda';\n// const endTimer = name => R.tap(() => console.timeEnd(name));\n\n\nvar layout = asyncCompose(resolveZIndex, resolveRulers, resolveOrigin, resolvePagination, resolveTextLayout, resolvePercentRadius, resolveDimensions, resolveSvg, resolveAssets, resolveInheritance, resolvePercentHeight, resolvePagePaddings$1, resolveStyles$1, resolveNoteChildren, resolveLinkSubstitution, resolvePageMargins, resolvePageSizes);\n/**\n * Checks if two sets of props are equal (recursively)\n *\n * @param {Object} props A\n * @param {Object} props B\n * @returns {Boolean} props equals?\n *\n */\n\nvar propsEqual = function propsEqual(a, b) {\n  var oldPropsKeys = Object.keys(a);\n  var newPropsKeys = Object.keys(b);\n\n  if (oldPropsKeys.length !== newPropsKeys.length) {\n    return false;\n  }\n\n  for (var i = 0; i < oldPropsKeys.length; i++) {\n    var propName = oldPropsKeys[i];\n\n    if (propName === 'render') {\n      if (!a[propName] !== !b[propName]) {\n        return false;\n      }\n\n      continue;\n    }\n\n    if (propName !== 'children' && a[propName] !== b[propName]) {\n      if (typeof a[propName] === 'object' && typeof b[propName] === 'object' && propsEqual(a[propName], b[propName])) {\n        continue;\n      }\n\n      return false;\n    }\n\n    if (propName === 'children' && (typeof a[propName] === 'string' || typeof b[propName] === 'string')) {\n      return a[propName] === b[propName];\n    }\n  }\n\n  return true;\n};\n\nvar emptyObject = {};\n\nvar createRenderer = function createRenderer(_ref) {\n  var _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange;\n  return ReactFiberReconciler({\n    schedulePassiveEffects: unstable_scheduleCallback,\n    cancelPassiveEffects: unstable_cancelCallback,\n    supportsMutation: true,\n    isPrimaryRenderer: false,\n    warnsIfNotActing: false,\n    appendInitialChild: function appendInitialChild(parentInstance, child) {\n      parentInstance.children.push(child);\n    },\n    createInstance: function createInstance(type, _ref2) {\n      var style = _ref2.style,\n          children = _ref2.children,\n          props = _objectWithoutPropertiesLoose(_ref2, [\"style\", \"children\"]);\n\n      return {\n        type: type,\n        box: {},\n        style: style || {},\n        props: props || {},\n        children: []\n      };\n    },\n    createTextInstance: function createTextInstance(text, rootContainerInstance) {\n      return {\n        type: 'TEXT_INSTANCE',\n        value: text\n      };\n    },\n    finalizeInitialChildren: function finalizeInitialChildren(element, type, props) {\n      return false;\n    },\n    getPublicInstance: function getPublicInstance(instance) {\n      return instance;\n    },\n    prepareForCommit: function prepareForCommit() {// Noop\n    },\n    prepareUpdate: function prepareUpdate(element, type, oldProps, newProps) {\n      return !propsEqual(oldProps, newProps);\n    },\n    resetAfterCommit: onChange,\n    resetTextContent: function resetTextContent(element) {// Noop\n    },\n    getRootHostContext: function getRootHostContext() {\n      return emptyObject;\n    },\n    getChildHostContext: function getChildHostContext() {\n      return emptyObject;\n    },\n    shouldSetTextContent: function shouldSetTextContent(type, props) {\n      return false;\n    },\n    now: Date.now,\n    useSyncScheduling: true,\n    appendChild: function appendChild(parentInstance, child) {\n      parentInstance.children.push(child);\n    },\n    appendChildToContainer: function appendChildToContainer(parentInstance, child) {\n      if (parentInstance.type === 'ROOT') {\n        parentInstance.document = child;\n      } else {\n        parentInstance.children.push(child);\n      }\n    },\n    insertBefore: function insertBefore(parentInstance, child, beforeChild) {\n      var index = parentInstance.children.indexOf(beforeChild);\n      if (index !== -1 && child) parentInstance.children.splice(index, 0, child);\n    },\n    removeChild: function removeChild(parentInstance, child) {\n      var index = parentInstance.children.indexOf(child);\n      if (index !== -1) parentInstance.children.splice(index, 1);\n    },\n    removeChildFromContainer: function removeChildFromContainer(parentInstance, child) {\n      var index = parentInstance.children.indexOf(child);\n      if (index !== -1) parentInstance.children.splice(index, 1);\n    },\n    commitTextUpdate: function commitTextUpdate(textInstance, oldText, newText) {\n      textInstance.value = newText;\n    },\n    commitUpdate: function commitUpdate(instance, updatePayload, type, oldProps, newProps) {\n      var style = newProps.style,\n          props = _objectWithoutPropertiesLoose(newProps, [\"style\"]);\n\n      instance.props = props;\n      instance.style = style;\n    }\n  });\n};\n\nvar create = function create(styles) {\n  return styles;\n};\n\nvar absoluteFillObject = {\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  bottom: 0,\n  right: 0\n};\nvar StyleSheet = {\n  hairlineWidth: 1,\n  create: create,\n  flatten: flatten,\n  absoluteFillObject: absoluteFillObject\n};\nvar version = \"2.0.0-beta.6\";\nvar View = VIEW;\nvar Text = TEXT;\nvar Link = LINK;\nvar Page = PAGE;\nvar Note = NOTE;\nvar Image = IMAGE;\nvar Document = DOCUMENT;\nvar Canvas = CANVAS;\nvar Svg = SVG;\nvar G = GROUP;\nvar Path = PATH;\nvar Rect = RECT;\nvar Line = LINE;\nvar Circle = CIRCLE;\nvar Ellipse = ELLIPSE;\nvar Polygon = POLYGON;\nvar Polyline = POLYLINE;\nvar Defs = DEFS;\nvar Tspan = TSPAN;\nvar ClipPath = CLIP_PATH;\nvar Stop = STOP;\nvar LinearGradient = LINEAR_GRADIENT;\nvar RadialGradient = RADIAL_GRADIENT;\n\nvar pdf = function pdf(_ref) {\n  var initialValue = _ref.initialValue,\n      onChange = _ref.onChange;\n  var container = {\n    type: 'ROOT',\n    document: null\n  };\n  var PDFRenderer = createRenderer({\n    onChange: onChange\n  });\n  var mountNode = PDFRenderer.createContainer(container);\n  if (initialValue) updateContainer(initialValue);\n\n  var render$1 = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var ctx, layout$1;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              ctx = new PDFDocument({\n                autoFirstPage: false\n              });\n              console.time('layout');\n              _context.next = 4;\n              return layout(container.document);\n\n            case 4:\n              layout$1 = _context.sent;\n              console.timeEnd('layout');\n              return _context.abrupt(\"return\", render(ctx, layout$1));\n\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function render() {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  var layout$1 = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.abrupt(\"return\", layout(container));\n\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function layout() {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n\n  function updateContainer(doc) {\n    PDFRenderer.updateContainer(doc, mountNode, null);\n  }\n\n  function callOnRender(params) {\n    if (params === void 0) {\n      params = {};\n    }\n\n    if (container.document.props.onRender) {\n      container.document.props.onRender(params);\n    }\n  }\n\n  function toBlob() {\n    return _toBlob.apply(this, arguments);\n  }\n\n  function _toBlob() {\n    _toBlob = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n      var instance, stream;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return render$1();\n\n            case 2:\n              instance = _context3.sent;\n              stream = instance.pipe(BlobStream());\n              return _context3.abrupt(\"return\", new Promise(function (resolve, reject) {\n                stream.on('finish', function () {\n                  try {\n                    var blob = stream.toBlob('application/pdf');\n                    callOnRender({\n                      blob: blob\n                    });\n                    resolve(blob);\n                  } catch (error) {\n                    reject(error);\n                  }\n                });\n                stream.on('error', reject);\n              }));\n\n            case 5:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n    return _toBlob.apply(this, arguments);\n  }\n\n  function toBuffer() {\n    return _toBuffer.apply(this, arguments);\n  }\n\n  function _toBuffer() {\n    _toBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              callOnRender();\n              return _context4.abrupt(\"return\", render$1());\n\n            case 2:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n    return _toBuffer.apply(this, arguments);\n  }\n\n  function toString() {\n    var result = '';\n    var instance = render$1();\n    return new Promise(function (resolve, reject) {\n      try {\n        instance.on('data', function (buffer) {\n          result += buffer;\n        });\n        instance.on('end', function () {\n          resolve(result);\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  return {\n    layout: layout$1,\n    container: container,\n    updateContainer: updateContainer,\n    toBuffer: toBuffer,\n    toBlob: toBlob,\n    toString: toString\n  };\n};\n\nvar svgpath = require('svgpath');\n\nvar queue = require('queue');\n\nvar canvasInstance = function canvasInstance(canvas) {\n  var instance = {};\n  var images = {};\n  var ctx = canvas.getContext('2d');\n  var fillColor = 'white';\n\n  var nil = function nil() {\n    return instance;\n  };\n\n  instance.info = {};\n  instance.end = nil;\n  instance.font = nil;\n\n  instance.translate = function (x, y) {\n    ctx.translate(x, y);\n    return instance;\n  };\n\n  instance.addPage = function (_ref) {\n    var size = _ref.size;\n    canvas.width = size[0];\n    canvas.height = size[1];\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n  };\n\n  instance.save = function () {\n    ctx.save();\n    return instance;\n  };\n\n  instance.restore = function () {\n    ctx.restore();\n    return instance;\n  };\n\n  instance.moveTo = function (x, y) {\n    ctx.moveTo(x, y);\n    return instance;\n  };\n\n  instance.lineTo = function (x, y) {\n    ctx.lineTo(x, y);\n    return instance;\n  };\n\n  instance.bezierCurveTo = function (a, b, c, d, e, f) {\n    ctx.bezierCurveTo(a, b, c, d, e, f);\n    return instance;\n  };\n\n  instance.closePath = function () {\n    ctx.closePath();\n    return instance;\n  };\n\n  instance.clip = function () {\n    ctx.clip();\n    return instance;\n  };\n\n  instance.fillColor = function (color) {\n    fillColor = color;\n    return instance;\n  };\n\n  instance.rect = function (a, b, c, d) {\n    ctx.rect(a, b, c, d);\n    return instance;\n  };\n\n  instance.fill = function () {\n    ctx.fillStyle = fillColor;\n    ctx.fill();\n    return instance;\n  };\n\n  instance.fillOpacity = function (opacity) {\n    ctx.globalAlpha = opacity;\n    return instance;\n  };\n\n  instance._addGlyphs = function (glyphs, positions) {\n    var xAdvance = 0;\n    var fontSize = 20;\n    var unitsPerEm = 2048;\n\n    for (var i = 0; i < glyphs.length; i++) {\n      var glyph = glyphs[i];\n      var position = positions[i];\n      var path = svgpath(glyph.path.toSVG()).scale(1, -1).scale(fontSize / unitsPerEm).translate(xAdvance, 0).toString();\n      xAdvance += position.xAdvance;\n      ctx.fillStyle = '#000';\n      var p = new Path2D(path);\n      ctx.stroke(p);\n      ctx.fill(p);\n    }\n\n    return instance;\n  };\n\n  instance.image = function (data, x, y, _ref2) {\n    var width = _ref2.width,\n        height = _ref2.height;\n    var base64Data = btoa(String.fromCharCode.apply(null, data));\n\n    if (images[base64Data]) {\n      ctx.drawImage(images[base64Data], x, y, width, height);\n    } else {\n      var img = document.createElement('img');\n      img.src = 'data:image/png;base64,' + base64Data;\n      images[base64Data] = img;\n\n      img.onload = function () {\n        ctx.drawImage(img, x, y, width, height);\n      };\n    }\n\n    return instance;\n  };\n\n  instance.clear = function () {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n  };\n\n  return instance;\n};\n\nvar CanvasViewer = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(CanvasViewer, _React$Component);\n\n  function CanvasViewer() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.ctx = null;\n    _this.instance = pdf();\n    _this.renderQueue = queue({\n      autostart: true,\n      concurrency: 1\n    });\n    _this.state = {\n      layout: null,\n      error: null\n    };\n\n    _this.onRenderFailed = function (error) {\n      _this.setState({\n        error: error\n      });\n\n      console.error(error);\n    };\n\n    _this.onRenderSuccessful = function (layout) {\n      _this.setState({\n        layout: layout\n      });\n    };\n\n    return _this;\n  }\n\n  var _proto = CanvasViewer.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.ctx = canvasInstance(this.canvas);\n    this.queueDocumentRender(this.props.children);\n    this.renderQueue.on('error', this.onRenderFailed);\n    this.renderQueue.on('success', this.onRenderSuccessful);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    if (prevProps.children !== this.props.children) {\n      this.queueDocumentRender(this.props.children);\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.renderQueue.end();\n  };\n\n  _proto.queueDocumentRender = function queueDocumentRender(doc) {\n    var _this2 = this;\n\n    this.renderQueue.splice(0, this.renderQueue.length, function () {\n      _this2.instance.updateContainer(doc);\n\n      if (_this2.instance.isDirty() && !_this2.state.error) {\n        return _this2.instance.renderWithContext(_this2.ctx);\n      }\n\n      return Promise.resolve();\n    });\n  };\n\n  _proto.render = function render() {\n    var _this3 = this;\n\n    return React.createElement(\"canvas\", {\n      height: 900,\n      id: \"myCanvas\",\n      ref: function ref(_ref3) {\n        return _this3.canvas = _ref3;\n      },\n      style: {\n        border: '1px solid black'\n      },\n      width: 900\n    });\n  };\n\n  return CanvasViewer;\n}(React.Component);\n\nvar queue$1 = require('queue');\n\nvar flatStyles = function flatStyles(stylesArray) {\n  return stylesArray.reduce(function (acc, style) {\n    return _extends({}, acc, style);\n  }, {});\n};\n\nvar Document$1 = function Document$1(_ref) {\n  var children = _ref.children,\n      props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n\n  return React.createElement(Document, props, children);\n};\n\nvar InternalBlobProvider = /*#__PURE__*/function (_React$PureComponent) {\n  _inheritsLoose(InternalBlobProvider, _React$PureComponent);\n\n  function InternalBlobProvider() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;\n    _this.renderQueue = queue$1({\n      autostart: true,\n      concurrency: 1\n    });\n    _this.state = {\n      blob: null,\n      url: null,\n      loading: true,\n      error: null\n    };\n\n    _this.queueDocumentRender = function () {\n      _this.renderQueue.splice(0, _this.renderQueue.length, function () {\n        return _this.state.error ? Promise.resolve() : _this.instance.toBlob();\n      });\n    };\n\n    _this.onRenderFailed = function (error) {\n      _this.setState({\n        error: error\n      });\n\n      console.error(error);\n    };\n\n    _this.onRenderSuccessful = function (blob) {\n      var oldBlobUrl = _this.state.url;\n\n      _this.setState({\n        blob: blob,\n        url: URL.createObjectURL(blob),\n        loading: false\n      }, function () {\n        return URL.revokeObjectURL(oldBlobUrl);\n      });\n    };\n\n    return _this;\n  }\n\n  var _proto = InternalBlobProvider.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.instance = pdf({\n      onChange: this.queueDocumentRender\n    });\n    this.instance.updateContainer(this.props.document);\n    this.renderQueue.on('error', this.onRenderFailed);\n    this.renderQueue.on('success', this.onRenderSuccessful);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate() {\n    this.instance.updateContainer(this.props.document);\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.renderQueue.end();\n  };\n\n  _proto.render = function render() {\n    return this.props.children(this.state);\n  };\n\n  return InternalBlobProvider;\n}(React.PureComponent);\n\nvar BlobProvider = function BlobProvider(_ref2) {\n  var doc = _ref2.document,\n      children = _ref2.children;\n\n  if (!doc) {\n    warning(false, 'You should pass a valid document to BlobProvider');\n    return null;\n  }\n\n  return React.createElement(InternalBlobProvider, {\n    document: doc\n  }, children);\n};\n\nvar PDFViewer = function PDFViewer(_ref3) {\n  var className = _ref3.className,\n      style = _ref3.style,\n      children = _ref3.children,\n      innerRef = _ref3.innerRef,\n      props = _objectWithoutPropertiesLoose(_ref3, [\"className\", \"style\", \"children\", \"innerRef\"]);\n\n  return React.createElement(InternalBlobProvider, {\n    document: children\n  }, function (_ref4) {\n    var url = _ref4.url;\n    return React.createElement(\"iframe\", _extends({\n      className: className,\n      ref: innerRef,\n      src: url,\n      style: Array.isArray(style) ? flatStyles(style) : style\n    }, props));\n  });\n};\n\nvar PDFDownloadLink = function PDFDownloadLink(_ref5) {\n  var doc = _ref5.document,\n      className = _ref5.className,\n      style = _ref5.style,\n      children = _ref5.children,\n      _ref5$fileName = _ref5.fileName,\n      fileName = _ref5$fileName === void 0 ? 'document.pdf' : _ref5$fileName;\n\n  if (!doc) {\n    warning(false, 'You should pass a valid document to PDFDownloadLink');\n    return null;\n  }\n\n  var downloadOnIE = function downloadOnIE(blob) {\n    return function () {\n      if (window.navigator.msSaveBlob) {\n        window.navigator.msSaveBlob(blob, fileName);\n      }\n    };\n  };\n\n  return React.createElement(InternalBlobProvider, {\n    document: doc\n  }, function (params) {\n    return React.createElement(\"a\", {\n      className: className,\n      download: fileName,\n      href: params.url,\n      onClick: downloadOnIE(params.blob),\n      style: Array.isArray(style) ? flatStyles(style) : style\n    }, typeof children === 'function' ? children(params) : children);\n  });\n};\n\nvar dom = {\n  pdf: pdf,\n  View: View,\n  Text: Text,\n  Link: Link,\n  Page: Page,\n  Font: Font$1,\n  Note: Note,\n  Image: Image,\n  Canvas: Canvas,\n  Svg: Svg,\n  G: G,\n  Path: Path,\n  Rect: Rect,\n  Line: Line,\n  Circle: Circle,\n  Ellipse: Ellipse,\n  Polygon: Polygon,\n  Polyline: Polyline,\n  Defs: Defs,\n  Tspan: Tspan,\n  ClipPath: ClipPath,\n  Stop: Stop,\n  LinearGradient: LinearGradient,\n  RadialGradient: RadialGradient,\n  version: version,\n  Document: Document$1,\n  PDFViewer: PDFViewer,\n  StyleSheet: StyleSheet,\n  CanvasViewer: CanvasViewer,\n  BlobProvider: BlobProvider,\n  PDFDownloadLink: PDFDownloadLink\n};\nexport default dom;\nexport { Document$1 as Document, BlobProvider, PDFViewer, PDFDownloadLink, pdf, View, Text, Link, Page, Font$1 as Font, Note, Image, Canvas, Svg, G, Path, Rect, Line, Circle, Ellipse, Polygon, Polyline, Defs, Tspan, ClipPath, Stop, LinearGradient, RadialGradient, version, StyleSheet, CanvasViewer };","map":null,"metadata":{},"sourceType":"module"}