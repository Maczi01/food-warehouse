{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar _ascent = _interopRequireDefault(require(\"../../run/ascent\"));\n\nvar _ascent2 = _interopRequireDefault(require(\"../../attributedString/ascent\"));\n\nvar _advanceWidth = _interopRequireDefault(require(\"../../run/advanceWidth\"));\n\nvar _advanceWidth2 = _interopRequireDefault(require(\"../../attributedString/advanceWidth\")); // The base font size used for calculating underline thickness.\n\n\nvar BASE_FONT_SIZE = 12;\n/**\n * Computes the intersections between an underline and the glyphs in\n * a line fragment. Returns an array of DecorationLines omitting the\n * intersections.\n */\n// const intersectWithGlyphs = (line, lineFragment) => {\n//   // Find intersection ranges between underline and glyphs\n//   let x = 0;\n//   let y = lineFragment.ascent;\n//   const ranges = [];\n//   for (const run of lineFragment.runs) {\n//     if (!run.attributes.underline) {\n//       x += run.advanceWidth;\n//       continue;\n//     }\n//     for (let i = 0; i < run.glyphs.length; i++) {\n//       const position = run.positions[i];\n//       if (x >= line.rect.x && x <= line.rect.maxX) {\n//         const gx = x + position.xOffset;\n//         const gy = y + position.yOffset;\n//         // Standard fonts may not have a path to intersect with\n//         if (run.glyphs[i].path) {\n//           const path = run.glyphs[i].path.scale(run.scale, -run.scale).translate(gx, gy);\n//           const range = findPathIntersections(path, line.rect);\n//           if (range) {\n//             ranges.push(range);\n//           }\n//         }\n//       }\n//       x += position.xAdvance;\n//       y += position.yAdvance;\n//     }\n//   }\n//   if (ranges.length === 0) {\n//     // No intersections. Return the original line.\n//     return [line];\n//   }\n//   const merged = Range.merge(ranges);\n//   // Generate underline segments omitting the intersections,\n//   // but only if the space warrents an underline.\n//   const lines = [];\n//   x = line.rect.x;\n//   for (const { start, end } of merged) {\n//     if (start - x > line.rect.height) {\n//       lines.push(line.slice(x, start));\n//     }\n//     x = end;\n//   }\n//   if (line.rect.maxX - x > line.rect.height) {\n//     lines.push(line.slice(x, line.rect.maxX));\n//   }\n//   return lines;\n// };\n// const findIntersectionPoint = (y, x1, y1, x2, y2, range) => {\n//   if ((y1 < y && y2 > y) || (y1 > y && y2 < y)) {\n//     const x = x1 + ((y - y1) * (x2 - x1)) / (y2 - y1);\n//     range.extend(x);\n//   }\n// };\n\n/**\n * Finds the intersections between a glyph path and an underline rectangle.\n * It models each contour of the path a straight line, and returns a range\n * containing the leftmost and rightmost intersection points, if any.\n */\n// const findPathIntersections = (path, rect) => {\n//   let sx = 0;\n//   let sy = 0;\n//   let cx = 0;\n//   let cy = 0;\n//   let px = 0;\n//   let py = 0;\n//   const range = new Range(Infinity, -Infinity);\n//   const y1 = rect.y;\n//   const y2 = rect.maxY;\n//   const dialation = Math.ceil(rect.height);\n//   for (const { command, args } of path.commands) {\n//     switch (command) {\n//       case 'moveTo':\n//         sx = cx = args[0];\n//         sy = cy = args[1];\n//         continue;\n//       case 'lineTo':\n//         px = args[0];\n//         py = args[1];\n//         break;\n//       case 'quadraticCurveTo':\n//         px = args[2];\n//         py = args[3];\n//         break;\n//       case 'bezierCurveTo':\n//         px = args[4];\n//         py = args[5];\n//         break;\n//       case 'closePath':\n//         px = sx;\n//         py = sy;\n//         break;\n//       default:\n//         break;\n//     }\n//     findIntersectionPoint(y1, cx, cy, px, py, range);\n//     findIntersectionPoint(y2, cx, cy, px, py, range);\n//     if ((cy >= y1 && cy <= y2) || (cy <= y1 && cy >= y2)) {\n//       range.extend(cx);\n//     }\n//     cx = px;\n//     cy = py;\n//   }\n//   if (range.start < range.end) {\n//     range.start -= dialation;\n//     range.end += dialation;\n//     return range;\n//   }\n//   return null;\n// };\n\n/**\n * A TextDecorationEngine is used by a Typesetter to generate\n * DecorationLines for a line fragment, including underlines\n * and strikes.\n */\n\nvar textDecoration = function textDecoration() {\n  return function (lineFragment) {\n    var x = R.propOr(0, 'overflowLeft', lineFragment);\n    var overflowRight = R.propOr(0, 'overflowRight', lineFragment);\n    var maxX = (0, _advanceWidth2[\"default\"])(lineFragment) - overflowRight;\n    lineFragment.decorationLines = [];\n\n    for (var _iterator = lineFragment.runs, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var run = _ref;\n      var width = Math.min(maxX - x, (0, _advanceWidth[\"default\"])(run));\n      var thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));\n\n      if (run.attributes.underline) {\n        var rect = {\n          x: x,\n          y: (0, _ascent2[\"default\"])(lineFragment) + thickness * 2,\n          width: width,\n          height: thickness\n        };\n        var line = {\n          rect: rect,\n          opacity: run.attributes.opacity,\n          color: run.attributes.underlineColor || 'black',\n          style: run.attributes.underlineStyle || 'solid'\n        };\n        lineFragment.decorationLines.push(line);\n      }\n\n      if (run.attributes.strike) {\n        var y = (0, _ascent2[\"default\"])(lineFragment) - (0, _ascent[\"default\"])(run) / 3;\n        var _rect = {\n          x: x,\n          y: y,\n          width: width,\n          height: thickness\n        };\n        var _line = {\n          rect: _rect,\n          opacity: run.attributes.opacity,\n          color: run.attributes.strikeColor || 'black',\n          style: run.attributes.strikeStyle || 'solid'\n        };\n        lineFragment.decorationLines.push(_line);\n      }\n\n      x += width;\n    } // Adjust underline y positions, and intersect with glyph descenders.\n    // for (const line of underlines) {\n    //   lineFragment.decorationLines.push(...intersectWithGlyphs(line, lineFragment));\n    // }\n\n\n    return lineFragment;\n  };\n};\n\nvar _default = textDecoration;\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}