{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nvar w = \"production\" !== process.env.NODE_ENV ? function (a) {\n  return Object.freeze(a);\n} : function (a) {\n  return a;\n};\n\nfunction x(a, f) {\n  if (!a) {\n    \"undefined\" !== typeof console && console.warn(f);\n\n    try {\n      throw Error(f);\n    } catch (h) {}\n  }\n}\n\nfunction y(a) {\n  a.preventDefault();\n  a.returnValue = \"\";\n}\n\nfunction z() {\n  var a = [];\n  return {\n    get length() {\n      return a.length;\n    },\n\n    push: function push(f) {\n      a.push(f);\n      return function () {\n        a = a.filter(function (a) {\n          return a !== f;\n        });\n      };\n    },\n    call: function call(f) {\n      a.forEach(function (a) {\n        return a && a(f);\n      });\n    }\n  };\n}\n\nfunction A() {\n  return Math.random().toString(36).substr(2, 8);\n}\n\nfunction C(a) {\n  var f = a.pathname,\n      h = a.search;\n  a = a.hash;\n  return (void 0 === f ? \"/\" : f) + (void 0 === h ? \"\" : h) + (void 0 === a ? \"\" : a);\n}\n\nfunction D(a) {\n  var f = {};\n\n  if (a) {\n    var h = a.indexOf(\"#\");\n    0 <= h && (f.hash = a.substr(h), a = a.substr(0, h));\n    h = a.indexOf(\"?\");\n    0 <= h && (f.search = a.substr(h), a = a.substr(0, h));\n    a && (f.pathname = a);\n  }\n\n  return f;\n}\n\nvar createBrowserHistory = function createBrowserHistory(a) {\n  function f() {\n    var a = k.location,\n        e = g.state || {};\n    return [e.idx, w({\n      pathname: a.pathname,\n      search: a.search,\n      hash: a.hash,\n      state: e.usr || null,\n      key: e.key || \"default\"\n    })];\n  }\n\n  function h(a) {\n    return \"string\" === typeof a ? a : C(a);\n  }\n\n  function r(a, e) {\n    void 0 === e && (e = null);\n    return w(_extends({}, m, {}, \"string\" === typeof a ? D(a) : a, {\n      state: e,\n      key: A()\n    }));\n  }\n\n  function u(a) {\n    n = a;\n    a = f();\n    p = a[0];\n    m = a[1];\n    c.call({\n      action: n,\n      location: m\n    });\n  }\n\n  function v(a, e) {\n    function c() {\n      v(a, e);\n    }\n\n    var B = r(a, e);\n\n    if (!b.length || (b.call({\n      action: \"PUSH\",\n      location: B,\n      retry: c\n    }), !1)) {\n      var d = [{\n        usr: B.state,\n        key: B.key,\n        idx: p + 1\n      }, h(B)];\n      B = d[0];\n      d = d[1];\n\n      try {\n        g.pushState(B, null, d);\n      } catch (E) {\n        k.location.assign(d);\n      }\n\n      u(\"PUSH\");\n    }\n  }\n\n  function t(a, e) {\n    function c() {\n      t(a, e);\n    }\n\n    var d = r(a, e);\n    b.length && (b.call({\n      action: \"REPLACE\",\n      location: d,\n      retry: c\n    }), 1) || (d = [{\n      usr: d.state,\n      key: d.key,\n      idx: p\n    }, h(d)], g.replaceState(d[0], null, d[1]), u(\"REPLACE\"));\n  }\n\n  function l(a) {\n    g.go(a);\n  }\n\n  a = (void 0 === a ? {} : a).window;\n  var k = void 0 === a ? document.defaultView : a,\n      g = k.history,\n      q = null;\n  k.addEventListener(\"popstate\", function () {\n    if (q) b.call(q), q = null;else {\n      var a = f(),\n          e = a[0];\n      a = a[1];\n      if (b.length) {\n        if (null != e) {\n          var c = p - e;\n          c && (q = {\n            action: \"POP\",\n            location: a,\n            retry: function retry() {\n              l(-1 * c);\n            }\n          }, l(c));\n        } else \"production\" !== process.env.NODE_ENV ? x(!1, \"You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation.\") : void 0;\n      } else u(\"POP\");\n    }\n  });\n  var n = \"POP\";\n  a = f();\n  var p = a[0],\n      m = a[1],\n      b = z(),\n      c = z();\n  null == p && (p = 0, g.replaceState(_extends({}, g.state, {\n    idx: p\n  }), null));\n  return {\n    get action() {\n      return n;\n    },\n\n    get location() {\n      return m;\n    },\n\n    createHref: h,\n    push: v,\n    replace: t,\n    go: l,\n    back: function back() {\n      l(-1);\n    },\n    forward: function forward() {\n      l(1);\n    },\n    listen: function listen(a) {\n      return c.push(a);\n    },\n    block: function block(a) {\n      var e = b.push(a);\n      1 === b.length && k.addEventListener(\"beforeunload\", y);\n      return function () {\n        e();\n        b.length || k.removeEventListener(\"beforeunload\", y);\n      };\n    }\n  };\n};\n\nvar createHashHistory = function createHashHistory(a) {\n  function f() {\n    var a = D(g.location.hash.substr(1)),\n        b = a.pathname,\n        c = a.search;\n    a = a.hash;\n    var d = q.state || {};\n    return [d.idx, w({\n      pathname: void 0 === b ? \"/\" : b,\n      search: void 0 === c ? \"\" : c,\n      hash: void 0 === a ? \"\" : a,\n      state: d.usr || null,\n      key: d.key || \"default\"\n    })];\n  }\n\n  function h() {\n    if (n) c.call(n), n = null;else {\n      var a = f(),\n          b = a[0];\n      a = a[1];\n      if (c.length) {\n        if (null != b) {\n          var d = m - b;\n          d && (n = {\n            action: \"POP\",\n            location: a,\n            retry: function retry() {\n              k(-1 * d);\n            }\n          }, k(d));\n        } else \"production\" !== process.env.NODE_ENV ? x(!1, \"You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation.\") : void 0;\n      } else v(\"POP\");\n    }\n  }\n\n  function r(a) {\n    var b = document.querySelector(\"base\"),\n        e = \"\";\n    b && b.getAttribute(\"href\") && (b = g.location.href, e = b.indexOf(\"#\"), e = -1 === e ? b : b.slice(0, e));\n    return e + \"#\" + (\"string\" === typeof a ? a : C(a));\n  }\n\n  function u(a, c) {\n    void 0 === c && (c = null);\n    return w(_extends({}, b, {}, \"string\" === typeof a ? D(a) : a, {\n      state: c,\n      key: A()\n    }));\n  }\n\n  function v(a) {\n    p = a;\n    a = f();\n    m = a[0];\n    b = a[1];\n    d.call({\n      action: p,\n      location: b\n    });\n  }\n\n  function t(a, b) {\n    function d() {\n      t(a, b);\n    }\n\n    var e = u(a, b);\n    \"production\" !== process.env.NODE_ENV ? x(\"/\" === e.pathname.charAt(0), \"Relative pathnames are not supported in hash history.push(\" + JSON.stringify(a) + \")\") : void 0;\n\n    if (!c.length || (c.call({\n      action: \"PUSH\",\n      location: e,\n      retry: d\n    }), !1)) {\n      var f = [{\n        usr: e.state,\n        key: e.key,\n        idx: m + 1\n      }, r(e)];\n      e = f[0];\n      f = f[1];\n\n      try {\n        q.pushState(e, null, f);\n      } catch (F) {\n        g.location.assign(f);\n      }\n\n      v(\"PUSH\");\n    }\n  }\n\n  function l(a, b) {\n    function e() {\n      l(a, b);\n    }\n\n    var d = u(a, b);\n    \"production\" !== process.env.NODE_ENV ? x(\"/\" === d.pathname.charAt(0), \"Relative pathnames are not supported in hash history.replace(\" + JSON.stringify(a) + \")\") : void 0;\n    c.length && (c.call({\n      action: \"REPLACE\",\n      location: d,\n      retry: e\n    }), 1) || (d = [{\n      usr: d.state,\n      key: d.key,\n      idx: m\n    }, r(d)], q.replaceState(d[0], null, d[1]), v(\"REPLACE\"));\n  }\n\n  function k(a) {\n    q.go(a);\n  }\n\n  a = (void 0 === a ? {} : a).window;\n  var g = void 0 === a ? document.defaultView : a,\n      q = g.history,\n      n = null;\n  g.addEventListener(\"popstate\", h);\n  g.addEventListener(\"hashchange\", function () {\n    var a = f()[1];\n    C(a) !== C(b) && h();\n  });\n  var p = \"POP\";\n  a = f();\n  var m = a[0],\n      b = a[1],\n      c = z(),\n      d = z();\n  null == m && (m = 0, q.replaceState(_extends({}, q.state, {\n    idx: m\n  }), null));\n  return {\n    get action() {\n      return p;\n    },\n\n    get location() {\n      return b;\n    },\n\n    createHref: r,\n    push: t,\n    replace: l,\n    go: k,\n    back: function back() {\n      k(-1);\n    },\n    forward: function forward() {\n      k(1);\n    },\n    listen: function listen(a) {\n      return d.push(a);\n    },\n    block: function block(a) {\n      var b = c.push(a);\n      1 === c.length && g.addEventListener(\"beforeunload\", y);\n      return function () {\n        b();\n        c.length || g.removeEventListener(\"beforeunload\", y);\n      };\n    }\n  };\n};\n\nvar createMemoryHistory = function createMemoryHistory(a) {\n  function f(a, c) {\n    void 0 === c && (c = null);\n    return w(_extends({}, n, {}, \"string\" === typeof a ? D(a) : a, {\n      state: c,\n      key: A()\n    }));\n  }\n\n  function h(a, c, d) {\n    return !p.length || (p.call({\n      action: a,\n      location: c,\n      retry: d\n    }), !1);\n  }\n\n  function r(a, c) {\n    q = a;\n    n = c;\n    m.call({\n      action: q,\n      location: n\n    });\n  }\n\n  function u(a, c) {\n    var b = f(a, c);\n    \"production\" !== process.env.NODE_ENV ? x(\"/\" === n.pathname.charAt(0), \"Relative pathnames are not supported in memory history.push(\" + JSON.stringify(a) + \")\") : void 0;\n    h(\"PUSH\", b, function () {\n      u(a, c);\n    }) && (g += 1, k.splice(g, k.length, b), r(\"PUSH\", b));\n  }\n\n  function v(a, c) {\n    var b = f(a, c);\n    \"production\" !== process.env.NODE_ENV ? x(\"/\" === n.pathname.charAt(0), \"Relative pathnames are not supported in memory history.replace(\" + JSON.stringify(a) + \")\") : void 0;\n    h(\"REPLACE\", b, function () {\n      v(a, c);\n    }) && (k[g] = b, r(\"REPLACE\", b));\n  }\n\n  function t(a) {\n    var b = Math.min(Math.max(g + a, 0), k.length - 1),\n        d = k[b];\n    h(\"POP\", d, function () {\n      t(a);\n    }) && (g = b, r(\"POP\", d));\n  }\n\n  var l = void 0 === a ? {} : a;\n  a = l.initialEntries;\n  l = l.initialIndex;\n  l = void 0 === l ? 0 : l;\n  var k = (void 0 === a ? [\"/\"] : a).map(function (a) {\n    var b = w(_extends({\n      pathname: \"/\",\n      search: \"\",\n      hash: \"\",\n      state: null,\n      key: A()\n    }, \"string\" === typeof a ? D(a) : a));\n    \"production\" !== process.env.NODE_ENV ? x(\"/\" === b.pathname.charAt(0), \"Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: \" + JSON.stringify(a) + \")\") : void 0;\n    return b;\n  }),\n      g = Math.min(Math.max(l, 0), k.length - 1),\n      q = \"POP\",\n      n = k[g],\n      p = z(),\n      m = z();\n  return {\n    get index() {\n      return g;\n    },\n\n    get action() {\n      return q;\n    },\n\n    get location() {\n      return n;\n    },\n\n    createHref: function createHref(a) {\n      return \"string\" === typeof a ? a : C(a);\n    },\n    push: u,\n    replace: v,\n    go: t,\n    back: function back() {\n      t(-1);\n    },\n    forward: function forward() {\n      t(1);\n    },\n    listen: function listen(a) {\n      return m.push(a);\n    },\n    block: function block(a) {\n      return p.push(a);\n    }\n  };\n};\n\nvar createPath = C;\nvar parsePath = D;\nexport { createBrowserHistory, createHashHistory, createMemoryHistory, createPath, parsePath };","map":null,"metadata":{},"sourceType":"module"}