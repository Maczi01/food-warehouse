{"ast":null,"code":"var _classCallCheck = require(\"C:\\\\Users\\\\Admin\\\\Desktop\\\\react1\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Admin\\\\Desktop\\\\react1\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\n// Generated by CoffeeScript 2.4.1\n(function () {\n  var NodeType,\n      WriterState,\n      XMLCData,\n      XMLComment,\n      XMLDTDAttList,\n      XMLDTDElement,\n      XMLDTDEntity,\n      XMLDTDNotation,\n      XMLDeclaration,\n      XMLDocType,\n      XMLDummy,\n      XMLElement,\n      XMLProcessingInstruction,\n      XMLRaw,\n      XMLText,\n      XMLWriterBase,\n      assign,\n      hasProp = {}.hasOwnProperty;\n\n  var _require = require('./Utility');\n\n  assign = _require.assign;\n  NodeType = require('./NodeType');\n  XMLDeclaration = require('./XMLDeclaration');\n  XMLDocType = require('./XMLDocType');\n  XMLCData = require('./XMLCData');\n  XMLComment = require('./XMLComment');\n  XMLElement = require('./XMLElement');\n  XMLRaw = require('./XMLRaw');\n  XMLText = require('./XMLText');\n  XMLProcessingInstruction = require('./XMLProcessingInstruction');\n  XMLDummy = require('./XMLDummy');\n  XMLDTDAttList = require('./XMLDTDAttList');\n  XMLDTDElement = require('./XMLDTDElement');\n  XMLDTDEntity = require('./XMLDTDEntity');\n  XMLDTDNotation = require('./XMLDTDNotation');\n  WriterState = require('./WriterState'); // Base class for XML writers\n\n  module.exports = XMLWriterBase = /*#__PURE__*/function () {\n    \"use strict\";\n\n    // Initializes a new instance of `XMLWriterBase`\n    // `options.pretty` pretty prints the result\n    // `options.indent` indentation string\n    // `options.newline` newline sequence\n    // `options.offset` a fixed number of indentations to add to every line\n    // `options.width` maximum column width\n    // `options.allowEmpty` do not self close empty element tags\n    // 'options.dontPrettyTextNodes' if any text is present in node, don't indent or LF\n    // `options.spaceBeforeSlash` add a space before the closing slash of empty elements\n    function XMLWriterBase(options) {\n      _classCallCheck(this, XMLWriterBase);\n\n      var key, ref, value;\n      options || (options = {});\n      this.options = options;\n      ref = options.writer || {};\n\n      for (key in ref) {\n        if (!hasProp.call(ref, key)) continue;\n        value = ref[key];\n        this[\"_\" + key] = this[key];\n        this[key] = value;\n      }\n    } // Filters writer options and provides defaults\n    // `options` writer options\n\n\n    _createClass(XMLWriterBase, [{\n      key: \"filterOptions\",\n      value: function filterOptions(options) {\n        var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7;\n        options || (options = {});\n        options = assign({}, this.options, options);\n        filteredOptions = {\n          writer: this\n        };\n        filteredOptions.pretty = options.pretty || false;\n        filteredOptions.allowEmpty = options.allowEmpty || false;\n        filteredOptions.indent = (ref = options.indent) != null ? ref : '  ';\n        filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : '\\n';\n        filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;\n        filteredOptions.width = (ref3 = options.width) != null ? ref3 : 0;\n        filteredOptions.dontPrettyTextNodes = (ref4 = (ref5 = options.dontPrettyTextNodes) != null ? ref5 : options.dontprettytextnodes) != null ? ref4 : 0;\n        filteredOptions.spaceBeforeSlash = (ref6 = (ref7 = options.spaceBeforeSlash) != null ? ref7 : options.spacebeforeslash) != null ? ref6 : '';\n\n        if (filteredOptions.spaceBeforeSlash === true) {\n          filteredOptions.spaceBeforeSlash = ' ';\n        }\n\n        filteredOptions.suppressPrettyCount = 0;\n        filteredOptions.user = {};\n        filteredOptions.state = WriterState.None;\n        return filteredOptions;\n      } // Returns the indentation string for the current level\n      // `node` current node\n      // `options` writer options\n      // `level` current indentation level\n\n    }, {\n      key: \"indent\",\n      value: function indent(node, options, level) {\n        var indentLevel;\n\n        if (!options.pretty || options.suppressPrettyCount) {\n          return '';\n        } else if (options.pretty) {\n          indentLevel = (level || 0) + options.offset + 1;\n\n          if (indentLevel > 0) {\n            return new Array(indentLevel).join(options.indent);\n          }\n        }\n\n        return '';\n      } // Returns the newline string\n      // `node` current node\n      // `options` writer options\n      // `level` current indentation level\n\n    }, {\n      key: \"endline\",\n      value: function endline(node, options, level) {\n        if (!options.pretty || options.suppressPrettyCount) {\n          return '';\n        } else {\n          return options.newline;\n        }\n      }\n    }, {\n      key: \"attribute\",\n      value: function attribute(att, options, level) {\n        var r;\n        this.openAttribute(att, options, level);\n\n        if (options.pretty && options.width > 0) {\n          r = att.name + '=\"' + att.value + '\"';\n        } else {\n          r = ' ' + att.name + '=\"' + att.value + '\"';\n        }\n\n        this.closeAttribute(att, options, level);\n        return r;\n      }\n    }, {\n      key: \"cdata\",\n      value: function cdata(node, options, level) {\n        var r;\n        this.openNode(node, options, level);\n        options.state = WriterState.OpenTag;\n        r = this.indent(node, options, level) + '<![CDATA[';\n        options.state = WriterState.InsideTag;\n        r += node.value;\n        options.state = WriterState.CloseTag;\n        r += ']]>' + this.endline(node, options, level);\n        options.state = WriterState.None;\n        this.closeNode(node, options, level);\n        return r;\n      }\n    }, {\n      key: \"comment\",\n      value: function comment(node, options, level) {\n        var r;\n        this.openNode(node, options, level);\n        options.state = WriterState.OpenTag;\n        r = this.indent(node, options, level) + '<!-- ';\n        options.state = WriterState.InsideTag;\n        r += node.value;\n        options.state = WriterState.CloseTag;\n        r += ' -->' + this.endline(node, options, level);\n        options.state = WriterState.None;\n        this.closeNode(node, options, level);\n        return r;\n      }\n    }, {\n      key: \"declaration\",\n      value: function declaration(node, options, level) {\n        var r;\n        this.openNode(node, options, level);\n        options.state = WriterState.OpenTag;\n        r = this.indent(node, options, level) + '<?xml';\n        options.state = WriterState.InsideTag;\n        r += ' version=\"' + node.version + '\"';\n\n        if (node.encoding != null) {\n          r += ' encoding=\"' + node.encoding + '\"';\n        }\n\n        if (node.standalone != null) {\n          r += ' standalone=\"' + node.standalone + '\"';\n        }\n\n        options.state = WriterState.CloseTag;\n        r += options.spaceBeforeSlash + '?>';\n        r += this.endline(node, options, level);\n        options.state = WriterState.None;\n        this.closeNode(node, options, level);\n        return r;\n      }\n    }, {\n      key: \"docType\",\n      value: function docType(node, options, level) {\n        var child, i, len1, r, ref;\n        level || (level = 0);\n        this.openNode(node, options, level);\n        options.state = WriterState.OpenTag;\n        r = this.indent(node, options, level);\n        r += '<!DOCTYPE ' + node.root().name; // external identifier\n\n        if (node.pubID && node.sysID) {\n          r += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n        } else if (node.sysID) {\n          r += ' SYSTEM \"' + node.sysID + '\"';\n        } // internal subset\n\n\n        if (node.children.length > 0) {\n          r += ' [';\n          r += this.endline(node, options, level);\n          options.state = WriterState.InsideTag;\n          ref = node.children;\n\n          for (i = 0, len1 = ref.length; i < len1; i++) {\n            child = ref[i];\n            r += this.writeChildNode(child, options, level + 1);\n          }\n\n          options.state = WriterState.CloseTag;\n          r += ']';\n        } // close tag\n\n\n        options.state = WriterState.CloseTag;\n        r += options.spaceBeforeSlash + '>';\n        r += this.endline(node, options, level);\n        options.state = WriterState.None;\n        this.closeNode(node, options, level);\n        return r;\n      }\n    }, {\n      key: \"element\",\n      value: function element(node, options, level) {\n        var att, attLen, child, childNodeCount, firstChildNode, i, j, len, len1, len2, name, prettySuppressed, r, ratt, ref, ref1, ref2, ref3, rline;\n        level || (level = 0);\n        prettySuppressed = false; // open tag\n\n        this.openNode(node, options, level);\n        options.state = WriterState.OpenTag;\n        r = this.indent(node, options, level) + '<' + node.name; // attributes\n\n        if (options.pretty && options.width > 0) {\n          len = r.length;\n          ref = node.attribs;\n\n          for (name in ref) {\n            if (!hasProp.call(ref, name)) continue;\n            att = ref[name];\n            ratt = this.attribute(att, options, level);\n            attLen = ratt.length;\n\n            if (len + attLen > options.width) {\n              rline = this.indent(node, options, level + 1) + ratt;\n              r += this.endline(node, options, level) + rline;\n              len = rline.length;\n            } else {\n              rline = ' ' + ratt;\n              r += rline;\n              len += rline.length;\n            }\n          }\n        } else {\n          ref1 = node.attribs;\n\n          for (name in ref1) {\n            if (!hasProp.call(ref1, name)) continue;\n            att = ref1[name];\n            r += this.attribute(att, options, level);\n          }\n        }\n\n        childNodeCount = node.children.length;\n        firstChildNode = childNodeCount === 0 ? null : node.children[0];\n\n        if (childNodeCount === 0 || node.children.every(function (e) {\n          return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === '';\n        })) {\n          // empty element\n          if (options.allowEmpty) {\n            r += '>';\n            options.state = WriterState.CloseTag;\n            r += '</' + node.name + '>' + this.endline(node, options, level);\n          } else {\n            options.state = WriterState.CloseTag;\n            r += options.spaceBeforeSlash + '/>' + this.endline(node, options, level);\n          }\n        } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {\n          // do not indent text-only nodes\n          r += '>';\n          options.state = WriterState.InsideTag;\n          options.suppressPrettyCount++;\n          prettySuppressed = true;\n          r += this.writeChildNode(firstChildNode, options, level + 1);\n          options.suppressPrettyCount--;\n          prettySuppressed = false;\n          options.state = WriterState.CloseTag;\n          r += '</' + node.name + '>' + this.endline(node, options, level);\n        } else {\n          // if ANY are a text node, then suppress pretty now\n          if (options.dontPrettyTextNodes) {\n            ref2 = node.children;\n\n            for (i = 0, len1 = ref2.length; i < len1; i++) {\n              child = ref2[i];\n\n              if ((child.type === NodeType.Text || child.type === NodeType.Raw) && child.value != null) {\n                options.suppressPrettyCount++;\n                prettySuppressed = true;\n                break;\n              }\n            }\n          } // close the opening tag, after dealing with newline\n\n\n          r += '>' + this.endline(node, options, level);\n          options.state = WriterState.InsideTag;\n          ref3 = node.children; // inner tags\n\n          for (j = 0, len2 = ref3.length; j < len2; j++) {\n            child = ref3[j];\n            r += this.writeChildNode(child, options, level + 1);\n          } // close tag\n\n\n          options.state = WriterState.CloseTag;\n          r += this.indent(node, options, level) + '</' + node.name + '>';\n\n          if (prettySuppressed) {\n            options.suppressPrettyCount--;\n          }\n\n          r += this.endline(node, options, level);\n          options.state = WriterState.None;\n        }\n\n        this.closeNode(node, options, level);\n        return r;\n      }\n    }, {\n      key: \"writeChildNode\",\n      value: function writeChildNode(node, options, level) {\n        switch (node.type) {\n          case NodeType.CData:\n            return this.cdata(node, options, level);\n\n          case NodeType.Comment:\n            return this.comment(node, options, level);\n\n          case NodeType.Element:\n            return this.element(node, options, level);\n\n          case NodeType.Raw:\n            return this.raw(node, options, level);\n\n          case NodeType.Text:\n            return this.text(node, options, level);\n\n          case NodeType.ProcessingInstruction:\n            return this.processingInstruction(node, options, level);\n\n          case NodeType.Dummy:\n            return '';\n\n          case NodeType.Declaration:\n            return this.declaration(node, options, level);\n\n          case NodeType.DocType:\n            return this.docType(node, options, level);\n\n          case NodeType.AttributeDeclaration:\n            return this.dtdAttList(node, options, level);\n\n          case NodeType.ElementDeclaration:\n            return this.dtdElement(node, options, level);\n\n          case NodeType.EntityDeclaration:\n            return this.dtdEntity(node, options, level);\n\n          case NodeType.NotationDeclaration:\n            return this.dtdNotation(node, options, level);\n\n          default:\n            throw new Error(\"Unknown XML node type: \" + node.constructor.name);\n        }\n      }\n    }, {\n      key: \"processingInstruction\",\n      value: function processingInstruction(node, options, level) {\n        var r;\n        this.openNode(node, options, level);\n        options.state = WriterState.OpenTag;\n        r = this.indent(node, options, level) + '<?';\n        options.state = WriterState.InsideTag;\n        r += node.target;\n\n        if (node.value) {\n          r += ' ' + node.value;\n        }\n\n        options.state = WriterState.CloseTag;\n        r += options.spaceBeforeSlash + '?>';\n        r += this.endline(node, options, level);\n        options.state = WriterState.None;\n        this.closeNode(node, options, level);\n        return r;\n      }\n    }, {\n      key: \"raw\",\n      value: function raw(node, options, level) {\n        var r;\n        this.openNode(node, options, level);\n        options.state = WriterState.OpenTag;\n        r = this.indent(node, options, level);\n        options.state = WriterState.InsideTag;\n        r += node.value;\n        options.state = WriterState.CloseTag;\n        r += this.endline(node, options, level);\n        options.state = WriterState.None;\n        this.closeNode(node, options, level);\n        return r;\n      }\n    }, {\n      key: \"text\",\n      value: function text(node, options, level) {\n        var r;\n        this.openNode(node, options, level);\n        options.state = WriterState.OpenTag;\n        r = this.indent(node, options, level);\n        options.state = WriterState.InsideTag;\n        r += node.value;\n        options.state = WriterState.CloseTag;\n        r += this.endline(node, options, level);\n        options.state = WriterState.None;\n        this.closeNode(node, options, level);\n        return r;\n      }\n    }, {\n      key: \"dtdAttList\",\n      value: function dtdAttList(node, options, level) {\n        var r;\n        this.openNode(node, options, level);\n        options.state = WriterState.OpenTag;\n        r = this.indent(node, options, level) + '<!ATTLIST';\n        options.state = WriterState.InsideTag;\n        r += ' ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType;\n\n        if (node.defaultValueType !== '#DEFAULT') {\n          r += ' ' + node.defaultValueType;\n        }\n\n        if (node.defaultValue) {\n          r += ' \"' + node.defaultValue + '\"';\n        }\n\n        options.state = WriterState.CloseTag;\n        r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);\n        options.state = WriterState.None;\n        this.closeNode(node, options, level);\n        return r;\n      }\n    }, {\n      key: \"dtdElement\",\n      value: function dtdElement(node, options, level) {\n        var r;\n        this.openNode(node, options, level);\n        options.state = WriterState.OpenTag;\n        r = this.indent(node, options, level) + '<!ELEMENT';\n        options.state = WriterState.InsideTag;\n        r += ' ' + node.name + ' ' + node.value;\n        options.state = WriterState.CloseTag;\n        r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);\n        options.state = WriterState.None;\n        this.closeNode(node, options, level);\n        return r;\n      }\n    }, {\n      key: \"dtdEntity\",\n      value: function dtdEntity(node, options, level) {\n        var r;\n        this.openNode(node, options, level);\n        options.state = WriterState.OpenTag;\n        r = this.indent(node, options, level) + '<!ENTITY';\n        options.state = WriterState.InsideTag;\n\n        if (node.pe) {\n          r += ' %';\n        }\n\n        r += ' ' + node.name;\n\n        if (node.value) {\n          r += ' \"' + node.value + '\"';\n        } else {\n          if (node.pubID && node.sysID) {\n            r += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n          } else if (node.sysID) {\n            r += ' SYSTEM \"' + node.sysID + '\"';\n          }\n\n          if (node.nData) {\n            r += ' NDATA ' + node.nData;\n          }\n        }\n\n        options.state = WriterState.CloseTag;\n        r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);\n        options.state = WriterState.None;\n        this.closeNode(node, options, level);\n        return r;\n      }\n    }, {\n      key: \"dtdNotation\",\n      value: function dtdNotation(node, options, level) {\n        var r;\n        this.openNode(node, options, level);\n        options.state = WriterState.OpenTag;\n        r = this.indent(node, options, level) + '<!NOTATION';\n        options.state = WriterState.InsideTag;\n        r += ' ' + node.name;\n\n        if (node.pubID && node.sysID) {\n          r += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n        } else if (node.pubID) {\n          r += ' PUBLIC \"' + node.pubID + '\"';\n        } else if (node.sysID) {\n          r += ' SYSTEM \"' + node.sysID + '\"';\n        }\n\n        options.state = WriterState.CloseTag;\n        r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);\n        options.state = WriterState.None;\n        this.closeNode(node, options, level);\n        return r;\n      }\n    }, {\n      key: \"openNode\",\n      value: function openNode(node, options, level) {}\n    }, {\n      key: \"closeNode\",\n      value: function closeNode(node, options, level) {}\n    }, {\n      key: \"openAttribute\",\n      value: function openAttribute(att, options, level) {}\n    }, {\n      key: \"closeAttribute\",\n      value: function closeAttribute(att, options, level) {}\n    }]);\n\n    return XMLWriterBase;\n  }();\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}