{"ast":null,"code":"// Generated by CoffeeScript 1.7.1\n(function () {\n  var DecodeStream,\n      Fixed,\n      NumberT,\n      __hasProp = {}.hasOwnProperty,\n      __extends = function __extends(child, parent) {\n    for (var key in parent) {\n      if (__hasProp.call(parent, key)) child[key] = parent[key];\n    }\n\n    function ctor() {\n      this.constructor = child;\n    }\n\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n    child.__super__ = parent.prototype;\n    return child;\n  };\n\n  DecodeStream = require('./DecodeStream');\n\n  NumberT = function () {\n    function NumberT(type, endian) {\n      this.type = type;\n      this.endian = endian != null ? endian : 'BE';\n      this.fn = this.type;\n\n      if (this.type[this.type.length - 1] !== '8') {\n        this.fn += this.endian;\n      }\n    }\n\n    NumberT.prototype.size = function () {\n      return DecodeStream.TYPES[this.type];\n    };\n\n    NumberT.prototype.decode = function (stream) {\n      return stream['read' + this.fn]();\n    };\n\n    NumberT.prototype.encode = function (stream, val) {\n      return stream['write' + this.fn](val);\n    };\n\n    return NumberT;\n  }();\n\n  exports.Number = NumberT;\n  exports.uint8 = new NumberT('UInt8');\n  exports.uint16be = exports.uint16 = new NumberT('UInt16', 'BE');\n  exports.uint16le = new NumberT('UInt16', 'LE');\n  exports.uint24be = exports.uint24 = new NumberT('UInt24', 'BE');\n  exports.uint24le = new NumberT('UInt24', 'LE');\n  exports.uint32be = exports.uint32 = new NumberT('UInt32', 'BE');\n  exports.uint32le = new NumberT('UInt32', 'LE');\n  exports.int8 = new NumberT('Int8');\n  exports.int16be = exports.int16 = new NumberT('Int16', 'BE');\n  exports.int16le = new NumberT('Int16', 'LE');\n  exports.int24be = exports.int24 = new NumberT('Int24', 'BE');\n  exports.int24le = new NumberT('Int24', 'LE');\n  exports.int32be = exports.int32 = new NumberT('Int32', 'BE');\n  exports.int32le = new NumberT('Int32', 'LE');\n  exports.floatbe = exports.float = new NumberT('Float', 'BE');\n  exports.floatle = new NumberT('Float', 'LE');\n  exports.doublebe = exports.double = new NumberT('Double', 'BE');\n  exports.doublele = new NumberT('Double', 'LE');\n\n  Fixed = function (_super) {\n    __extends(Fixed, _super);\n\n    function Fixed(size, endian, fracBits) {\n      if (fracBits == null) {\n        fracBits = size >> 1;\n      }\n\n      Fixed.__super__.constructor.call(this, \"Int\" + size, endian);\n\n      this._point = 1 << fracBits;\n    }\n\n    Fixed.prototype.decode = function (stream) {\n      return Fixed.__super__.decode.call(this, stream) / this._point;\n    };\n\n    Fixed.prototype.encode = function (stream, val) {\n      return Fixed.__super__.encode.call(this, stream, val * this._point | 0);\n    };\n\n    return Fixed;\n  }(NumberT);\n\n  exports.Fixed = Fixed;\n  exports.fixed16be = exports.fixed16 = new Fixed(16, 'BE');\n  exports.fixed16le = new Fixed(16, 'LE');\n  exports.fixed32be = exports.fixed32 = new Fixed(32, 'BE');\n  exports.fixed32le = new Fixed(32, 'LE');\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}