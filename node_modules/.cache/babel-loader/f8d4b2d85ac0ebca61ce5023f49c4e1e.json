{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar axios = require('axios');\n\nvar fs = require('fs');\n\nvar http = require('http');\n\nvar https = require('https');\n\nvar Q = require('q');\n\nvar qs = require('qs');\n\nvar Response = require('../http/response');\n\nvar Request = require('../http/request');\n\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';\n\nvar RequestClient = function RequestClient() {};\n/**\n * Make http request\n * @param {object} opts - The options argument\n * @param {string} opts.method - The http method\n * @param {string} opts.uri - The request uri\n * @param {string} [opts.username] - The username used for auth\n * @param {string} [opts.password] - The password used for auth\n * @param {object} [opts.headers] - The request headers\n * @param {object} [opts.params] - The request params\n * @param {object} [opts.data] - The request data\n * @param {int} [opts.timeout=30000] - The request timeout in milliseconds\n * @param {boolean} [opts.allowRedirects] - Should the client follow redirects\n * @param {boolean} [opts.forever] - Set to true to use the forever-agent\n */\n\n\nRequestClient.prototype.request = function (opts) {\n  opts = opts || {};\n\n  if (!opts.method) {\n    throw new Error('http method is required');\n  }\n\n  if (!opts.uri) {\n    throw new Error('uri is required');\n  }\n\n  var deferred = Q.defer();\n  var headers = opts.headers || {};\n\n  if (!headers.Connection && !headers.connection) {\n    headers.Connection = 'close';\n  }\n\n  if (opts.username && opts.password) {\n    var b64Auth = Buffer.from(opts.username + ':' + opts.password).toString('base64');\n    headers.Authorization = 'Basic ' + b64Auth;\n  }\n\n  var options = {\n    timeout: opts.timeout || 30000,\n    maxRedirects: opts.allowRedirects ? 10 : 0,\n    // Same number of allowed redirects as request module default\n    url: opts.uri,\n    method: opts.method,\n    headers: opts.headers,\n    httpAgent: opts.forever ? new http.Agent({\n      keepAlive: true\n    }) : undefined,\n    httpsAgent: opts.forever ? new https.Agent({\n      keepAlive: true\n    }) : undefined,\n    validateStatus: function validateStatus(status) {\n      return status >= 100 && status < 600;\n    }\n  };\n\n  if (process.env.TWILIO_CA_BUNDLE !== undefined) {\n    if (this.ca === undefined) {\n      this.ca = fs.readFileSync(process.env.TWILIO_CA_BUNDLE);\n    }\n\n    options.ca = this.ca;\n  }\n\n  if (!_.isNull(opts.data)) {\n    options.data = qs.stringify(opts.data, {\n      arrayFormat: 'repeat'\n    });\n  }\n\n  if (!_.isNull(opts.params)) {\n    options.params = opts.params;\n\n    options.paramsSerializer = function (params) {\n      return qs.stringify(params, {\n        arrayFormat: 'repeat'\n      });\n    };\n  }\n\n  var optionsRequest = {\n    method: options.method,\n    url: options.url,\n    auth: b64Auth || null,\n    params: options.params,\n    data: opts.data,\n    headers: options.headers,\n    ca: options.ca\n  };\n\n  var _this = this;\n\n  this.lastResponse = undefined;\n  this.lastRequest = new Request(optionsRequest);\n  axios(options).then(function (response) {\n    _this.lastResponse = new Response(response.status, response.data);\n    deferred.resolve({\n      statusCode: response.status,\n      body: response.data\n    });\n  }).catch(function (error) {\n    _this.lastResponse = undefined;\n    deferred.reject(error);\n  });\n  return deferred.promise;\n};\n\nmodule.exports = RequestClient;","map":null,"metadata":{},"sourceType":"script"}