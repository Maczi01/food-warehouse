{"ast":null,"code":"var _classCallCheck = require(\"C:\\\\Users\\\\Admin\\\\Desktop\\\\react1\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Admin\\\\Desktop\\\\react1\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\Admin\\\\Desktop\\\\react1\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\Admin\\\\Desktop\\\\react1\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _get = require(\"C:\\\\Users\\\\Admin\\\\Desktop\\\\react1\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\n\nvar _inherits = require(\"C:\\\\Users\\\\Admin\\\\Desktop\\\\react1\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\n// Generated by CoffeeScript 2.4.1\n(function () {\n  var NodeType,\n      WriterState,\n      XMLStreamWriter,\n      XMLWriterBase,\n      hasProp = {}.hasOwnProperty;\n  NodeType = require('./NodeType');\n  XMLWriterBase = require('./XMLWriterBase');\n  WriterState = require('./WriterState'); // Prints XML nodes to a stream\n\n  module.exports = XMLStreamWriter = /*#__PURE__*/function (_XMLWriterBase) {\n    \"use strict\";\n\n    _inherits(XMLStreamWriter, _XMLWriterBase);\n\n    // Initializes a new instance of `XMLStreamWriter`\n    // `stream` output stream\n    // `options.pretty` pretty prints the result\n    // `options.indent` indentation string\n    // `options.newline` newline sequence\n    // `options.offset` a fixed number of indentations to add to every line\n    // `options.allowEmpty` do not self close empty element tags\n    // 'options.dontPrettyTextNodes' if any text is present in node, don't indent or LF\n    // `options.spaceBeforeSlash` add a space before the closing slash of empty elements\n    function XMLStreamWriter(stream, options) {\n      var _this;\n\n      _classCallCheck(this, XMLStreamWriter);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(XMLStreamWriter).call(this, options));\n      _this.stream = stream;\n      return _this;\n    }\n\n    _createClass(XMLStreamWriter, [{\n      key: \"endline\",\n      value: function endline(node, options, level) {\n        if (node.isLastRootNode && options.state === WriterState.CloseTag) {\n          return '';\n        } else {\n          return _get(_getPrototypeOf(XMLStreamWriter.prototype), \"endline\", this).call(this, node, options, level);\n        }\n      }\n    }, {\n      key: \"document\",\n      value: function document(doc, options) {\n        var child, i, j, k, len1, len2, ref, ref1, results;\n        ref = doc.children; // set a flag so that we don't insert a newline after the last root level node \n\n        for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n          child = ref[i];\n          child.isLastRootNode = i === doc.children.length - 1;\n        }\n\n        options = this.filterOptions(options);\n        ref1 = doc.children;\n        results = [];\n\n        for (k = 0, len2 = ref1.length; k < len2; k++) {\n          child = ref1[k];\n          results.push(this.writeChildNode(child, options, 0));\n        }\n\n        return results;\n      }\n    }, {\n      key: \"cdata\",\n      value: function cdata(node, options, level) {\n        return this.stream.write(_get(_getPrototypeOf(XMLStreamWriter.prototype), \"cdata\", this).call(this, node, options, level));\n      }\n    }, {\n      key: \"comment\",\n      value: function comment(node, options, level) {\n        return this.stream.write(_get(_getPrototypeOf(XMLStreamWriter.prototype), \"comment\", this).call(this, node, options, level));\n      }\n    }, {\n      key: \"declaration\",\n      value: function declaration(node, options, level) {\n        return this.stream.write(_get(_getPrototypeOf(XMLStreamWriter.prototype), \"declaration\", this).call(this, node, options, level));\n      }\n    }, {\n      key: \"docType\",\n      value: function docType(node, options, level) {\n        var child, j, len1, ref;\n        level || (level = 0);\n        this.openNode(node, options, level);\n        options.state = WriterState.OpenTag;\n        this.stream.write(this.indent(node, options, level));\n        this.stream.write('<!DOCTYPE ' + node.root().name); // external identifier\n\n        if (node.pubID && node.sysID) {\n          this.stream.write(' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"');\n        } else if (node.sysID) {\n          this.stream.write(' SYSTEM \"' + node.sysID + '\"');\n        } // internal subset\n\n\n        if (node.children.length > 0) {\n          this.stream.write(' [');\n          this.stream.write(this.endline(node, options, level));\n          options.state = WriterState.InsideTag;\n          ref = node.children;\n\n          for (j = 0, len1 = ref.length; j < len1; j++) {\n            child = ref[j];\n            this.writeChildNode(child, options, level + 1);\n          }\n\n          options.state = WriterState.CloseTag;\n          this.stream.write(']');\n        } // close tag\n\n\n        options.state = WriterState.CloseTag;\n        this.stream.write(options.spaceBeforeSlash + '>');\n        this.stream.write(this.endline(node, options, level));\n        options.state = WriterState.None;\n        return this.closeNode(node, options, level);\n      }\n    }, {\n      key: \"element\",\n      value: function element(node, options, level) {\n        var att, attLen, child, childNodeCount, firstChildNode, j, len, len1, name, prettySuppressed, r, ratt, ref, ref1, ref2, rline;\n        level || (level = 0); // open tag\n\n        this.openNode(node, options, level);\n        options.state = WriterState.OpenTag;\n        r = this.indent(node, options, level) + '<' + node.name; // attributes\n\n        if (options.pretty && options.width > 0) {\n          len = r.length;\n          ref = node.attribs;\n\n          for (name in ref) {\n            if (!hasProp.call(ref, name)) continue;\n            att = ref[name];\n            ratt = this.attribute(att, options, level);\n            attLen = ratt.length;\n\n            if (len + attLen > options.width) {\n              rline = this.indent(node, options, level + 1) + ratt;\n              r += this.endline(node, options, level) + rline;\n              len = rline.length;\n            } else {\n              rline = ' ' + ratt;\n              r += rline;\n              len += rline.length;\n            }\n          }\n        } else {\n          ref1 = node.attribs;\n\n          for (name in ref1) {\n            if (!hasProp.call(ref1, name)) continue;\n            att = ref1[name];\n            r += this.attribute(att, options, level);\n          }\n        }\n\n        this.stream.write(r);\n        childNodeCount = node.children.length;\n        firstChildNode = childNodeCount === 0 ? null : node.children[0];\n\n        if (childNodeCount === 0 || node.children.every(function (e) {\n          return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === '';\n        })) {\n          // empty element\n          if (options.allowEmpty) {\n            this.stream.write('>');\n            options.state = WriterState.CloseTag;\n            this.stream.write('</' + node.name + '>');\n          } else {\n            options.state = WriterState.CloseTag;\n            this.stream.write(options.spaceBeforeSlash + '/>');\n          }\n        } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {\n          // do not indent text-only nodes\n          this.stream.write('>');\n          options.state = WriterState.InsideTag;\n          options.suppressPrettyCount++;\n          prettySuppressed = true;\n          this.writeChildNode(firstChildNode, options, level + 1);\n          options.suppressPrettyCount--;\n          prettySuppressed = false;\n          options.state = WriterState.CloseTag;\n          this.stream.write('</' + node.name + '>');\n        } else {\n          this.stream.write('>' + this.endline(node, options, level));\n          options.state = WriterState.InsideTag;\n          ref2 = node.children; // inner tags\n\n          for (j = 0, len1 = ref2.length; j < len1; j++) {\n            child = ref2[j];\n            this.writeChildNode(child, options, level + 1);\n          } // close tag\n\n\n          options.state = WriterState.CloseTag;\n          this.stream.write(this.indent(node, options, level) + '</' + node.name + '>');\n        }\n\n        this.stream.write(this.endline(node, options, level));\n        options.state = WriterState.None;\n        return this.closeNode(node, options, level);\n      }\n    }, {\n      key: \"processingInstruction\",\n      value: function processingInstruction(node, options, level) {\n        return this.stream.write(_get(_getPrototypeOf(XMLStreamWriter.prototype), \"processingInstruction\", this).call(this, node, options, level));\n      }\n    }, {\n      key: \"raw\",\n      value: function raw(node, options, level) {\n        return this.stream.write(_get(_getPrototypeOf(XMLStreamWriter.prototype), \"raw\", this).call(this, node, options, level));\n      }\n    }, {\n      key: \"text\",\n      value: function text(node, options, level) {\n        return this.stream.write(_get(_getPrototypeOf(XMLStreamWriter.prototype), \"text\", this).call(this, node, options, level));\n      }\n    }, {\n      key: \"dtdAttList\",\n      value: function dtdAttList(node, options, level) {\n        return this.stream.write(_get(_getPrototypeOf(XMLStreamWriter.prototype), \"dtdAttList\", this).call(this, node, options, level));\n      }\n    }, {\n      key: \"dtdElement\",\n      value: function dtdElement(node, options, level) {\n        return this.stream.write(_get(_getPrototypeOf(XMLStreamWriter.prototype), \"dtdElement\", this).call(this, node, options, level));\n      }\n    }, {\n      key: \"dtdEntity\",\n      value: function dtdEntity(node, options, level) {\n        return this.stream.write(_get(_getPrototypeOf(XMLStreamWriter.prototype), \"dtdEntity\", this).call(this, node, options, level));\n      }\n    }, {\n      key: \"dtdNotation\",\n      value: function dtdNotation(node, options, level) {\n        return this.stream.write(_get(_getPrototypeOf(XMLStreamWriter.prototype), \"dtdNotation\", this).call(this, node, options, level));\n      }\n    }]);\n\n    return XMLStreamWriter;\n  }(XMLWriterBase);\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}