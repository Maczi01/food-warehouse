{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar dayjs = require('dayjs');\n\nvar utc = require('dayjs/plugin/utc');\n\ndayjs.extend(utc);\nmodule.exports = {};\n/**\n * @namespace serialize\n */\n\n/**\n * @function iso8601Date\n * @memberOf serialize\n * @description turns a Date object into a string if parameter is a Date\n * otherwise returns the parameter\n *\n * @param  {Date} d date object to format\n * @return {string|object} date formatted in YYYY-MM-DD form\n */\n\nmodule.exports.iso8601Date = function (d) {\n  if (_.isUndefined(d) || _.isString(d) || !_.isDate(d)) {\n    return d;\n  } else {\n    return dayjs.utc(d).format('YYYY-MM-DD');\n  }\n};\n/**\n * @function iso8601DateTime\n * @memberOf serialize\n * @description turns a Date object into a string if parameter is a Date\n * otherwise returns the parameter\n *\n * @param  {Date} d date object to format\n * @return {string|object} date formatted in YYYY-MM-DD[T]HH:mm:ss[Z] form\n */\n\n\nmodule.exports.iso8601DateTime = function (d) {\n  if (_.isUndefined(d) || _.isString(d) || !(d instanceof Date)) {\n    return d;\n  } else {\n    return dayjs.utc(d).format('YYYY-MM-DD[T]HH:mm:ss[Z]');\n  }\n};\n/**\n * @function prefixedCollapsibleMap\n * @memberOf serialize\n * @description turns a map of params int oa flattened map separated by dots\n * if the parameter is an object, otherwise returns an empty map\n *\n * @param {object} m map to transform\n * @param {string|undefined} prefix to append to each flattened value\n * @return {object} flattened map\n */\n\n\nmodule.exports.prefixedCollapsibleMap = function (m, prefix) {\n  if (_.isUndefined(m) || !_.isPlainObject(m)) {\n    return {};\n  }\n\n  function flatten(m, result, previous) {\n    result = result || {};\n    previous = previous || [];\n\n    _.each(_.keys(m), function (key) {\n      if (_.isPlainObject(m[key])) {\n        flatten(m[key], result, _.union(previous, [key]));\n      } else {\n        result[_.join(_.union(previous, [key]), '.')] = m[key];\n      }\n    });\n\n    return result;\n  }\n\n  var flattened = flatten(m);\n  var result = flattened;\n\n  if (prefix) {\n    result = {};\n\n    _.each(_.keys(flattened), function (key) {\n      result[prefix + '.' + key] = flattened[key];\n    });\n  }\n\n  return result;\n};\n/**\n * @function object\n * @memberOf serialize\n * @description turns an object into a JSON string if the parameter\n * is an object, otherwise returns the passed in object\n *\n * @param {object|array} o json object or array\n * @returns {string|object} stringified object\n */\n\n\nmodule.exports.object = function (o) {\n  if (_.isObject(o) || _.isArray(o)) {\n    return JSON.stringify(o);\n  }\n\n  return o;\n};\n/**\n * @function bool\n * @memberOf serialize\n * @description coerces a boolean literal into a string\n *\n * @param {boolean|string} input boolean or string to be coerced\n * @returns {string} a string \"true\" or \"false\"\n */\n\n\nmodule.exports.bool = function (input) {\n  if (_.isString(input)) {\n    return input;\n  }\n\n  if (_.isBoolean(input)) {\n    return input.toString();\n  }\n\n  return input;\n};\n/**\n * @function map\n * @memberOf serialize\n * @description maps transform over each element in input if input is an array\n *\n * @param {array} input array to map transform over, if not an array then it is\n * returned as is.\n * @returns {array} new array with transform applied to each element.\n */\n\n\nmodule.exports.map = function (input, transform) {\n  if (_.isArray(input)) {\n    return _.map(input, transform);\n  }\n\n  return input;\n};","map":null,"metadata":{},"sourceType":"script"}