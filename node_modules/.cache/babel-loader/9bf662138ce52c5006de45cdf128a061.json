{"ast":null,"code":"/** Text hyphenation in Javascript.\n *  Copyright (C) 2020 Yevhen Tiurin (yevhentiurin@gmail.com)\n *  https://github.com/ytiurin/hyphen\n *\n *  Released under the ISC license\n *  https://github.com/ytiurin/hyphen/blob/master/LICENSE\n */\n(function (root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.createHyphenator = factory();\n  }\n})(this, function () {\n  var MIN_WORD_LENGTH_BOUNDRY = 5;\n  var SETTING_DEFAULT_ASYNC = false,\n      SETTING_DEFAULT_DEBUG = false,\n      SETTING_DEFAULT_HTML = false,\n      SETTING_DEFAULT_HYPH_CHAR = \"\\xAD\",\n      SETTING_NAME_ASYNC = \"async\",\n      SETTING_NAME_DEBUG = \"debug\",\n      SETTING_NAME_HTML = \"html\",\n      SETTING_NAME_HYPH_CHAR = \"hyphenChar\",\n      SETTING_NAME_MIN_WORD_LENGTH = \"minWordLength\";\n\n  var _global = typeof global === \"object\" ? global : typeof window === \"object\" ? window : typeof this === \"object\" ? this : {};\n\n  function cloneObj(source) {\n    var target = {};\n\n    for (var key in source) {\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n\n  function keyOrDefault(object, key, defaultValue) {\n    if (key in object) {\n      return object[key];\n    }\n\n    return defaultValue;\n  }\n\n  function exceptionsFromDefinition(patternsDefinition, hyphenChar) {\n    return patternsDefinition.exceptions.reduce(function (exceptions, exception) {\n      exceptions[exception.replace(/\\-/g, \"\")] = exception.replace(/\\-/g, hyphenChar);\n      return exceptions;\n    }, {});\n  }\n\n  function createHyphenator(patternsDefinition, options) {\n    options = options || {};\n    var //\n    asyncMode = keyOrDefault(options, SETTING_NAME_ASYNC, SETTING_DEFAULT_ASYNC),\n        caches = {},\n        debug = keyOrDefault(options, SETTING_NAME_DEBUG, SETTING_DEFAULT_DEBUG),\n        exceptions = {},\n        hyphenChar = keyOrDefault(options, SETTING_NAME_HYPH_CHAR, SETTING_DEFAULT_HYPH_CHAR),\n        patterns = patternsDefinition.patterns.map(preprocessPattern),\n        minWordLength = Math.max(options[SETTING_NAME_MIN_WORD_LENGTH] >> 0, MIN_WORD_LENGTH_BOUNDRY),\n        skipHTML = keyOrDefault(options, SETTING_NAME_HTML, SETTING_DEFAULT_HTML); // Prepare cache\n\n    var cacheKey = hyphenChar + minWordLength;\n    exceptions[cacheKey] = exceptionsFromDefinition(patternsDefinition, hyphenChar);\n    caches[cacheKey] = cloneObj(exceptions[cacheKey]);\n\n    if (asyncMode && !(\"Promise\" in _global)) {\n      throw new Error(\"Failed to create hyphenator: Could not find global Promise object, needed for hyphenator to work in async mode\");\n    }\n\n    return function (text, options) {\n      options = options || {};\n      var localDebug = keyOrDefault(options, SETTING_NAME_DEBUG, debug),\n          localHyphenChar = keyOrDefault(options, SETTING_NAME_HYPH_CHAR, hyphenChar),\n          localMinWordLength = Math.max(options[SETTING_NAME_MIN_WORD_LENGTH] >> 0, minWordLength),\n          cacheKey = localHyphenChar + localMinWordLength;\n\n      if (!exceptions[cacheKey]) {\n        exceptions[cacheKey] = exceptionsFromDefinition(patternsDefinition, localHyphenChar);\n      }\n\n      if (!caches[cacheKey]) {\n        caches[cacheKey] = cloneObj(exceptions[cacheKey]);\n      }\n\n      return start(text, patterns, caches[cacheKey], localDebug, localHyphenChar, skipHTML, localMinWordLength, asyncMode);\n    };\n  }\n\n  function createTextChunkReader(text, hyphenChar, skipHTML, minWordLength) {\n    function readNextTextChunk() {\n      var nextTextChunk = \"\";\n      shouldHyphenate = void 0;\n\n      chunkReader: while (nextCharIndex <= text.length) {\n        var //\n        nextChar = text.charAt(nextCharIndex++),\n            charIsLetter = !!nextChar && !/\\s|[\\!-\\@\\[-\\`\\{-\\~\\u2013-\\u203C]/.test(nextChar),\n            charIsAngleOpen = nextChar === \"<\",\n            charIsAngleClose = nextChar === \">\",\n            charIsHyphen = nextChar === hyphenChar;\n\n        do {\n          if (state === STATE_READ_TAG) {\n            if (charIsAngleClose) {\n              state = STATE_RETURN_UNTOUCHED;\n            }\n\n            break;\n          }\n\n          if (charIsHyphen) {\n            shouldHyphenate = SHOULD_SKIP;\n            state = STATE_READ_WORD;\n            break;\n          }\n\n          if (charIsLetter) {\n            state = STATE_READ_WORD;\n            break;\n          }\n\n          if (state === STATE_READ_WORD) {\n            state = STATE_RETURN_WORD;\n            shouldHyphenate = shouldHyphenate || nextTextChunk.length >= minWordLength && SHOULD_HYPHENATE;\n            break;\n          }\n\n          shouldHyphenate = SHOULD_SKIP;\n          state = STATE_RETURN_UNTOUCHED;\n        } while (0);\n\n        if (charIsAngleOpen && state !== STATE_RETURN_WORD && skipHTML && !isSpacelike(text.charAt(nextCharIndex))) {\n          shouldHyphenate = SHOULD_SKIP;\n          state = STATE_READ_TAG;\n        }\n\n        switch (state) {\n          case STATE_READ_TAG:\n            nextTextChunk += nextChar;\n            break;\n\n          case STATE_READ_WORD:\n            nextTextChunk += nextChar;\n            break;\n\n          case STATE_RETURN_UNTOUCHED:\n            nextTextChunk += nextChar;\n            break chunkReader;\n\n          case STATE_RETURN_WORD:\n            nextCharIndex--;\n            break chunkReader;\n        }\n      }\n\n      return nextTextChunk || void 0;\n    }\n\n    function shouldNextHyphenate() {\n      return shouldHyphenate === SHOULD_HYPHENATE;\n    }\n\n    var isSpacelike = RegExp.prototype.test.bind(/\\s/);\n    var //\n    nextCharIndex = 0,\n        SHOULD_HYPHENATE = 1,\n        SHOULD_SKIP = 2,\n        shouldHyphenate,\n        STATE_READ_TAG = 1,\n        STATE_READ_WORD = 2,\n        STATE_RETURN_UNTOUCHED = 3,\n        STATE_RETURN_WORD = 4,\n        state;\n    return [readNextTextChunk, shouldNextHyphenate];\n  }\n\n  function hyphenateWord(text, patterns, debug, hyphenChar) {\n    var //\n    levels = new Array(text.length + 1),\n        loweredText = text.toLocaleLowerCase(),\n        p = [],\n        patternData,\n        patternIndex = 0;\n\n    for (var i = levels.length; i--;) {\n      levels[i] = 0;\n    }\n\n    while (patternData = patterns[patternIndex++]) {\n      var //\n      fromChar = 0,\n          endPattern = false;\n\n      while (!endPattern) {\n        var //\n        patternEntityIndex = loweredText.indexOf(patternData.text, fromChar),\n            patternFits = patternEntityIndex > -1 && (patternData.stickToLeft ? patternEntityIndex === 0 : true) && (patternData.stickToRight ? patternEntityIndex + patternData.text.length === text.length : true);\n\n        if (patternFits) {\n          p.push(patternData.pattern + \">\" + patternData.levels.join(\"\"));\n\n          for (var i = 0; i < patternData.levels.length; i++) {\n            levels[patternEntityIndex + i] = Math.max(patternData.levels[i], levels[patternEntityIndex + i]);\n          }\n        }\n\n        if (patternEntityIndex > -1 && patternData.text.length > 0) {\n          fromChar = patternEntityIndex + patternData.text.length + 1;\n        } else {\n          endPattern = true;\n        }\n      }\n    }\n\n    levels[0] = levels[1] = levels[levels.length - 1] = levels[levels.length - 2] = 0;\n    var //\n    hyphenatedText = \"\",\n        leveledText = \"\",\n        debugHyphenatedText = \"\";\n\n    for (var i = 0; i < levels.length; i++) {\n      hyphenatedText += (levels[i] % 2 === 1 ? hyphenChar : \"\") + text.charAt(i);\n      debugHyphenatedText += (levels[i] % 2 === 1 ? \"-\" : \"\") + text.charAt(i);\n      leveledText += (levels[i] > 0 ? levels[i] : \"\") + text.charAt(i);\n    }\n\n    if (debug) console.log.apply(console, [text, \"->\"].concat(p).concat([\"->\"]).concat(levels).concat([\"->\", leveledText]).concat([\"->\", debugHyphenatedText]));\n    return hyphenatedText;\n  }\n\n  function preprocessPattern(pattern) {\n    var //\n    patternCharIndex = 0,\n        patternChar,\n        patternData = {\n      pattern: pattern,\n      text: \"\",\n      levels: [],\n      stickToLeft: 0,\n      stickToRight: 0\n    },\n        states = {\n      alphabet: 1,\n      level: 2,\n      stickToLeft: 3,\n      stickToRight: 4\n    };\n\n    while (patternChar = pattern.charAt(patternCharIndex++)) {\n      var //\n      charIsDot = patternChar === \".\",\n          charIsNumber = !charIsDot && /\\d/.test(patternChar),\n          state = charIsDot ? patternCharIndex - 1 === 0 ? states.stickToLeft : states.stickToRight : charIsNumber ? states.level : states.alphabet;\n\n      switch (state) {\n        case states.alphabet:\n          !prevCharIsNumber && patternData.levels.push(0);\n          patternData.text += patternChar;\n          break;\n\n        case states.level:\n          patternData.levels.push(parseInt(patternChar));\n          break;\n\n        case states.stickToLeft:\n          patternData.stickToLeft = true;\n          break;\n\n        case states.stickToRight:\n          patternData.stickToRight = true;\n          break;\n      }\n\n      var prevCharIsNumber = charIsNumber;\n    }\n\n    return patternData;\n  }\n\n  function start(text, patterns, cache, debug, hyphenChar, skipHTML, minWordLength, isAsync) {\n    function done() {\n      allTime = new Date() - allTime;\n      resolveNewText(newText);\n\n      if (debug) {\n        console.log(\"----------------\\nHyphenation stats: \" + processedN + \" text chunks processed, \" + hyphenatedN + \" words hyphenated\");\n        console.log(\"Work time: \" + workTime / 1000);\n        console.log(\"Wait time: \" + (allTime - workTime) / 1000);\n        console.log(\"All time: \" + allTime / 1000);\n      }\n    }\n\n    var //\n    newText = \"\",\n        nextTextChunk,\n        reader = createTextChunkReader(text, hyphenChar, skipHTML, minWordLength),\n        readNextTextChunk = reader[0],\n        shouldNextHyphenate = reader[1],\n        states = {\n      hyphenateWord: 1,\n      concatenate: 2\n    },\n        processedN = 0,\n        hyphenatedN = 0;\n    var //\n    allTime = new Date(),\n        workTime = 0;\n\n    var resolveNewText = function resolveNewText() {};\n\n    function nextTick() {\n      var loopStart = new Date();\n\n      while ((!isAsync || new Date() - loopStart < 10) && (nextTextChunk = readNextTextChunk())) {\n        var state = shouldNextHyphenate() ? states.hyphenateWord : states.concatenate;\n\n        switch (state) {\n          case states.hyphenateWord:\n            if (!cache[nextTextChunk]) cache[nextTextChunk] = hyphenateWord(nextTextChunk, patterns, debug, hyphenChar);\n            if (nextTextChunk !== cache[nextTextChunk]) hyphenatedN++;\n            nextTextChunk = cache[nextTextChunk];\n\n          case states.concatenate:\n            newText += nextTextChunk;\n        }\n\n        processedN++;\n      }\n\n      workTime += new Date() - loopStart;\n\n      if (!nextTextChunk) {\n        done();\n      } else {\n        setTimeout(nextTick);\n      }\n    }\n\n    if (isAsync) {\n      setTimeout(nextTick);\n      return new Promise(function (resolve) {\n        resolveNewText = resolve;\n      });\n    } else {\n      nextTick();\n      return newText;\n    }\n  }\n\n  return createHyphenator;\n});","map":null,"metadata":{},"sourceType":"script"}