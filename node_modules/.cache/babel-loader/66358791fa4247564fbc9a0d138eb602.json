{"ast":null,"code":"// Generated by CoffeeScript 1.7.1\n(function () {\n  var Struct, utils;\n  utils = require('./utils');\n\n  Struct = function () {\n    function Struct(fields) {\n      this.fields = fields != null ? fields : {};\n    }\n\n    Struct.prototype.decode = function (stream, parent, length) {\n      var res, _ref;\n\n      if (length == null) {\n        length = 0;\n      }\n\n      res = this._setup(stream, parent, length);\n\n      this._parseFields(stream, res, this.fields);\n\n      if ((_ref = this.process) != null) {\n        _ref.call(res, stream);\n      }\n\n      return res;\n    };\n\n    Struct.prototype._setup = function (stream, parent, length) {\n      var res;\n      res = {};\n      Object.defineProperties(res, {\n        parent: {\n          value: parent\n        },\n        _startOffset: {\n          value: stream.pos\n        },\n        _currentOffset: {\n          value: 0,\n          writable: true\n        },\n        _length: {\n          value: length\n        }\n      });\n      return res;\n    };\n\n    Struct.prototype._parseFields = function (stream, res, fields) {\n      var key, type, val;\n\n      for (key in fields) {\n        type = fields[key];\n\n        if (typeof type === 'function') {\n          val = type.call(res, res);\n        } else {\n          val = type.decode(stream, res);\n        }\n\n        if (val !== void 0) {\n          if (val instanceof utils.PropertyDescriptor) {\n            Object.defineProperty(res, key, val);\n          } else {\n            res[key] = val;\n          }\n        }\n\n        res._currentOffset = stream.pos - res._startOffset;\n      }\n    };\n\n    Struct.prototype.size = function (val, parent, includePointers) {\n      var ctx, key, size, type, _ref;\n\n      if (val == null) {\n        val = {};\n      }\n\n      if (includePointers == null) {\n        includePointers = true;\n      }\n\n      ctx = {\n        parent: parent,\n        val: val,\n        pointerSize: 0\n      };\n      size = 0;\n      _ref = this.fields;\n\n      for (key in _ref) {\n        type = _ref[key];\n\n        if (type.size != null) {\n          size += type.size(val[key], ctx);\n        }\n      }\n\n      if (includePointers) {\n        size += ctx.pointerSize;\n      }\n\n      return size;\n    };\n\n    Struct.prototype.encode = function (stream, val, parent) {\n      var ctx, i, key, ptr, type, _ref, _ref1;\n\n      if ((_ref = this.preEncode) != null) {\n        _ref.call(val, stream);\n      }\n\n      ctx = {\n        pointers: [],\n        startOffset: stream.pos,\n        parent: parent,\n        val: val,\n        pointerSize: 0\n      };\n      ctx.pointerOffset = stream.pos + this.size(val, ctx, false);\n      _ref1 = this.fields;\n\n      for (key in _ref1) {\n        type = _ref1[key];\n\n        if (type.encode != null) {\n          type.encode(stream, val[key], ctx);\n        }\n      }\n\n      i = 0;\n\n      while (i < ctx.pointers.length) {\n        ptr = ctx.pointers[i++];\n        ptr.type.encode(stream, ptr.val, ptr.parent);\n      }\n    };\n\n    return Struct;\n  }();\n\n  module.exports = Struct;\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}