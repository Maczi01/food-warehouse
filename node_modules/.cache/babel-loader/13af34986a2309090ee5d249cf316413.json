{"ast":null,"code":"\"use strict\";\n\nvar Buffer = require(\"safer-buffer\").Buffer; // Multibyte codec. In this scheme, a character is represented by 1 or more bytes.\n// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.\n// To save memory and loading time, we read table files only when requested.\n\n\nexports._dbcs = DBCSCodec;\nvar UNASSIGNED = -1,\n    GB18030_CODE = -2,\n    SEQ_START = -10,\n    NODE_START = -1000,\n    UNASSIGNED_NODE = new Array(0x100),\n    DEF_CHAR = -1;\n\nfor (var i = 0; i < 0x100; i++) {\n  UNASSIGNED_NODE[i] = UNASSIGNED;\n} // Class DBCSCodec reads and initializes mapping tables.\n\n\nfunction DBCSCodec(codecOptions, iconv) {\n  this.encodingName = codecOptions.encodingName;\n  if (!codecOptions) throw new Error(\"DBCS codec is called without the data.\");\n  if (!codecOptions.table) throw new Error(\"Encoding '\" + this.encodingName + \"' has no data.\"); // Load tables.\n\n  var mappingTable = codecOptions.table(); // Decode tables: MBCS -> Unicode.\n  // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.\n  // Trie root is decodeTables[0].\n  // Values: >=  0 -> unicode character code. can be > 0xFFFF\n  //         == UNASSIGNED -> unknown/unassigned sequence.\n  //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.\n  //         <= NODE_START -> index of the next node in our trie to process next byte.\n  //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.\n\n  this.decodeTables = [];\n  this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.\n  // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. \n\n  this.decodeTableSeq = []; // Actual mapping tables consist of chunks. Use them to fill up decode tables.\n\n  for (var i = 0; i < mappingTable.length; i++) {\n    this._addDecodeChunk(mappingTable[i]);\n  }\n\n  this.defaultCharUnicode = iconv.defaultCharUnicode; // Encode tables: Unicode -> DBCS.\n  // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.\n  // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.\n  // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).\n  //         == UNASSIGNED -> no conversion found. Output a default char.\n  //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.\n\n  this.encodeTable = []; // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of\n  // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key\n  // means end of sequence (needed when one sequence is a strict subsequence of another).\n  // Objects are kept separately from encodeTable to increase performance.\n\n  this.encodeTableSeq = []; // Some chars can be decoded, but need not be encoded.\n\n  var skipEncodeChars = {};\n  if (codecOptions.encodeSkipVals) for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {\n    var val = codecOptions.encodeSkipVals[i];\n    if (typeof val === 'number') skipEncodeChars[val] = true;else for (var j = val.from; j <= val.to; j++) {\n      skipEncodeChars[j] = true;\n    }\n  } // Use decode trie to recursively fill out encode tables.\n\n  this._fillEncodeTable(0, 0, skipEncodeChars); // Add more encoding pairs when needed.\n\n\n  if (codecOptions.encodeAdd) {\n    for (var uChar in codecOptions.encodeAdd) {\n      if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);\n    }\n  }\n\n  this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];\n  if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];\n  if (this.defCharSB === UNASSIGNED) this.defCharSB = \"?\".charCodeAt(0); // Load & create GB18030 tables when needed.\n\n  if (typeof codecOptions.gb18030 === 'function') {\n    this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.\n    // Add GB18030 decode tables.\n\n    var thirdByteNodeIdx = this.decodeTables.length;\n    var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);\n    var fourthByteNodeIdx = this.decodeTables.length;\n    var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);\n\n    for (var i = 0x81; i <= 0xFE; i++) {\n      var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];\n      var secondByteNode = this.decodeTables[secondByteNodeIdx];\n\n      for (var j = 0x30; j <= 0x39; j++) {\n        secondByteNode[j] = NODE_START - thirdByteNodeIdx;\n      }\n    }\n\n    for (var i = 0x81; i <= 0xFE; i++) {\n      thirdByteNode[i] = NODE_START - fourthByteNodeIdx;\n    }\n\n    for (var i = 0x30; i <= 0x39; i++) {\n      fourthByteNode[i] = GB18030_CODE;\n    }\n  }\n}\n\nDBCSCodec.prototype.encoder = DBCSEncoder;\nDBCSCodec.prototype.decoder = DBCSDecoder; // Decoder helpers\n\nDBCSCodec.prototype._getDecodeTrieNode = function (addr) {\n  var bytes = [];\n\n  for (; addr > 0; addr >>= 8) {\n    bytes.push(addr & 0xFF);\n  }\n\n  if (bytes.length == 0) bytes.push(0);\n  var node = this.decodeTables[0];\n\n  for (var i = bytes.length - 1; i > 0; i--) {\n    // Traverse nodes deeper into the trie.\n    var val = node[bytes[i]];\n\n    if (val == UNASSIGNED) {\n      // Create new node.\n      node[bytes[i]] = NODE_START - this.decodeTables.length;\n      this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));\n    } else if (val <= NODE_START) {\n      // Existing node.\n      node = this.decodeTables[NODE_START - val];\n    } else throw new Error(\"Overwrite byte in \" + this.encodingName + \", addr: \" + addr.toString(16));\n  }\n\n  return node;\n};\n\nDBCSCodec.prototype._addDecodeChunk = function (chunk) {\n  // First element of chunk is the hex mbcs code where we start.\n  var curAddr = parseInt(chunk[0], 16); // Choose the decoding node where we'll write our chars.\n\n  var writeTable = this._getDecodeTrieNode(curAddr);\n\n  curAddr = curAddr & 0xFF; // Write all other elements of the chunk to the table.\n\n  for (var k = 1; k < chunk.length; k++) {\n    var part = chunk[k];\n\n    if (typeof part === \"string\") {\n      // String, write as-is.\n      for (var l = 0; l < part.length;) {\n        var code = part.charCodeAt(l++);\n\n        if (0xD800 <= code && code < 0xDC00) {\n          // Decode surrogate\n          var codeTrail = part.charCodeAt(l++);\n          if (0xDC00 <= codeTrail && codeTrail < 0xE000) writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);else throw new Error(\"Incorrect surrogate pair in \" + this.encodingName + \" at chunk \" + chunk[0]);\n        } else if (0x0FF0 < code && code <= 0x0FFF) {\n          // Character sequence (our own encoding used)\n          var len = 0xFFF - code + 2;\n          var seq = [];\n\n          for (var m = 0; m < len; m++) {\n            seq.push(part.charCodeAt(l++));\n          } // Simple variation: don't support surrogates or subsequences in seq.\n\n\n          writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;\n          this.decodeTableSeq.push(seq);\n        } else writeTable[curAddr++] = code; // Basic char\n\n      }\n    } else if (typeof part === \"number\") {\n      // Integer, meaning increasing sequence starting with prev character.\n      var charCode = writeTable[curAddr - 1] + 1;\n\n      for (var l = 0; l < part; l++) {\n        writeTable[curAddr++] = charCode++;\n      }\n    } else throw new Error(\"Incorrect type '\" + typeof part + \"' given in \" + this.encodingName + \" at chunk \" + chunk[0]);\n  }\n\n  if (curAddr > 0xFF) throw new Error(\"Incorrect chunk in \" + this.encodingName + \" at addr \" + chunk[0] + \": too long\" + curAddr);\n}; // Encoder helpers\n\n\nDBCSCodec.prototype._getEncodeBucket = function (uCode) {\n  var high = uCode >> 8; // This could be > 0xFF because of astral characters.\n\n  if (this.encodeTable[high] === undefined) this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.\n\n  return this.encodeTable[high];\n};\n\nDBCSCodec.prototype._setEncodeChar = function (uCode, dbcsCode) {\n  var bucket = this._getEncodeBucket(uCode);\n\n  var low = uCode & 0xFF;\n  if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.\n  else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;\n};\n\nDBCSCodec.prototype._setEncodeSequence = function (seq, dbcsCode) {\n  // Get the root of character tree according to first character of the sequence.\n  var uCode = seq[0];\n\n  var bucket = this._getEncodeBucket(uCode);\n\n  var low = uCode & 0xFF;\n  var node;\n\n  if (bucket[low] <= SEQ_START) {\n    // There's already a sequence with  - use it.\n    node = this.encodeTableSeq[SEQ_START - bucket[low]];\n  } else {\n    // There was no sequence object - allocate a new one.\n    node = {};\n    if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.\n\n    bucket[low] = SEQ_START - this.encodeTableSeq.length;\n    this.encodeTableSeq.push(node);\n  } // Traverse the character tree, allocating new nodes as needed.\n\n\n  for (var j = 1; j < seq.length - 1; j++) {\n    var oldVal = node[uCode];\n    if (typeof oldVal === 'object') node = oldVal;else {\n      node = node[uCode] = {};\n      if (oldVal !== undefined) node[DEF_CHAR] = oldVal;\n    }\n  } // Set the leaf to given dbcsCode.\n\n\n  uCode = seq[seq.length - 1];\n  node[uCode] = dbcsCode;\n};\n\nDBCSCodec.prototype._fillEncodeTable = function (nodeIdx, prefix, skipEncodeChars) {\n  var node = this.decodeTables[nodeIdx];\n\n  for (var i = 0; i < 0x100; i++) {\n    var uCode = node[i];\n    var mbCode = prefix + i;\n    if (skipEncodeChars[mbCode]) continue;\n    if (uCode >= 0) this._setEncodeChar(uCode, mbCode);else if (uCode <= NODE_START) this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);else if (uCode <= SEQ_START) this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);\n  }\n}; // == Encoder ==================================================================\n\n\nfunction DBCSEncoder(options, codec) {\n  // Encoder state\n  this.leadSurrogate = -1;\n  this.seqObj = undefined; // Static data\n\n  this.encodeTable = codec.encodeTable;\n  this.encodeTableSeq = codec.encodeTableSeq;\n  this.defaultCharSingleByte = codec.defCharSB;\n  this.gb18030 = codec.gb18030;\n}\n\nDBCSEncoder.prototype.write = function (str) {\n  var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),\n      leadSurrogate = this.leadSurrogate,\n      seqObj = this.seqObj,\n      nextChar = -1,\n      i = 0,\n      j = 0;\n\n  while (true) {\n    // 0. Get next character.\n    if (nextChar === -1) {\n      if (i == str.length) break;\n      var uCode = str.charCodeAt(i++);\n    } else {\n      var uCode = nextChar;\n      nextChar = -1;\n    } // 1. Handle surrogates.\n\n\n    if (0xD800 <= uCode && uCode < 0xE000) {\n      // Char is one of surrogates.\n      if (uCode < 0xDC00) {\n        // We've got lead surrogate.\n        if (leadSurrogate === -1) {\n          leadSurrogate = uCode;\n          continue;\n        } else {\n          leadSurrogate = uCode; // Double lead surrogate found.\n\n          uCode = UNASSIGNED;\n        }\n      } else {\n        // We've got trail surrogate.\n        if (leadSurrogate !== -1) {\n          uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);\n          leadSurrogate = -1;\n        } else {\n          // Incomplete surrogate pair - only trail surrogate found.\n          uCode = UNASSIGNED;\n        }\n      }\n    } else if (leadSurrogate !== -1) {\n      // Incomplete surrogate pair - only lead surrogate found.\n      nextChar = uCode;\n      uCode = UNASSIGNED; // Write an error, then current char.\n\n      leadSurrogate = -1;\n    } // 2. Convert uCode character.\n\n\n    var dbcsCode = UNASSIGNED;\n\n    if (seqObj !== undefined && uCode != UNASSIGNED) {\n      // We are in the middle of the sequence\n      var resCode = seqObj[uCode];\n\n      if (typeof resCode === 'object') {\n        // Sequence continues.\n        seqObj = resCode;\n        continue;\n      } else if (typeof resCode == 'number') {\n        // Sequence finished. Write it.\n        dbcsCode = resCode;\n      } else if (resCode == undefined) {\n        // Current character is not part of the sequence.\n        // Try default character for this sequence\n        resCode = seqObj[DEF_CHAR];\n\n        if (resCode !== undefined) {\n          dbcsCode = resCode; // Found. Write it.\n\n          nextChar = uCode; // Current character will be written too in the next iteration.\n        } else {// TODO: What if we have no default? (resCode == undefined)\n            // Then, we should write first char of the sequence as-is and try the rest recursively.\n            // Didn't do it for now because no encoding has this situation yet.\n            // Currently, just skip the sequence and write current char.\n          }\n      }\n\n      seqObj = undefined;\n    } else if (uCode >= 0) {\n      // Regular character\n      var subtable = this.encodeTable[uCode >> 8];\n      if (subtable !== undefined) dbcsCode = subtable[uCode & 0xFF];\n\n      if (dbcsCode <= SEQ_START) {\n        // Sequence start\n        seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];\n        continue;\n      }\n\n      if (dbcsCode == UNASSIGNED && this.gb18030) {\n        // Use GB18030 algorithm to find character(s) to write.\n        var idx = findIdx(this.gb18030.uChars, uCode);\n\n        if (idx != -1) {\n          var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);\n          newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600);\n          dbcsCode = dbcsCode % 12600;\n          newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260);\n          dbcsCode = dbcsCode % 1260;\n          newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10);\n          dbcsCode = dbcsCode % 10;\n          newBuf[j++] = 0x30 + dbcsCode;\n          continue;\n        }\n      }\n    } // 3. Write dbcsCode character.\n\n\n    if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;\n\n    if (dbcsCode < 0x100) {\n      newBuf[j++] = dbcsCode;\n    } else if (dbcsCode < 0x10000) {\n      newBuf[j++] = dbcsCode >> 8; // high byte\n\n      newBuf[j++] = dbcsCode & 0xFF; // low byte\n    } else {\n      newBuf[j++] = dbcsCode >> 16;\n      newBuf[j++] = dbcsCode >> 8 & 0xFF;\n      newBuf[j++] = dbcsCode & 0xFF;\n    }\n  }\n\n  this.seqObj = seqObj;\n  this.leadSurrogate = leadSurrogate;\n  return newBuf.slice(0, j);\n};\n\nDBCSEncoder.prototype.end = function () {\n  if (this.leadSurrogate === -1 && this.seqObj === undefined) return; // All clean. Most often case.\n\n  var newBuf = Buffer.alloc(10),\n      j = 0;\n\n  if (this.seqObj) {\n    // We're in the sequence.\n    var dbcsCode = this.seqObj[DEF_CHAR];\n\n    if (dbcsCode !== undefined) {\n      // Write beginning of the sequence.\n      if (dbcsCode < 0x100) {\n        newBuf[j++] = dbcsCode;\n      } else {\n        newBuf[j++] = dbcsCode >> 8; // high byte\n\n        newBuf[j++] = dbcsCode & 0xFF; // low byte\n      }\n    } else {// See todo above.\n      }\n\n    this.seqObj = undefined;\n  }\n\n  if (this.leadSurrogate !== -1) {\n    // Incomplete surrogate pair - only lead surrogate found.\n    newBuf[j++] = this.defaultCharSingleByte;\n    this.leadSurrogate = -1;\n  }\n\n  return newBuf.slice(0, j);\n}; // Export for testing\n\n\nDBCSEncoder.prototype.findIdx = findIdx; // == Decoder ==================================================================\n\nfunction DBCSDecoder(options, codec) {\n  // Decoder state\n  this.nodeIdx = 0;\n  this.prevBuf = Buffer.alloc(0); // Static data\n\n  this.decodeTables = codec.decodeTables;\n  this.decodeTableSeq = codec.decodeTableSeq;\n  this.defaultCharUnicode = codec.defaultCharUnicode;\n  this.gb18030 = codec.gb18030;\n}\n\nDBCSDecoder.prototype.write = function (buf) {\n  var newBuf = Buffer.alloc(buf.length * 2),\n      nodeIdx = this.nodeIdx,\n      prevBuf = this.prevBuf,\n      prevBufOffset = this.prevBuf.length,\n      seqStart = -this.prevBuf.length,\n      // idx of the start of current parsed sequence.\n  uCode;\n  if (prevBufOffset > 0) // Make prev buf overlap a little to make it easier to slice later.\n    prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);\n\n  for (var i = 0, j = 0; i < buf.length; i++) {\n    var curByte = i >= 0 ? buf[i] : prevBuf[i + prevBufOffset]; // Lookup in current trie node.\n\n    var uCode = this.decodeTables[nodeIdx][curByte];\n\n    if (uCode >= 0) {// Normal character, just use it.\n    } else if (uCode === UNASSIGNED) {\n      // Unknown char.\n      // TODO: Callback with seq.\n      //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);\n      i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).\n\n      uCode = this.defaultCharUnicode.charCodeAt(0);\n    } else if (uCode === GB18030_CODE) {\n      var curSeq = seqStart >= 0 ? buf.slice(seqStart, i + 1) : prevBuf.slice(seqStart + prevBufOffset, i + 1 + prevBufOffset);\n      var ptr = (curSeq[0] - 0x81) * 12600 + (curSeq[1] - 0x30) * 1260 + (curSeq[2] - 0x81) * 10 + (curSeq[3] - 0x30);\n      var idx = findIdx(this.gb18030.gbChars, ptr);\n      uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];\n    } else if (uCode <= NODE_START) {\n      // Go to next trie node.\n      nodeIdx = NODE_START - uCode;\n      continue;\n    } else if (uCode <= SEQ_START) {\n      // Output a sequence of chars.\n      var seq = this.decodeTableSeq[SEQ_START - uCode];\n\n      for (var k = 0; k < seq.length - 1; k++) {\n        uCode = seq[k];\n        newBuf[j++] = uCode & 0xFF;\n        newBuf[j++] = uCode >> 8;\n      }\n\n      uCode = seq[seq.length - 1];\n    } else throw new Error(\"iconv-lite internal error: invalid decoding table value \" + uCode + \" at \" + nodeIdx + \"/\" + curByte); // Write the character to buffer, handling higher planes using surrogate pair.\n\n\n    if (uCode > 0xFFFF) {\n      uCode -= 0x10000;\n      var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);\n      newBuf[j++] = uCodeLead & 0xFF;\n      newBuf[j++] = uCodeLead >> 8;\n      uCode = 0xDC00 + uCode % 0x400;\n    }\n\n    newBuf[j++] = uCode & 0xFF;\n    newBuf[j++] = uCode >> 8; // Reset trie node.\n\n    nodeIdx = 0;\n    seqStart = i + 1;\n  }\n\n  this.nodeIdx = nodeIdx;\n  this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);\n  return newBuf.slice(0, j).toString('ucs2');\n};\n\nDBCSDecoder.prototype.end = function () {\n  var ret = ''; // Try to parse all remaining chars.\n\n  while (this.prevBuf.length > 0) {\n    // Skip 1 character in the buffer.\n    ret += this.defaultCharUnicode;\n    var buf = this.prevBuf.slice(1); // Parse remaining as usual.\n\n    this.prevBuf = Buffer.alloc(0);\n    this.nodeIdx = 0;\n    if (buf.length > 0) ret += this.write(buf);\n  }\n\n  this.nodeIdx = 0;\n  return ret;\n}; // Binary search for GB18030. Returns largest i such that table[i] <= val.\n\n\nfunction findIdx(table, val) {\n  if (table[0] > val) return -1;\n  var l = 0,\n      r = table.length;\n\n  while (l < r - 1) {\n    // always table[l] <= val < table[r]\n    var mid = l + Math.floor((r - l + 1) / 2);\n    if (table[mid] <= val) l = mid;else r = mid;\n  }\n\n  return l;\n}","map":null,"metadata":{},"sourceType":"script"}