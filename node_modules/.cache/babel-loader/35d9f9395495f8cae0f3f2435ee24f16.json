{"ast":null,"code":"import { createMemoryHistory, parsePath } from 'history';\nimport PropTypes from 'prop-types';\nimport React from 'react';\n\nfunction h() {\n  h = Object.assign || function (a) {\n    for (var b = 1; b < arguments.length; b++) {\n      var c = arguments[b],\n          d;\n\n      for (d in c) {\n        Object.prototype.hasOwnProperty.call(c, d) && (a[d] = c[d]);\n      }\n    }\n\n    return a;\n  };\n\n  return h.apply(this, arguments);\n}\n\nvar l = \"production\" !== process.env.NODE_ENV ? function (a) {\n  return Object.freeze(a);\n} : function (a) {\n  return a;\n};\n\nfunction m(a, b) {\n  if (!a) throw Error(b);\n}\n\nvar p = React.createContext({\n  history: null,\n  location: {\n    pathname: \"/\",\n    search: \"\",\n    hash: \"\"\n  },\n  pending: !1\n});\n\"production\" !== process.env.NODE_ENV && (p.Consumer.displayName = \"Location.Consumer\", p.Provider.displayName = \"Location.Provider\");\nvar q = React.createContext({\n  outlet: null,\n  params: l({}),\n  pathname: \"\",\n  route: null\n});\n\"production\" !== process.env.NODE_ENV && (q.Consumer.displayName = \"Route.Consumer\", q.Provider.displayName = \"Route.Provider\");\n\nfunction r(a) {\n  var b = a.children,\n      c = a.initialEntries,\n      d = a.initialIndex;\n  a = a.timeout;\n  var e = React.useRef(null);\n  null == e.current && (e.current = createMemoryHistory({\n    initialEntries: c,\n    initialIndex: d\n  }));\n  return React.createElement(t, {\n    children: b,\n    history: e.current,\n    timeout: a\n  });\n}\n\n\"production\" !== process.env.NODE_ENV && (r.displayName = \"MemoryRouter\", r.propTypes = {\n  children: PropTypes.node,\n  timeout: PropTypes.number,\n  initialEntries: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.shape({\n    pathname: PropTypes.string,\n    search: PropTypes.string,\n    hash: PropTypes.string,\n    state: PropTypes.object,\n    key: PropTypes.string\n  })])),\n  initialIndex: PropTypes.number\n});\n\nfunction u(a) {\n  var b = a.to,\n      c = a.replace;\n  c = void 0 === c ? !1 : c;\n  a = a.state;\n  v()(b, {\n    replace: c,\n    state: a\n  });\n  return null;\n}\n\n\"production\" !== process.env.NODE_ENV && (u.displayName = \"Navigate\", u.propTypes = {\n  to: PropTypes.oneOfType([PropTypes.string, PropTypes.shape({\n    pathname: PropTypes.string,\n    search: PropTypes.string,\n    hash: PropTypes.string\n  })]).isRequired,\n  replace: PropTypes.bool,\n  state: PropTypes.object\n});\n\nfunction w() {\n  return x();\n}\n\n\"production\" !== process.env.NODE_ENV && (w.displayName = \"Outlet\", w.propTypes = {});\n\nfunction y() {\n  return null;\n}\n\n\"production\" !== process.env.NODE_ENV && (y.displayName = \"Redirect\", y.propTypes = {\n  children: function children(a, b) {\n    if (null != a[b]) return Error(\"A <Redirect> should not have child routes; they will never be rendered.\");\n  },\n  from: PropTypes.string,\n  to: PropTypes.oneOfType([PropTypes.string, PropTypes.shape({\n    pathname: PropTypes.string,\n    search: PropTypes.string,\n    hash: PropTypes.string\n  })])\n});\n\nfunction z(a) {\n  return a.element;\n}\n\n\"production\" !== process.env.NODE_ENV && (z.displayName = \"Route\", z.propTypes = {\n  children: PropTypes.node,\n  element: PropTypes.element,\n  path: PropTypes.string\n});\n\nfunction A(a) {\n  return a();\n}\n\nvar B = React.useTransition || function () {\n  return [A, !1];\n};\n\nfunction t(a) {\n  var b = a.children;\n  b = void 0 === b ? null : b;\n  var c = a.history;\n  a = a.timeout;\n  var d = void 0 === a ? 2E3 : a,\n      e = React.useState(c.location);\n  a = e[0];\n  var f = e[1];\n  d = B({\n    timeoutMs: d\n  });\n  var g = d[0];\n  d = d[1];\n  e = React.useRef(!1);\n  React.useContext(p).history ? \"production\" !== process.env.NODE_ENV ? m(!1, \"You rendered a <Router> inside another <Router> but you should only ever render one in a given app.\") : m(!1) : void 0;\n  e.current || (e.current = !0, c.listen(function (a) {\n    var b = a.location;\n    g(function () {\n      f(b);\n    });\n  }));\n  return React.createElement(p.Provider, {\n    children: b,\n    value: {\n      history: c,\n      location: a,\n      pending: d\n    }\n  });\n}\n\n\"production\" !== process.env.NODE_ENV && (t.displayName = \"Router\", t.propTypes = {\n  children: PropTypes.node,\n  history: PropTypes.shape({\n    action: PropTypes.string,\n    location: PropTypes.object,\n    push: PropTypes.func,\n    replace: PropTypes.func,\n    go: PropTypes.func,\n    listen: PropTypes.func,\n    block: PropTypes.func\n  }),\n  timeout: PropTypes.number\n});\n\nfunction C(a) {\n  var b = a.basename;\n  b = void 0 === b ? \"\" : b;\n  var c = a.caseSensitive;\n  c = void 0 === c ? !1 : c;\n  a = a.children;\n  var d = React.useContext(q),\n      e = d.pathname,\n      f = d.route;\n  d = f && f.path;\n\n  if (\"production\" !== process.env.NODE_ENV) {\n    if (f = !f || f.path.endsWith(\"*\"), e = 'You rendered <Routes> at \"' + e + '\" (under route path \"' + d + '\") but the route path has no trailing \"*\", so the child routes won\\'t be able to match any part of the URL. You should use route path \"' + (d + '/*\" instead.'), !f) {\n      \"undefined\" !== typeof console && console.warn(e);\n\n      try {\n        throw Error(e);\n      } catch (g) {}\n    }\n  } else void 0;\n\n  a = D(a);\n  return E(a, b, c);\n}\n\n\"production\" !== process.env.NODE_ENV && (C.displayName = \"Routes\", C.propTypes = {\n  basename: PropTypes.string,\n  caseSensitive: PropTypes.bool,\n  children: PropTypes.node\n});\n\nfunction D(a) {\n  var b = [];\n  React.Children.forEach(a, function (a) {\n    if (React.isValidElement(a)) {\n      var c = a.props,\n          e = c.children,\n          f = c.from,\n          g = c.path;\n      c = c.to;\n      a.type === React.Fragment ? b.push.apply(b, D(e)) : (g = g || f || \"/\", c ? a = {\n        path: g,\n        redirectTo: c\n      } : (a = {\n        path: g,\n        element: a\n      }, e = D(e), e.length && (a.children = e)), b.push(a));\n    }\n  });\n  return b;\n}\n\nfunction F() {\n  return React.useContext(p).location;\n}\n\nfunction v() {\n  var a = React.useContext(p),\n      b = a.history,\n      c = a.pending,\n      d = React.useContext(q).pathname;\n  null == b ? \"production\" !== process.env.NODE_ENV ? m(!1, \"navigation may be used only in the context of a <Router> component\") : m(!1) : void 0;\n  return React.useCallback(function (a, f) {\n    var e = void 0 === f ? {} : f;\n    f = e.replace;\n    e = e.state;\n    \"number\" === typeof a ? b.go(a) : (a = G(a, d), b[f || c ? \"replace\" : \"push\"](a, e));\n  }, [b, c, d]);\n}\n\nfunction x() {\n  return React.useContext(q).outlet;\n}\n\nfunction H(a) {\n  var b = React.useContext(q).pathname;\n  return React.useMemo(function () {\n    return G(a, b);\n  }, [a, b]);\n}\n\nfunction E(a, b, c) {\n  void 0 === b && (b = \"\");\n  void 0 === c && (c = !1);\n  var d = F(),\n      e = v(),\n      f = React.useContext(q),\n      g = f.params,\n      n = f.pathname;\n  b = b ? I([n, b]) : n;\n  f = React.useMemo(function () {\n    return J(a, d, b, c);\n  }, [a, d, b, c]);\n  if (!f) return null;\n  var k = f.find(function (a) {\n    return null != a.route.redirectTo;\n  });\n  return k ? (f = k.params, n = G(k.route.redirectTo, n), k = n.pathname, /:\\w+/.test(k) && (n = h({}, n, {\n    pathname: K(k, f)\n  })), e(n, {\n    replace: !0\n  }), null) : f.reduceRight(function (a, c) {\n    var d = c.pathname,\n        e = c.route;\n    return React.createElement(q.Provider, {\n      children: e.element,\n      value: {\n        outlet: a,\n        params: l(h({}, g, {}, c.params)),\n        pathname: I([b, d]),\n        route: e\n      }\n    });\n  }, null);\n}\n\nfunction J(a, b, c, d) {\n  function e(a) {\n    a = g[a];\n    var b = a[1];\n    if (L(a[0], !0, d)[0].test(f)) return {\n      v: b.map(function (a, c) {\n        c = b.slice(0, c + 1);\n        c = I(c.map(function (a) {\n          return a.path;\n        }));\n        var e = L(c, !1, d);\n        c = e[1];\n        e = f.match(e[0]);\n        return {\n          params: M(c, e.slice(2)),\n          pathname: \"/\" + e[1],\n          route: a\n        };\n      })\n    };\n  }\n\n  void 0 === c && (c = \"\");\n  void 0 === d && (d = !1);\n  \"string\" === typeof b && (b = parsePath(b));\n  c = c.replace(/^\\/+|\\/+$/g, \"\");\n  var f = b.pathname.slice(1);\n  if (c) if (c === f) f = \"\";else if (f.startsWith(c)) f = f.slice(c.length).replace(/^\\/+/, \"\");else return null;\n  var g = N(a);\n  O(g);\n\n  for (a = 0; a < g.length; ++a) {\n    if (b = e(a), \"object\" === typeof b) return b.v;\n  }\n\n  return null;\n}\n\nfunction N(a, b, c, d, e) {\n  void 0 === b && (b = []);\n  void 0 === c && (c = \"\");\n  void 0 === d && (d = []);\n  void 0 === e && (e = []);\n  a.forEach(function (a, g) {\n    var f = I([c, a.path]),\n        k = d.concat(a);\n    g = e.concat(g);\n    b.push([f, k, g]);\n    a.children && N(a.children, b, f, k, g);\n  });\n  return b;\n}\n\nvar P = /^:\\w+$/;\n\nfunction Q(a) {\n  return a.split(\"/\").reduce(function (a, c) {\n    return a + (P.test(c) ? 2 : \"*\" === c ? -1 : 10);\n  }, 0);\n}\n\nfunction O(a) {\n  var b = a.reduce(function (a, b) {\n    b = b[0];\n    a[b] = Q(b);\n    return a;\n  }, {});\n  a.sort(function (a, d) {\n    var c = a[2];\n    a = b[a[0]];\n    var f = d[2];\n    d = b[d[0]];\n    return a !== d ? d - a : R(c, f);\n  });\n}\n\nfunction R(a, b) {\n  return a.length === b.length && a.slice(0, -1).every(function (a, d) {\n    return a === b[d];\n  }) ? a[a.length - 1] - b[b.length - 1] : 0;\n}\n\nfunction L(a, b, c) {\n  var d = [],\n      e = \"^(\" + a.replace(/^\\/+/, \"\").replace(/\\*\\//, \"\").replace(/\\/?\\*?$/, \"\").replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\").replace(/:(\\w+)/g, function (a, b) {\n    d.push(b);\n    return \"([^\\\\/]+)\";\n  }) + \")\";\n  a.endsWith(\"*\") ? (a.endsWith(\"/*\") && (e += \"\\\\/?\"), d.push(\"*\"), e += \"(.*)\") : b && (e += \"\\\\/?\");\n  b && (e += \"$\");\n  return [new RegExp(e, c ? void 0 : \"i\"), d];\n}\n\nfunction M(a, b) {\n  return a.reduce(function (a, d, e) {\n    a[d] = b[e];\n    return a;\n  }, {});\n}\n\nfunction I(a) {\n  return a.join(\"/\").replace(/\\/\\/+/g, \"/\");\n}\n\nfunction S(a, b) {\n  var c = b.replace(/\\/+$/, \"\").replace(/\\/\\/+/g, \"/\").split(\"/\");\n  a.replace(/\\/\\/+/g, \"/\").split(\"/\").forEach(function (a) {\n    \"..\" === a ? 1 < c.length && c.pop() : \".\" !== a && c.push(a);\n  });\n  return 1 < c.length ? I(c) : \"/\";\n}\n\nfunction G(a, b) {\n  void 0 === b && (b = \"/\");\n  var c = \"string\" === typeof a ? parsePath(a) : a;\n  a = c.pathname;\n  var d = c.search;\n  d = void 0 === d ? \"\" : d;\n  c = c.hash;\n  c = void 0 === c ? \"\" : c;\n  return {\n    pathname: a ? a.startsWith(\"/\") ? S(a, \"/\") : S(a, b) : b,\n    search: d,\n    hash: c\n  };\n}\n\nfunction K(a, b) {\n  void 0 === b && (b = {});\n  return a.replace(/:(\\w+)/g, function (a, d) {\n    return b[d] || \":\" + d;\n  }).replace(/\\*$/, function (a) {\n    return b[a] || a;\n  });\n}\n\nvar MemoryRouter = r;\nvar Navigate = u;\nvar Outlet = w;\nvar Redirect = y;\nvar Route = z;\nvar Router = t;\nvar Routes = C;\nvar createRoutesFromChildren = D;\nvar generatePath = K;\nvar matchRoutes = J;\nvar resolveLocation = G;\n\nvar useBlocker = function useBlocker(a, b) {\n  void 0 === b && (b = !0);\n  var c = React.useContext(p).history;\n  null == c ? \"production\" !== process.env.NODE_ENV ? m(!1, \"navigation blocking may be used only in the context of a <Router> component\") : m(!1) : void 0;\n  React.useEffect(function () {\n    if (b) {\n      var d = c.block(function (b) {\n        var c = h({}, b, {\n          retry: function retry() {\n            d();\n            b.retry();\n          }\n        });\n        a(c);\n      });\n      return d;\n    }\n  }, [c, b, a]);\n};\n\nvar useHref = function useHref(a) {\n  a = H(a);\n  var b = React.useContext(p).history;\n  null == b ? \"production\" !== process.env.NODE_ENV ? m(!1, \"href resolution may be used only in the context of a <Router> component\") : m(!1) : void 0;\n  return b.createHref(a);\n};\n\nvar useLocation = F;\n\nvar useMatch = function useMatch(a) {\n  var b = F();\n  a = H(a);\n  return b.pathname === a.pathname;\n};\n\nvar useNavigate = v;\nvar useOutlet = x;\n\nvar useParams = function useParams() {\n  return React.useContext(q).params;\n};\n\nvar useResolvedLocation = H;\nvar useRoutes = E;\nexport { MemoryRouter, Navigate, Outlet, Redirect, Route, Router, Routes, createRoutesFromChildren, generatePath, matchRoutes, resolveLocation, useBlocker, useHref, useLocation, useMatch, useNavigate, useOutlet, useParams, useResolvedLocation, useRoutes };","map":null,"metadata":{},"sourceType":"module"}