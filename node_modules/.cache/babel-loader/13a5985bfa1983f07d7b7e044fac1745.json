{"ast":null,"code":"/* vim:ts=4:sts=4:sw=4: */\n\n/*!\n *\n * Copyright 2009-2013 Kris Kowal under the terms of the MIT\n * license found at http://github.com/kriskowal/q/raw/master/LICENSE\n *\n * With parts by Tyler Close\n * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n * at http://www.opensource.org/licenses/mit-license.html\n * Forked at ref_send.js version: 2009-05-11\n *\n * With parts by Mark Miller\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n/*global -WeakMap */\n\"use strict\";\n\nvar hasStacks = false;\n\ntry {\n  throw new Error();\n} catch (e) {\n  hasStacks = !!e.stack;\n} // All code after this point will be filtered from stack traces reported\n// by Q.\n\n\nvar qStartingLine = captureLine();\nvar qFileName;\n\nvar WeakMap = require(\"weak-map\");\n\nvar iterate = require(\"pop-iterate\");\n\nvar asap = require(\"asap\");\n\nfunction isObject(value) {\n  return value === Object(value);\n} // long stack traces\n\n\nvar STACK_JUMP_SEPARATOR = \"From previous event:\";\n\nfunction makeStackTraceLong(error, promise) {\n  // If possible, transform the error stack trace by removing Node and Q\n  // cruft, then concatenating with the stack trace of `promise`. See #57.\n  if (hasStacks && promise.stack && typeof error === \"object\" && error !== null && error.stack && error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1) {\n    var stacks = [];\n\n    for (var p = promise; !!p && handlers.get(p); p = handlers.get(p).became) {\n      if (p.stack) {\n        stacks.unshift(p.stack);\n      }\n    }\n\n    stacks.unshift(error.stack);\n    var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n    error.stack = filterStackString(concatedStacks);\n  }\n}\n\nfunction filterStackString(stackString) {\n  if (Q.isIntrospective) {\n    return stackString;\n  }\n\n  var lines = stackString.split(\"\\n\");\n  var desiredLines = [];\n\n  for (var i = 0; i < lines.length; ++i) {\n    var line = lines[i];\n\n    if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n      desiredLines.push(line);\n    }\n  }\n\n  return desiredLines.join(\"\\n\");\n}\n\nfunction isNodeFrame(stackLine) {\n  return stackLine.indexOf(\"(module.js:\") !== -1 || stackLine.indexOf(\"(node.js:\") !== -1;\n}\n\nfunction getFileNameAndLineNumber(stackLine) {\n  // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n  // In IE10 function name can have spaces (\"Anonymous function\") O_o\n  var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n\n  if (attempt1) {\n    return [attempt1[1], Number(attempt1[2])];\n  } // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n\n\n  var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n\n  if (attempt2) {\n    return [attempt2[1], Number(attempt2[2])];\n  } // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n\n\n  var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n\n  if (attempt3) {\n    return [attempt3[1], Number(attempt3[2])];\n  }\n}\n\nfunction isInternalFrame(stackLine) {\n  var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n\n  if (!fileNameAndLineNumber) {\n    return false;\n  }\n\n  var fileName = fileNameAndLineNumber[0];\n  var lineNumber = fileNameAndLineNumber[1];\n  return fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine;\n} // discover own file name and line number range for filtering stack\n// traces\n\n\nfunction captureLine() {\n  if (!hasStacks) {\n    return;\n  }\n\n  try {\n    throw new Error();\n  } catch (e) {\n    var lines = e.stack.split(\"\\n\");\n    var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n    var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n\n    if (!fileNameAndLineNumber) {\n      return;\n    }\n\n    qFileName = fileNameAndLineNumber[0];\n    return fileNameAndLineNumber[1];\n  }\n}\n\nfunction deprecate(callback, name, alternative) {\n  return function Q_deprecate() {\n    if (typeof console !== \"undefined\" && typeof console.warn === \"function\") {\n      if (alternative) {\n        console.warn(name + \" is deprecated, use \" + alternative + \" instead.\", new Error(\"\").stack);\n      } else {\n        console.warn(name + \" is deprecated.\", new Error(\"\").stack);\n      }\n    }\n\n    return callback.apply(this, arguments);\n  };\n} // end of long stack traces\n\n\nvar handlers = new WeakMap();\n\nfunction Q_getHandler(promise) {\n  var handler = handlers.get(promise);\n\n  if (!handler || !handler.became) {\n    return handler;\n  }\n\n  handler = follow(handler);\n  handlers.set(promise, handler);\n  return handler;\n}\n\nfunction follow(handler) {\n  if (!handler.became) {\n    return handler;\n  } else {\n    handler.became = follow(handler.became);\n    return handler.became;\n  }\n}\n\nvar theViciousCycleError = new Error(\"Can't resolve a promise with itself\");\nvar theViciousCycleRejection = Q_reject(theViciousCycleError);\nvar theViciousCycle = Q_getHandler(theViciousCycleRejection);\nvar thenables = new WeakMap();\n/**\n * Coerces a value to a promise. If the value is a promise, pass it through\n * unaltered. If the value has a `then` method, it is presumed to be a promise\n * but not one of our own, so it is treated as a “thenable” promise and this\n * returns a promise that stands for it. Otherwise, this returns a promise that\n * has already been fulfilled with the value.\n * @param value promise, object with a then method, or a fulfillment value\n * @returns {Promise} the same promise as given, or a promise for the given\n * value\n */\n\nmodule.exports = Q;\n\nfunction Q(value) {\n  // If the object is already a Promise, return it directly.  This enables\n  // the resolve function to both be used to created references from objects,\n  // but to tolerably coerce non-promises to promises.\n  if (Q_isPromise(value)) {\n    return value;\n  } else if (isThenable(value)) {\n    if (!thenables.has(value)) {\n      thenables.set(value, new Promise(new Thenable(value)));\n    }\n\n    return thenables.get(value);\n  } else {\n    return new Promise(new Fulfilled(value));\n  }\n}\n/**\n * Controls whether or not long stack traces will be on\n * @type {boolean}\n */\n\n\nQ.longStackSupport = false;\n/**\n * Returns a promise that has been rejected with a reason, which should be an\n * instance of `Error`.\n * @param {Error} error reason for the failure.\n * @returns {Promise} rejection\n */\n\nQ.reject = Q_reject;\n\nfunction Q_reject(error) {\n  return new Promise(new Rejected(error));\n}\n/**\n * Constructs a {promise, resolve, reject} object.\n *\n * `resolve` is a callback to invoke with a more resolved value for the\n * promise. To fulfill the promise, invoke `resolve` with any value that is\n * not a thenable. To reject the promise, invoke `resolve` with a rejected\n * thenable, or invoke `reject` with the reason directly. To resolve the\n * promise to another thenable, thus putting it in the same state, invoke\n * `resolve` with that other thenable.\n *\n * @returns {{promise, resolve, reject}} a deferred\n */\n\n\nQ.defer = defer;\n\nfunction defer() {\n  var handler = new Pending();\n  var promise = new Promise(handler);\n  var deferred = new Deferred(promise);\n\n  if (Q.longStackSupport && hasStacks) {\n    try {\n      throw new Error();\n    } catch (e) {\n      // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n      // accessor around; that causes memory leaks as per GH-111. Just\n      // reify the stack trace as a string ASAP.\n      //\n      // At the same time, cut off the first line; it's always just\n      // \"[object Promise]\\n\", as per the `toString`.\n      promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n    }\n  }\n\n  return deferred;\n} // TODO\n\n/**\n */\n\n\nQ.when = function Q_when(value, fulfilled, rejected, ms) {\n  return Q(value).then(fulfilled, rejected, ms);\n};\n/**\n * Turns an array of promises into a promise for an array.  If any of the\n * promises gets rejected, the whole array is rejected immediately.\n * @param {Array.<Promise>} an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Promise.<Array>} a promise for an array of the corresponding values\n */\n// By Mark Miller\n// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\n\n\nQ.all = Q_all;\n\nfunction Q_all(questions) {\n  // XXX deprecated behavior\n  if (Q_isPromise(questions)) {\n    if (typeof console !== \"undefined\" && typeof console.warn === \"function\") {\n      console.warn(\"Q.all no longer directly unwraps a promise. Use Q(array).all()\");\n    }\n\n    return Q(questions).all();\n  }\n\n  var countDown = 0;\n  var deferred = defer();\n  var answers = Array(questions.length);\n  var estimates = [];\n  var estimate = -Infinity;\n  var setEstimate;\n  Array.prototype.forEach.call(questions, function Q_all_each(promise, index) {\n    var handler;\n\n    if (Q_isPromise(promise) && (handler = Q_getHandler(promise)).state === \"fulfilled\") {\n      answers[index] = handler.value;\n    } else {\n      ++countDown;\n      promise = Q(promise);\n      promise.then(function Q_all_eachFulfilled(value) {\n        answers[index] = value;\n\n        if (--countDown === 0) {\n          deferred.resolve(answers);\n        }\n      }, deferred.reject);\n      promise.observeEstimate(function Q_all_eachEstimate(newEstimate) {\n        var oldEstimate = estimates[index];\n        estimates[index] = newEstimate;\n\n        if (newEstimate > estimate) {\n          estimate = newEstimate;\n        } else if (oldEstimate === estimate && newEstimate <= estimate) {\n          // There is a 1/length chance that we will need to perform\n          // this O(length) walk, so amortized O(1)\n          computeEstimate();\n        }\n\n        if (estimates.length === questions.length && estimate !== setEstimate) {\n          deferred.setEstimate(estimate);\n          setEstimate = estimate;\n        }\n      });\n    }\n  });\n\n  function computeEstimate() {\n    estimate = -Infinity;\n\n    for (var index = 0; index < estimates.length; index++) {\n      if (estimates[index] > estimate) {\n        estimate = estimates[index];\n      }\n    }\n  }\n\n  if (countDown === 0) {\n    deferred.resolve(answers);\n  }\n\n  return deferred.promise;\n}\n/**\n * @see Promise#allSettled\n */\n\n\nQ.allSettled = Q_allSettled;\n\nfunction Q_allSettled(questions) {\n  // XXX deprecated behavior\n  if (Q_isPromise(questions)) {\n    if (typeof console !== \"undefined\" && typeof console.warn === \"function\") {\n      console.warn(\"Q.allSettled no longer directly unwraps a promise. Use Q(array).allSettled()\");\n    }\n\n    return Q(questions).allSettled();\n  }\n\n  return Q_all(questions.map(function Q_allSettled_each(promise) {\n    promise = Q(promise);\n\n    function regardless() {\n      return promise.inspect();\n    }\n\n    return promise.then(regardless, regardless);\n  }));\n}\n/**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */\n\n\nQ.delay = function Q_delay(object, timeout) {\n  if (timeout === void 0) {\n    timeout = object;\n    object = void 0;\n  }\n\n  return Q(object).delay(timeout);\n};\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Any*} promise\n * @param {Number} milliseconds timeout\n * @param {String} custom error message (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */\n\n\nQ.timeout = function Q_timeout(object, ms, message) {\n  return Q(object).timeout(ms, message);\n};\n/**\n * Spreads the values of a promised array of arguments into the\n * fulfillment callback.\n * @param fulfilled callback that receives variadic arguments from the\n * promised array\n * @param rejected callback that receives the exception if the promise\n * is rejected.\n * @returns a promise for the return value or thrown exception of\n * either callback.\n */\n\n\nQ.spread = Q_spread;\n\nfunction Q_spread(value, fulfilled, rejected) {\n  return Q(value).spread(fulfilled, rejected);\n}\n/**\n * If two promises eventually fulfill to the same value, promises that value,\n * but otherwise rejects.\n * @param x {Any*}\n * @param y {Any*}\n * @returns {Any*} a promise for x and y if they are the same, but a rejection\n * otherwise.\n *\n */\n\n\nQ.join = function Q_join(x, y) {\n  return Q.spread([x, y], function Q_joined(x, y) {\n    if (x === y) {\n      // TODO: \"===\" should be Object.is or equiv\n      return x;\n    } else {\n      throw new Error(\"Can't join: not the same: \" + x + \" \" + y);\n    }\n  });\n};\n/**\n * Returns a promise for the first of an array of promises to become fulfilled.\n * @param answers {Array} promises to race\n * @returns {Promise} the first promise to be fulfilled\n */\n\n\nQ.race = Q_race;\n\nfunction Q_race(answerPs) {\n  return new Promise(function (deferred) {\n    answerPs.forEach(function (answerP) {\n      Q(answerP).then(deferred.resolve, deferred.reject);\n    });\n  });\n}\n/**\n * Calls the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\n\n\nQ.try = function Q_try(callback) {\n  return Q(callback).dispatch(\"call\", [[]]);\n};\n/**\n * TODO\n */\n\n\nQ.function = Promise_function;\n\nfunction Promise_function(wrapped) {\n  return function promiseFunctionWrapper() {\n    var args = new Array(arguments.length);\n\n    for (var index = 0; index < arguments.length; index++) {\n      args[index] = arguments[index];\n    }\n\n    return Q(wrapped).apply(this, args);\n  };\n}\n/**\n * The promised function decorator ensures that any promise arguments\n * are settled and passed as values (`this` is also settled and passed\n * as a value).  It will also ensure that the result of a function is\n * always a promise.\n *\n * @example\n * var add = Q.promised(function (a, b) {\n *     return a + b;\n * });\n * add(Q(a), Q(B));\n *\n * @param {function} callback The function to decorate\n * @returns {function} a function that has been decorated.\n */\n\n\nQ.promised = function Q_promised(callback) {\n  return function promisedMethod() {\n    var args = new Array(arguments.length);\n\n    for (var index = 0; index < arguments.length; index++) {\n      args[index] = arguments[index];\n    }\n\n    return Q_spread([this, Q_all(args)], function Q_promised_spread(self, args) {\n      return callback.apply(self, args);\n    });\n  };\n};\n/**\n */\n\n\nQ.passByCopy = // TODO XXX experimental\nQ.push = function (value) {\n  if (Object(value) === value && !Q_isPromise(value)) {\n    passByCopies.set(value, true);\n  }\n\n  return value;\n};\n\nQ.isPortable = function (value) {\n  return Object(value) === value && passByCopies.has(value);\n};\n\nvar passByCopies = new WeakMap();\n/**\n * The async function is a decorator for generator functions, turning\n * them into asynchronous generators. Although generators are only\n * part of the newest ECMAScript 6 drafts, this code does not cause\n * syntax errors in older engines. This code should continue to work\n * and will in fact improve over time as the language improves.\n *\n * ES6 generators are currently part of V8 version 3.19 with the\n * `--harmony-generators` runtime flag enabled. This function does not\n * support the former, Pythonic generators that were only implemented\n * by SpiderMonkey.\n *\n * Decorates a generator function such that:\n *  - it may yield promises\n *  - execution will continue when that promise is fulfilled\n *  - the value of the yield expression will be the fulfilled value\n *  - it returns a promise for the return value (when the generator\n *    stops iterating)\n *  - the decorated function returns a promise for the return value\n *    of the generator or the first rejected promise among those\n *    yielded.\n *  - if an error is thrown in the generator, it propagates through\n *    every following yield until it is caught, or until it escapes\n *    the generator function altogether, and is translated into a\n *    rejection for the promise returned by the decorated generator.\n */\n\nQ.async = Q_async;\n\nfunction Q_async(makeGenerator) {\n  return function spawn() {\n    // when verb is \"send\", arg is a value\n    // when verb is \"throw\", arg is an exception\n    function continuer(verb, arg) {\n      var iteration;\n\n      try {\n        iteration = generator[verb](arg);\n      } catch (exception) {\n        return Q_reject(exception);\n      }\n\n      if (iteration.done) {\n        return Q(iteration.value);\n      } else {\n        return Q(iteration.value).then(callback, errback);\n      }\n    }\n\n    var generator = makeGenerator.apply(this, arguments);\n    var callback = continuer.bind(continuer, \"next\");\n    var errback = continuer.bind(continuer, \"throw\");\n    return callback();\n  };\n}\n/**\n * The spawn function is a small wrapper around async that immediately\n * calls the generator and also ends the promise chain, so that any\n * unhandled errors are thrown instead of forwarded to the error\n * handler. This is useful because it's extremely common to run\n * generators at the top-level to work with libraries.\n */\n\n\nQ.spawn = Q_spawn;\n\nfunction Q_spawn(makeGenerator) {\n  Q_async(makeGenerator)().done();\n} // Thus begins the section dedicated to the Promise\n\n/**\n * TODO\n */\n\n\nQ.Promise = Promise;\n\nfunction Promise(handler) {\n  if (!(this instanceof Promise)) {\n    return new Promise(handler);\n  }\n\n  if (typeof handler === \"function\") {\n    var setup = handler;\n    var deferred = defer();\n    handler = Q_getHandler(deferred.promise);\n\n    try {\n      setup(deferred.resolve, deferred.reject, deferred.setEstimate);\n    } catch (error) {\n      deferred.reject(error);\n    }\n  }\n\n  handlers.set(this, handler);\n}\n/**\n * Turns an array of promises into a promise for an array.  If any of the\n * promises gets rejected, the whole array is rejected immediately.\n * @param {Array.<Promise>} an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Promise.<Array>} a promise for an array of the corresponding values\n */\n\n\nPromise.all = Q_all;\n/**\n * Returns a promise for the first of an array of promises to become fulfilled.\n * @param answers {Array} promises to race\n * @returns {Promise} the first promise to be fulfilled\n */\n\nPromise.race = Q_race;\n/**\n * Coerces a value to a promise. If the value is a promise, pass it through\n * unaltered. If the value has a `then` method, it is presumed to be a promise\n * but not one of our own, so it is treated as a “thenable” promise and this\n * returns a promise that stands for it. Otherwise, this returns a promise that\n * has already been fulfilled with the value.\n * @param value promise, object with a then method, or a fulfillment value\n * @returns {Promise} the same promise as given, or a promise for the given\n * value\n */\n\nPromise.resolve = Promise_resolve;\n\nfunction Promise_resolve(value) {\n  return Q(value);\n}\n/**\n * Returns a promise that has been rejected with a reason, which should be an\n * instance of `Error`.\n * @param reason value describing the failure\n * @returns {Promise} rejection\n */\n\n\nPromise.reject = Q_reject;\n/**\n * @returns {boolean} whether the given value is a promise.\n */\n\nQ.isPromise = Q_isPromise;\n\nfunction Q_isPromise(object) {\n  return isObject(object) && !!handlers.get(object);\n}\n/**\n * @returns {boolean} whether the given value is an object with a then method.\n * @private\n */\n\n\nfunction isThenable(object) {\n  return isObject(object) && typeof object.then === \"function\";\n}\n/**\n * Synchronously produces a snapshot of the internal state of the promise.  The\n * object will have a `state` property. If the `state` is `\"pending\"`, there\n * will be no further information. If the `state` is `\"fulfilled\"`, there will\n * be a `value` property. If the state is `\"rejected\"` there will be a `reason`\n * property.  If the promise was constructed from a “thenable” and `then` nor\n * any other method has been dispatched on the promise has been called, the\n * state will be `\"pending\"`. The state object will not be updated if the\n * state changes and changing it will have no effect on the promise. Every\n * call to `inspect` produces a unique object.\n * @returns {{state: string, value?, reason?}}\n */\n\n\nPromise.prototype.inspect = function Promise_inspect() {\n  // the second layer captures only the relevant \"state\" properties of the\n  // handler to prevent leaking the capability to access or alter the\n  // handler.\n  return Q_getHandler(this).inspect();\n};\n/**\n * @returns {boolean} whether the promise is waiting for a result.\n */\n\n\nPromise.prototype.isPending = function Promise_isPending() {\n  return Q_getHandler(this).state === \"pending\";\n};\n/**\n * @returns {boolean} whether the promise has ended in a result and has a\n * fulfillment value.\n */\n\n\nPromise.prototype.isFulfilled = function Promise_isFulfilled() {\n  return Q_getHandler(this).state === \"fulfilled\";\n};\n/**\n * @returns {boolean} whether the promise has ended poorly and has a reason for\n * its rejection.\n */\n\n\nPromise.prototype.isRejected = function Promise_isRejected() {\n  return Q_getHandler(this).state === \"rejected\";\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.toBePassed = function Promise_toBePassed() {\n  return Q_getHandler(this).state === \"passed\";\n};\n/**\n * @returns {string} merely `\"[object Promise]\"`\n */\n\n\nPromise.prototype.toString = function Promise_toString() {\n  return \"[object Promise]\";\n};\n/**\n * Creates a new promise, waits for this promise to be resolved, and informs\n * either the fullfilled or rejected handler of the result. Whatever result\n * comes of the fulfilled or rejected handler, a value returned, a promise\n * returned, or an error thrown, becomes the resolution for the promise\n * returned by `then`.\n *\n * @param fulfilled\n * @param rejected\n * @returns {Promise} for the result of `fulfilled` or `rejected`.\n */\n\n\nPromise.prototype.then = function Promise_then(fulfilled, rejected, ms) {\n  var self = this;\n  var deferred = defer();\n\n  var _fulfilled;\n\n  if (typeof fulfilled === \"function\") {\n    _fulfilled = function Promise_then_fulfilled(value) {\n      try {\n        deferred.resolve(fulfilled.call(void 0, value));\n      } catch (error) {\n        deferred.reject(error);\n      }\n    };\n  } else {\n    _fulfilled = deferred.resolve;\n  }\n\n  var _rejected;\n\n  if (typeof rejected === \"function\") {\n    _rejected = function Promise_then_rejected(error) {\n      try {\n        deferred.resolve(rejected.call(void 0, error));\n      } catch (newError) {\n        deferred.reject(newError);\n      }\n    };\n  } else {\n    _rejected = deferred.reject;\n  }\n\n  this.done(_fulfilled, _rejected);\n\n  if (ms !== void 0) {\n    var updateEstimate = function Promise_then_updateEstimate() {\n      deferred.setEstimate(self.getEstimate() + ms);\n    };\n\n    this.observeEstimate(updateEstimate);\n    updateEstimate();\n  }\n\n  return deferred.promise;\n};\n/**\n * Terminates a chain of promises, forcing rejections to be\n * thrown as exceptions.\n * @param fulfilled\n * @param rejected\n */\n\n\nPromise.prototype.done = function Promise_done(fulfilled, rejected) {\n  var self = this;\n  var done = false; // ensure the untrusted promise makes at most a\n  // single call to one of the callbacks\n\n  asap(function Promise_done_task() {\n    var _fulfilled;\n\n    if (typeof fulfilled === \"function\") {\n      if (Q.onerror) {\n        _fulfilled = function Promise_done_fulfilled(value) {\n          if (done) {\n            return;\n          }\n\n          done = true;\n\n          try {\n            fulfilled.call(void 0, value);\n          } catch (error) {\n            // fallback to rethrow is still necessary because\n            // _fulfilled is not called in the same event as the\n            // above guard.\n            (Q.onerror || Promise_rethrow)(error);\n          }\n        };\n      } else {\n        _fulfilled = function Promise_done_fulfilled(value) {\n          if (done) {\n            return;\n          }\n\n          done = true;\n          fulfilled.call(void 0, value);\n        };\n      }\n    }\n\n    var _rejected;\n\n    if (typeof rejected === \"function\" && Q.onerror) {\n      _rejected = function Promise_done_rejected(error) {\n        if (done) {\n          return;\n        }\n\n        done = true;\n        makeStackTraceLong(error, self);\n\n        try {\n          rejected.call(void 0, error);\n        } catch (newError) {\n          (Q.onerror || Promise_rethrow)(newError);\n        }\n      };\n    } else if (typeof rejected === \"function\") {\n      _rejected = function Promise_done_rejected(error) {\n        if (done) {\n          return;\n        }\n\n        done = true;\n        makeStackTraceLong(error, self);\n        rejected.call(void 0, error);\n      };\n    } else {\n      _rejected = Q.onerror || Promise_rethrow;\n    }\n\n    if (typeof process === \"object\" && process.domain) {\n      _rejected = process.domain.bind(_rejected);\n    }\n\n    Q_getHandler(self).dispatch(_fulfilled, \"then\", [_rejected]);\n  });\n};\n\nfunction Promise_rethrow(error) {\n  throw error;\n}\n/**\n * TODO\n */\n\n\nPromise.prototype.thenResolve = function Promise_thenResolve(value) {\n  // Wrapping ahead of time to forestall multiple wrappers.\n  value = Q(value); // Using all is necessary to aggregate the estimated time to completion.\n\n  return Q_all([this, value]).then(function Promise_thenResolve_resolved() {\n    return value;\n  }, null, 0); // 0: does not contribute significantly to the estimated time to\n  // completion.\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.thenReject = function Promise_thenReject(error) {\n  return this.then(function Promise_thenReject_resolved() {\n    throw error;\n  }, null, 0); // 0: does not contribute significantly to the estimated time to\n  // completion.\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.all = function Promise_all() {\n  return this.then(Q_all);\n};\n/**\n * Turns an array of promises into a promise for an array of their states (as\n * returned by `inspect`) when they have all settled.\n * @param {Array[Any*]} values an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Array[State]} an array of states for the respective values.\n */\n\n\nPromise.prototype.allSettled = function Promise_allSettled() {\n  return this.then(Q_allSettled);\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.catch = function Promise_catch(rejected) {\n  return this.then(void 0, rejected);\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.finally = function Promise_finally(callback, ms) {\n  if (!callback) {\n    return this;\n  }\n\n  callback = Q(callback);\n  return this.then(function (value) {\n    return callback.call().then(function Promise_finally_fulfilled() {\n      return value;\n    });\n  }, function (reason) {\n    // TODO attempt to recycle the rejection with \"this\".\n    return callback.call().then(function Promise_finally_rejected() {\n      throw reason;\n    });\n  }, ms);\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.observeEstimate = function Promise_observeEstimate(emit) {\n  this.rawDispatch(null, \"estimate\", [emit]);\n  return this;\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.getEstimate = function Promise_getEstimate() {\n  return Q_getHandler(this).estimate;\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.dispatch = function Promise_dispatch(op, args) {\n  var deferred = defer();\n  this.rawDispatch(deferred.resolve, op, args);\n  return deferred.promise;\n};\n/**\n */\n\n\nPromise.prototype.rawDispatch = function Promise_rawDispatch(resolve, op, args) {\n  var self = this;\n  asap(function Promise_dispatch_task() {\n    Q_getHandler(self).dispatch(resolve, op, args);\n  });\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.get = function Promise_get(name) {\n  return this.dispatch(\"get\", [name]);\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.invoke = function Promise_invoke(name\n/*...args*/\n) {\n  var args = new Array(arguments.length - 1);\n\n  for (var index = 1; index < arguments.length; index++) {\n    args[index - 1] = arguments[index];\n  }\n\n  return this.dispatch(\"invoke\", [name, args]);\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.apply = function Promise_apply(thisp, args) {\n  return this.dispatch(\"call\", [args, thisp]);\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.call = function Promise_call(thisp\n/*, ...args*/\n) {\n  var args = new Array(Math.max(0, arguments.length - 1));\n\n  for (var index = 1; index < arguments.length; index++) {\n    args[index - 1] = arguments[index];\n  }\n\n  return this.dispatch(\"call\", [args, thisp]);\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.bind = function Promise_bind(thisp\n/*, ...args*/\n) {\n  var self = this;\n  var args = new Array(Math.max(0, arguments.length - 1));\n\n  for (var index = 1; index < arguments.length; index++) {\n    args[index - 1] = arguments[index];\n  }\n\n  return function Promise_bind_bound()\n  /*...args*/\n  {\n    var boundArgs = args.slice();\n\n    for (var index = 0; index < arguments.length; index++) {\n      boundArgs[boundArgs.length] = arguments[index];\n    }\n\n    return self.dispatch(\"call\", [boundArgs, thisp]);\n  };\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.keys = function Promise_keys() {\n  return this.dispatch(\"keys\", []);\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.iterate = function Promise_iterate() {\n  return this.dispatch(\"iterate\", []);\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.spread = function Promise_spread(fulfilled, rejected, ms) {\n  return this.all().then(function Promise_spread_fulfilled(array) {\n    return fulfilled.apply(void 0, array);\n  }, rejected, ms);\n};\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Number} milliseconds timeout\n * @param {String} custom error message (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */\n\n\nPromise.prototype.timeout = function Promsie_timeout(ms, message) {\n  var deferred = defer();\n  var timeoutId = setTimeout(function Promise_timeout_task() {\n    deferred.reject(new Error(message || \"Timed out after \" + ms + \" ms\"));\n  }, ms);\n  this.then(function Promise_timeout_fulfilled(value) {\n    clearTimeout(timeoutId);\n    deferred.resolve(value);\n  }, function Promise_timeout_rejected(error) {\n    clearTimeout(timeoutId);\n    deferred.reject(error);\n  });\n  return deferred.promise;\n};\n/**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */\n\n\nPromise.prototype.delay = function Promise_delay(ms) {\n  return this.then(function Promise_delay_fulfilled(value) {\n    var deferred = defer();\n    deferred.setEstimate(Date.now() + ms);\n    setTimeout(function Promise_delay_task() {\n      deferred.resolve(value);\n    }, ms);\n    return deferred.promise;\n  }, null, ms);\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.pull = function Promise_pull() {\n  return this.dispatch(\"pull\", []);\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.pass = function Promise_pass() {\n  if (!this.toBePassed()) {\n    return new Promise(new Passed(this));\n  } else {\n    return this;\n  }\n}; // Thus begins the portion dedicated to the deferred\n\n\nvar promises = new WeakMap();\n\nfunction Deferred(promise) {\n  this.promise = promise; // A deferred has an intrinsic promise, denoted by its hidden handler\n  // property.  The promise property of the deferred may be assigned to a\n  // different promise (as it is in a Queue), but the intrinsic promise does\n  // not change.\n\n  promises.set(this, promise);\n  var self = this;\n  var resolve = this.resolve;\n\n  this.resolve = function (value) {\n    resolve.call(self, value);\n  };\n\n  var reject = this.reject;\n\n  this.reject = function (error) {\n    reject.call(self, error);\n  };\n}\n/**\n * TODO\n */\n\n\nDeferred.prototype.resolve = function Deferred_resolve(value) {\n  var handler = Q_getHandler(promises.get(this));\n\n  if (!handler.messages) {\n    return;\n  }\n\n  handler.become(Q(value));\n};\n/**\n * TODO\n */\n\n\nDeferred.prototype.reject = function Deferred_reject(reason) {\n  var handler = Q_getHandler(promises.get(this));\n\n  if (!handler.messages) {\n    return;\n  }\n\n  handler.become(Q_reject(reason));\n};\n/**\n * TODO\n */\n\n\nDeferred.prototype.setEstimate = function Deferred_setEstimate(estimate) {\n  estimate = +estimate;\n\n  if (estimate !== estimate) {\n    estimate = Infinity;\n  }\n\n  if (estimate < 1e12 && estimate !== -Infinity) {\n    throw new Error(\"Estimate values should be a number of miliseconds in the future\");\n  }\n\n  var handler = Q_getHandler(promises.get(this)); // TODO There is a bit of capability leakage going on here. The Deferred\n  // should only be able to set the estimate for its original\n  // Pending, not for any handler that promise subsequently became.\n\n  if (handler.setEstimate) {\n    handler.setEstimate(estimate);\n  }\n}; // Thus ends the public interface\n// Thus begins the portion dedicated to handlers\n\n\nfunction Fulfilled(value) {\n  this.value = value;\n  this.estimate = Date.now();\n}\n\nFulfilled.prototype.state = \"fulfilled\";\n\nFulfilled.prototype.inspect = function Fulfilled_inspect() {\n  return {\n    state: \"fulfilled\",\n    value: this.value\n  };\n};\n\nFulfilled.prototype.dispatch = function Fulfilled_dispatch(resolve, op, operands) {\n  var result;\n\n  if (op === \"then\" || op === \"get\" || op === \"call\" || op === \"invoke\" || op === \"keys\" || op === \"iterate\" || op === \"pull\") {\n    try {\n      result = this[op].apply(this, operands);\n    } catch (exception) {\n      result = Q_reject(exception);\n    }\n  } else if (op === \"estimate\") {\n    operands[0].call(void 0, this.estimate);\n  } else {\n    var error = new Error(\"Fulfilled promises do not support the \" + op + \" operator\");\n    result = Q_reject(error);\n  }\n\n  if (resolve) {\n    resolve(result);\n  }\n};\n\nFulfilled.prototype.then = function Fulfilled_then() {\n  return this.value;\n};\n\nFulfilled.prototype.get = function Fulfilled_get(name) {\n  return this.value[name];\n};\n\nFulfilled.prototype.call = function Fulfilled_call(args, thisp) {\n  return this.callInvoke(this.value, args, thisp);\n};\n\nFulfilled.prototype.invoke = function Fulfilled_invoke(name, args) {\n  return this.callInvoke(this.value[name], args, this.value);\n};\n\nFulfilled.prototype.callInvoke = function Fulfilled_callInvoke(callback, args, thisp) {\n  var waitToBePassed;\n\n  for (var index = 0; index < args.length; index++) {\n    if (Q_isPromise(args[index]) && args[index].toBePassed()) {\n      waitToBePassed = waitToBePassed || [];\n      waitToBePassed.push(args[index]);\n    }\n  }\n\n  if (waitToBePassed) {\n    var self = this;\n    return Q_all(waitToBePassed).then(function () {\n      return self.callInvoke(callback, args.map(function (arg) {\n        if (Q_isPromise(arg) && arg.toBePassed()) {\n          return arg.inspect().value;\n        } else {\n          return arg;\n        }\n      }), thisp);\n    });\n  } else {\n    return callback.apply(thisp, args);\n  }\n};\n\nFulfilled.prototype.keys = function Fulfilled_keys() {\n  return Object.keys(this.value);\n};\n\nFulfilled.prototype.iterate = function Fulfilled_iterate() {\n  return iterate(this.value);\n};\n\nFulfilled.prototype.pull = function Fulfilled_pull() {\n  var result;\n\n  if (Object(this.value) === this.value) {\n    result = Array.isArray(this.value) ? [] : {};\n\n    for (var name in this.value) {\n      result[name] = this.value[name];\n    }\n  } else {\n    result = this.value;\n  }\n\n  return Q.push(result);\n};\n\nfunction Rejected(reason) {\n  this.reason = reason;\n  this.estimate = Infinity;\n}\n\nRejected.prototype.state = \"rejected\";\n\nRejected.prototype.inspect = function Rejected_inspect() {\n  return {\n    state: \"rejected\",\n    reason: this.reason\n  };\n};\n\nRejected.prototype.dispatch = function Rejected_dispatch(resolve, op, operands) {\n  var result;\n\n  if (op === \"then\") {\n    result = this.then(resolve, operands[0]);\n  } else {\n    result = this;\n  }\n\n  if (resolve) {\n    resolve(result);\n  }\n};\n\nRejected.prototype.then = function Rejected_then(resolve, rejected) {\n  return rejected ? rejected(this.reason) : this;\n};\n\nfunction Pending() {\n  // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n  // been resolved.  If it is \"undefined\", it has been resolved.  Each\n  // element of the messages array is itself an array of complete arguments to\n  // forward to the resolved promise.  We coerce the resolution value to a\n  // promise using the `resolve` function because it handles both fully\n  // non-thenable values and other thenables gracefully.\n  this.messages = [];\n  this.observers = [];\n  this.estimate = Infinity;\n}\n\nPending.prototype.state = \"pending\";\n\nPending.prototype.inspect = function Pending_inspect() {\n  return {\n    state: \"pending\"\n  };\n};\n\nPending.prototype.dispatch = function Pending_dispatch(resolve, op, operands) {\n  this.messages.push([resolve, op, operands]);\n\n  if (op === \"estimate\") {\n    this.observers.push(operands[0]);\n    var self = this;\n    asap(function Pending_dispatch_task() {\n      operands[0].call(void 0, self.estimate);\n    });\n  }\n};\n\nPending.prototype.become = function Pending_become(promise) {\n  this.became = theViciousCycle;\n  var handler = Q_getHandler(promise);\n  this.became = handler;\n  handlers.set(promise, handler);\n  this.promise = void 0;\n  this.messages.forEach(function Pending_become_eachMessage(message) {\n    // makeQ does not have this asap call, so it must be queueing events\n    // downstream. TODO look at makeQ to ascertain\n    asap(function Pending_become_eachMessage_task() {\n      var handler = Q_getHandler(promise);\n      handler.dispatch.apply(handler, message);\n    });\n  });\n  this.messages = void 0;\n  this.observers = void 0;\n};\n\nPending.prototype.setEstimate = function Pending_setEstimate(estimate) {\n  if (this.observers) {\n    var self = this;\n    self.estimate = estimate;\n    this.observers.forEach(function Pending_eachObserver(observer) {\n      asap(function Pending_setEstimate_eachObserver_task() {\n        observer.call(void 0, estimate);\n      });\n    });\n  }\n};\n\nfunction Thenable(thenable) {\n  this.thenable = thenable;\n  this.became = null;\n  this.estimate = Infinity;\n}\n\nThenable.prototype.state = \"thenable\";\n\nThenable.prototype.inspect = function Thenable_inspect() {\n  return {\n    state: \"pending\"\n  };\n};\n\nThenable.prototype.cast = function Thenable_cast() {\n  if (!this.became) {\n    var deferred = defer();\n    var thenable = this.thenable;\n    asap(function Thenable_cast_task() {\n      try {\n        thenable.then(deferred.resolve, deferred.reject);\n      } catch (exception) {\n        deferred.reject(exception);\n      }\n    });\n    this.became = Q_getHandler(deferred.promise);\n  }\n\n  return this.became;\n};\n\nThenable.prototype.dispatch = function Thenable_dispatch(resolve, op, args) {\n  this.cast().dispatch(resolve, op, args);\n};\n\nfunction Passed(promise) {\n  this.promise = promise;\n}\n\nPassed.prototype.state = \"passed\";\n\nPassed.prototype.inspect = function Passed_inspect() {\n  return this.promise.inspect();\n};\n\nPassed.prototype.dispatch = function Passed_dispatch(resolve, op, args) {\n  return this.promise.rawDispatch(resolve, op, args);\n}; // Thus begins the Q Node.js bridge\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback, forwarding the given variadic arguments, plus a provided\n * callback argument.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param ...args arguments to pass to the method; the callback will\n * be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\n\n\nQ.ninvoke = function Q_ninvoke(object, name\n/*...args*/\n) {\n  var args = new Array(Math.max(0, arguments.length - 1));\n\n  for (var index = 2; index < arguments.length; index++) {\n    args[index - 2] = arguments[index];\n  }\n\n  var deferred = Q.defer();\n  args[index - 2] = deferred.makeNodeResolver();\n  Q(object).dispatch(\"invoke\", [name, args]).catch(deferred.reject);\n  return deferred.promise;\n};\n\nPromise.prototype.ninvoke = function Promise_ninvoke(name\n/*...args*/\n) {\n  var args = new Array(arguments.length);\n\n  for (var index = 1; index < arguments.length; index++) {\n    args[index - 1] = arguments[index];\n  }\n\n  var deferred = Q.defer();\n  args[index - 1] = deferred.makeNodeResolver();\n  this.dispatch(\"invoke\", [name, args]).catch(deferred.reject);\n  return deferred.promise;\n};\n/**\n * Wraps a Node.js continuation passing function and returns an equivalent\n * version that returns a promise.\n * @example\n * Q.denodeify(FS.readFile)(__filename, \"utf-8\")\n * .then(console.log)\n * .done()\n */\n\n\nQ.denodeify = function Q_denodeify(callback, pattern) {\n  return function denodeified() {\n    var args = new Array(arguments.length + 1);\n    var index = 0;\n\n    for (; index < arguments.length; index++) {\n      args[index] = arguments[index];\n    }\n\n    var deferred = Q.defer();\n    args[index] = deferred.makeNodeResolver(pattern);\n    Q(callback).apply(this, args).catch(deferred.reject);\n    return deferred.promise;\n  };\n};\n/**\n * Creates a Node.js-style callback that will resolve or reject the deferred\n * promise.\n * @param unpack `true` means that the Node.js-style-callback accepts a\n * fixed or variable number of arguments and that the deferred should be resolved\n * with an array of these value arguments, or rejected with the error argument.\n * An array of names means that the Node.js-style-callback accepts a fixed\n * number of arguments, and that the resolution should be an object with\n * properties corresponding to the given names and respective value arguments.\n * @returns a nodeback\n */\n\n\nDeferred.prototype.makeNodeResolver = function (unpack) {\n  var resolve = this.resolve;\n\n  if (unpack === true) {\n    return function variadicNodebackToResolver(error) {\n      if (error) {\n        resolve(Q_reject(error));\n      } else {\n        var value = new Array(Math.max(0, arguments.length - 1));\n\n        for (var index = 1; index < arguments.length; index++) {\n          value[index - 1] = arguments[index];\n        }\n\n        resolve(value);\n      }\n    };\n  } else if (unpack) {\n    return function namedArgumentNodebackToResolver(error) {\n      if (error) {\n        resolve(Q_reject(error));\n      } else {\n        var value = {};\n\n        for (var index = 0; index < unpack.length; index++) {\n          value[unpack[index]] = arguments[index + 1];\n        }\n\n        resolve(value);\n      }\n    };\n  } else {\n    return function nodebackToResolver(error, value) {\n      if (error) {\n        resolve(Q_reject(error));\n      } else {\n        resolve(value);\n      }\n    };\n  }\n};\n/**\n * TODO\n */\n\n\nPromise.prototype.nodeify = function Promise_nodeify(nodeback) {\n  if (nodeback) {\n    this.done(function (value) {\n      nodeback(null, value);\n    }, nodeback);\n  } else {\n    return this;\n  }\n}; // DEPRECATED\n\n\nQ.nextTick = deprecate(asap, \"nextTick\", \"asap package\");\nQ.resolve = deprecate(Q, \"resolve\", \"Q\");\nQ.fulfill = deprecate(Q, \"fulfill\", \"Q\");\nQ.isPromiseAlike = deprecate(isThenable, \"isPromiseAlike\", \"(not supported)\");\nQ.fail = deprecate(function (value, rejected) {\n  return Q(value).catch(rejected);\n}, \"Q.fail\", \"Q(value).catch\");\nQ.fin = deprecate(function (value, regardless) {\n  return Q(value).finally(regardless);\n}, \"Q.fin\", \"Q(value).finally\");\nQ.progress = deprecate(function (value) {\n  return value;\n}, \"Q.progress\", \"no longer supported\");\nQ.thenResolve = deprecate(function (promise, value) {\n  return Q(promise).thenResolve(value);\n}, \"thenResolve\", \"Q(value).thenResolve\");\nQ.thenReject = deprecate(function (promise, reason) {\n  return Q(promise).thenResolve(reason);\n}, \"thenResolve\", \"Q(value).thenResolve\");\nQ.isPending = deprecate(function (value) {\n  return Q(value).isPending();\n}, \"isPending\", \"Q(value).isPending\");\nQ.isFulfilled = deprecate(function (value) {\n  return Q(value).isFulfilled();\n}, \"isFulfilled\", \"Q(value).isFulfilled\");\nQ.isRejected = deprecate(function (value) {\n  return Q(value).isRejected();\n}, \"isRejected\", \"Q(value).isRejected\");\nQ.master = deprecate(function (value) {\n  return value;\n}, \"master\", \"no longer necessary\");\n\nQ.makePromise = function () {\n  throw new Error(\"makePromise is no longer supported\");\n};\n\nQ.dispatch = deprecate(function (value, op, operands) {\n  return Q(value).dispatch(op, operands);\n}, \"dispatch\", \"Q(value).dispatch\");\nQ.get = deprecate(function (object, name) {\n  return Q(object).get(name);\n}, \"get\", \"Q(value).get\");\nQ.keys = deprecate(function (object) {\n  return Q(object).keys();\n}, \"keys\", \"Q(value).keys\");\nQ.post = deprecate(function (object, name, args) {\n  return Q(object).post(name, args);\n}, \"post\", \"Q(value).invoke (spread arguments)\");\nQ.mapply = deprecate(function (object, name, args) {\n  return Q(object).post(name, args);\n}, \"post\", \"Q(value).invoke (spread arguments)\");\nQ.send = deprecate(function (object, name) {\n  return Q(object).post(name, Array.prototype.slice.call(arguments, 2));\n}, \"send\", \"Q(value).invoke\");\n\nQ.set = function () {\n  throw new Error(\"Q.set no longer supported\");\n};\n\nQ.delete = function () {\n  throw new Error(\"Q.delete no longer supported\");\n};\n\nQ.nearer = deprecate(function (value) {\n  if (Q_isPromise(value) && value.isFulfilled()) {\n    return value.inspect().value;\n  } else {\n    return value;\n  }\n}, \"nearer\", \"inspect().value (+nuances)\");\nQ.fapply = deprecate(function (callback, args) {\n  return Q(callback).dispatch(\"call\", [args]);\n}, \"fapply\", \"Q(callback).apply(thisp, args)\");\nQ.fcall = deprecate(function (callback\n/*, ...args*/\n) {\n  return Q(callback).dispatch(\"call\", [Array.prototype.slice.call(arguments, 1)]);\n}, \"fcall\", \"Q(callback).call(thisp, ...args)\");\nQ.fbind = deprecate(function (object\n/*...args*/\n) {\n  var promise = Q(object);\n  var args = Array.prototype.slice.call(arguments, 1);\n  return function fbound() {\n    return promise.dispatch(\"call\", [args.concat(Array.prototype.slice.call(arguments)), this]);\n  };\n}, \"fbind\", \"bind with thisp\");\nQ.promise = deprecate(Promise, \"promise\", \"Promise\");\nPromise.prototype.fapply = deprecate(function (args) {\n  return this.dispatch(\"call\", [args]);\n}, \"fapply\", \"apply with thisp\");\nPromise.prototype.fcall = deprecate(function ()\n/*...args*/\n{\n  return this.dispatch(\"call\", [Array.prototype.slice.call(arguments)]);\n}, \"fcall\", \"try or call with thisp\");\nPromise.prototype.fail = deprecate(function (rejected) {\n  return this.catch(rejected);\n}, \"fail\", \"catch\");\nPromise.prototype.fin = deprecate(function (regardless) {\n  return this.finally(regardless);\n}, \"fin\", \"finally\");\n\nPromise.prototype.set = function () {\n  throw new Error(\"Promise set no longer supported\");\n};\n\nPromise.prototype.delete = function () {\n  throw new Error(\"Promise delete no longer supported\");\n};\n\nDeferred.prototype.notify = deprecate(function () {}, \"notify\", \"no longer supported\");\nPromise.prototype.progress = deprecate(function () {\n  return this;\n}, \"progress\", \"no longer supported\"); // alternative proposed by Redsandro, dropped in favor of post to streamline\n// the interface\n\nPromise.prototype.mapply = deprecate(function (name, args) {\n  return this.dispatch(\"invoke\", [name, args]);\n}, \"mapply\", \"invoke\");\nPromise.prototype.fbind = deprecate(function () {\n  return Q.fbind.apply(Q, [void 0].concat(Array.prototype.slice.call(arguments)));\n}, \"fbind\", \"bind(thisp, ...args)\"); // alternative proposed by Mark Miller, dropped in favor of invoke\n\nPromise.prototype.send = deprecate(function () {\n  return this.dispatch(\"invoke\", [name, Array.prototype.slice.call(arguments, 1)]);\n}, \"send\", \"invoke\"); // alternative proposed by Redsandro, dropped in favor of invoke\n\nPromise.prototype.mcall = deprecate(function () {\n  return this.dispatch(\"invoke\", [name, Array.prototype.slice.call(arguments, 1)]);\n}, \"mcall\", \"invoke\");\nPromise.prototype.passByCopy = deprecate(function (value) {\n  return value;\n}, \"passByCopy\", \"Q.passByCopy\"); // Deprecated Node.js bridge promise methods\n\nQ.nfapply = deprecate(function (callback, args) {\n  var deferred = Q.defer();\n  var nodeArgs = Array.prototype.slice.call(args);\n  nodeArgs.push(deferred.makeNodeResolver());\n  Q(callback).apply(this, nodeArgs).catch(deferred.reject);\n  return deferred.promise;\n}, \"nfapply\");\nPromise.prototype.nfapply = deprecate(function (args) {\n  return Q.nfapply(this, args);\n}, \"nfapply\");\nQ.nfcall = deprecate(function (callback\n/*...args*/\n) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return Q.nfapply(callback, args);\n}, \"nfcall\");\nPromise.prototype.nfcall = deprecate(function () {\n  var args = new Array(arguments.length);\n\n  for (var index = 0; index < arguments.length; index++) {\n    args[index] = arguments[index];\n  }\n\n  return Q.nfapply(this, args);\n}, \"nfcall\");\nQ.nfbind = deprecate(function (callback\n/*...args*/\n) {\n  var baseArgs = Array.prototype.slice.call(arguments, 1);\n  return function () {\n    var nodeArgs = baseArgs.concat(Array.prototype.slice.call(arguments));\n    var deferred = Q.defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    Q(callback).apply(this, nodeArgs).catch(deferred.reject);\n    return deferred.promise;\n  };\n}, \"nfbind\", \"denodeify (with caveats)\");\nPromise.prototype.nfbind = deprecate(function () {\n  var args = new Array(arguments.length);\n\n  for (var index = 0; index < arguments.length; index++) {\n    args[index] = arguments[index];\n  }\n\n  return Q.nfbind(this, args);\n}, \"nfbind\", \"denodeify (with caveats)\");\nQ.nbind = deprecate(function (callback, thisp\n/*...args*/\n) {\n  var baseArgs = Array.prototype.slice.call(arguments, 2);\n  return function () {\n    var nodeArgs = baseArgs.concat(Array.prototype.slice.call(arguments));\n    var deferred = Q.defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n\n    function bound() {\n      return callback.apply(thisp, arguments);\n    }\n\n    Q(bound).apply(this, nodeArgs).catch(deferred.reject);\n    return deferred.promise;\n  };\n}, \"nbind\", \"denodeify (with caveats)\");\nQ.npost = deprecate(function (object, name, nodeArgs) {\n  var deferred = Q.defer();\n  nodeArgs.push(deferred.makeNodeResolver());\n  Q(object).dispatch(\"invoke\", [name, nodeArgs]).catch(deferred.reject);\n  return deferred.promise;\n}, \"npost\", \"ninvoke (with spread arguments)\");\nPromise.prototype.npost = deprecate(function (name, args) {\n  return Q.npost(this, name, args);\n}, \"npost\", \"Q.ninvoke (with caveats)\");\nQ.nmapply = deprecate(Q.nmapply, \"nmapply\", \"q/node nmapply\");\nPromise.prototype.nmapply = deprecate(Promise.prototype.npost, \"nmapply\", \"Q.nmapply\");\nQ.nsend = deprecate(Q.ninvoke, \"nsend\", \"q/node ninvoke\");\nQ.nmcall = deprecate(Q.ninvoke, \"nmcall\", \"q/node ninvoke\");\nPromise.prototype.nsend = deprecate(Promise.prototype.ninvoke, \"nsend\", \"q/node ninvoke\");\nPromise.prototype.nmcall = deprecate(Promise.prototype.ninvoke, \"nmcall\", \"q/node ninvoke\"); // All code before this point will be filtered from stack traces.\n\nvar qEndingLine = captureLine();","map":null,"metadata":{},"sourceType":"script"}