{"ast":null,"code":"var _classCallCheck = require(\"C:\\\\Users\\\\Admin\\\\Desktop\\\\react1\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Admin\\\\Desktop\\\\react1\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\n// Generated by CoffeeScript 2.4.1\n(function () {\n  var NodeType,\n      WriterState,\n      XMLAttribute,\n      XMLCData,\n      XMLComment,\n      XMLDTDAttList,\n      XMLDTDElement,\n      XMLDTDEntity,\n      XMLDTDNotation,\n      XMLDeclaration,\n      XMLDocType,\n      XMLDocument,\n      XMLDocumentCB,\n      XMLElement,\n      XMLProcessingInstruction,\n      XMLRaw,\n      XMLStringWriter,\n      XMLStringifier,\n      XMLText,\n      getValue,\n      isFunction,\n      isObject,\n      isPlainObject,\n      hasProp = {}.hasOwnProperty;\n\n  var _require = require('./Utility');\n\n  isObject = _require.isObject;\n  isFunction = _require.isFunction;\n  isPlainObject = _require.isPlainObject;\n  getValue = _require.getValue;\n  NodeType = require('./NodeType');\n  XMLDocument = require('./XMLDocument');\n  XMLElement = require('./XMLElement');\n  XMLCData = require('./XMLCData');\n  XMLComment = require('./XMLComment');\n  XMLRaw = require('./XMLRaw');\n  XMLText = require('./XMLText');\n  XMLProcessingInstruction = require('./XMLProcessingInstruction');\n  XMLDeclaration = require('./XMLDeclaration');\n  XMLDocType = require('./XMLDocType');\n  XMLDTDAttList = require('./XMLDTDAttList');\n  XMLDTDEntity = require('./XMLDTDEntity');\n  XMLDTDElement = require('./XMLDTDElement');\n  XMLDTDNotation = require('./XMLDTDNotation');\n  XMLAttribute = require('./XMLAttribute');\n  XMLStringifier = require('./XMLStringifier');\n  XMLStringWriter = require('./XMLStringWriter');\n  WriterState = require('./WriterState'); // Represents an XML builder\n\n  module.exports = XMLDocumentCB = /*#__PURE__*/function () {\n    \"use strict\";\n\n    // Initializes a new instance of `XMLDocumentCB`\n    // `options.keepNullNodes` whether nodes with null values will be kept\n    //     or ignored: true or false\n    // `options.keepNullAttributes` whether attributes with null values will be\n    //     kept or ignored: true or false\n    // `options.ignoreDecorators` whether decorator strings will be ignored when\n    //     converting JS objects: true or false\n    // `options.separateArrayItems` whether array items are created as separate\n    //     nodes when passed as an object value: true or false\n    // `options.noDoubleEncoding` whether existing html entities are encoded:\n    //     true or false\n    // `options.stringify` a set of functions to use for converting values to\n    //     strings\n    // `options.writer` the default XML writer to use for converting nodes to\n    //     string. If the default writer is not set, the built-in XMLStringWriter\n    //     will be used instead.\n    // `onData` the function to be called when a new chunk of XML is output. The\n    //          string containing the XML chunk is passed to `onData` as its first\n    //          argument, and the current indentation level as its second argument.\n    // `onEnd`  the function to be called when the XML document is completed with\n    //          `end`. `onEnd` does not receive any arguments.\n    function XMLDocumentCB(options, onData, onEnd) {\n      _classCallCheck(this, XMLDocumentCB);\n\n      var writerOptions;\n      this.name = \"?xml\";\n      this.type = NodeType.Document;\n      options || (options = {});\n      writerOptions = {};\n\n      if (!options.writer) {\n        options.writer = new XMLStringWriter();\n      } else if (isPlainObject(options.writer)) {\n        writerOptions = options.writer;\n        options.writer = new XMLStringWriter();\n      }\n\n      this.options = options;\n      this.writer = options.writer;\n      this.writerOptions = this.writer.filterOptions(writerOptions);\n      this.stringify = new XMLStringifier(options);\n\n      this.onDataCallback = onData || function () {};\n\n      this.onEndCallback = onEnd || function () {};\n\n      this.currentNode = null;\n      this.currentLevel = -1;\n      this.openTags = {};\n      this.documentStarted = false;\n      this.documentCompleted = false;\n      this.root = null;\n    } // Creates a child element node from the given XMLNode\n    // `node` the child node\n\n\n    _createClass(XMLDocumentCB, [{\n      key: \"createChildNode\",\n      value: function createChildNode(node) {\n        var att, attName, attributes, child, i, len, ref, ref1;\n\n        switch (node.type) {\n          case NodeType.CData:\n            this.cdata(node.value);\n            break;\n\n          case NodeType.Comment:\n            this.comment(node.value);\n            break;\n\n          case NodeType.Element:\n            attributes = {};\n            ref = node.attribs;\n\n            for (attName in ref) {\n              if (!hasProp.call(ref, attName)) continue;\n              att = ref[attName];\n              attributes[attName] = att.value;\n            }\n\n            this.node(node.name, attributes);\n            break;\n\n          case NodeType.Dummy:\n            this.dummy();\n            break;\n\n          case NodeType.Raw:\n            this.raw(node.value);\n            break;\n\n          case NodeType.Text:\n            this.text(node.value);\n            break;\n\n          case NodeType.ProcessingInstruction:\n            this.instruction(node.target, node.value);\n            break;\n\n          default:\n            throw new Error(\"This XML node type is not supported in a JS object: \" + node.constructor.name);\n        }\n\n        ref1 = node.children; // write child nodes recursively\n\n        for (i = 0, len = ref1.length; i < len; i++) {\n          child = ref1[i];\n          this.createChildNode(child);\n\n          if (child.type === NodeType.Element) {\n            this.up();\n          }\n        }\n\n        return this;\n      } // Creates a dummy node\n\n    }, {\n      key: \"dummy\",\n      value: function dummy() {\n        // no-op, just return this\n        return this;\n      } // Creates a node\n      // `name` name of the node\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n\n    }, {\n      key: \"node\",\n      value: function node(name, attributes, text) {\n        if (name == null) {\n          throw new Error(\"Missing node name.\");\n        }\n\n        if (this.root && this.currentLevel === -1) {\n          throw new Error(\"Document can only have one root node. \" + this.debugInfo(name));\n        }\n\n        this.openCurrent();\n        name = getValue(name);\n\n        if (attributes == null) {\n          attributes = {};\n        }\n\n        attributes = getValue(attributes); // swap argument order: text <-> attributes\n\n        if (!isObject(attributes)) {\n          var _ref = [attributes, text];\n          text = _ref[0];\n          attributes = _ref[1];\n        }\n\n        this.currentNode = new XMLElement(this, name, attributes);\n        this.currentNode.children = false;\n        this.currentLevel++;\n        this.openTags[this.currentLevel] = this.currentNode;\n\n        if (text != null) {\n          this.text(text);\n        }\n\n        return this;\n      } // Creates a child element node or an element type declaration when called\n      // inside the DTD\n      // `name` name of the node\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n\n    }, {\n      key: \"element\",\n      value: function element(name, attributes, text) {\n        var child, i, len, oldValidationFlag, ref, root;\n\n        if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n          this.dtdElement.apply(this, arguments);\n        } else {\n          if (Array.isArray(name) || isObject(name) || isFunction(name)) {\n            oldValidationFlag = this.options.noValidation;\n            this.options.noValidation = true;\n            root = new XMLDocument(this.options).element('TEMP_ROOT');\n            root.element(name);\n            this.options.noValidation = oldValidationFlag;\n            ref = root.children;\n\n            for (i = 0, len = ref.length; i < len; i++) {\n              child = ref[i];\n              this.createChildNode(child);\n\n              if (child.type === NodeType.Element) {\n                this.up();\n              }\n            }\n          } else {\n            this.node(name, attributes, text);\n          }\n        }\n\n        return this;\n      } // Adds or modifies an attribute\n      // `name` attribute name\n      // `value` attribute value\n\n    }, {\n      key: \"attribute\",\n      value: function attribute(name, value) {\n        var attName, attValue;\n\n        if (!this.currentNode || this.currentNode.children) {\n          throw new Error(\"att() can only be used immediately after an ele() call in callback mode. \" + this.debugInfo(name));\n        }\n\n        if (name != null) {\n          name = getValue(name);\n        }\n\n        if (isObject(name)) {\n          // expand if object\n          for (attName in name) {\n            if (!hasProp.call(name, attName)) continue;\n            attValue = name[attName];\n            this.attribute(attName, attValue);\n          }\n        } else {\n          if (isFunction(value)) {\n            value = value.apply();\n          }\n\n          if (this.options.keepNullAttributes && value == null) {\n            this.currentNode.attribs[name] = new XMLAttribute(this, name, \"\");\n          } else if (value != null) {\n            this.currentNode.attribs[name] = new XMLAttribute(this, name, value);\n          }\n        }\n\n        return this;\n      } // Creates a text node\n      // `value` element text\n\n    }, {\n      key: \"text\",\n      value: function text(value) {\n        var node;\n        this.openCurrent();\n        node = new XMLText(this, value);\n        this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n        return this;\n      } // Creates a CDATA node\n      // `value` element text without CDATA delimiters\n\n    }, {\n      key: \"cdata\",\n      value: function cdata(value) {\n        var node;\n        this.openCurrent();\n        node = new XMLCData(this, value);\n        this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n        return this;\n      } // Creates a comment node\n      // `value` comment text\n\n    }, {\n      key: \"comment\",\n      value: function comment(value) {\n        var node;\n        this.openCurrent();\n        node = new XMLComment(this, value);\n        this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n        return this;\n      } // Adds unescaped raw text\n      // `value` text\n\n    }, {\n      key: \"raw\",\n      value: function raw(value) {\n        var node;\n        this.openCurrent();\n        node = new XMLRaw(this, value);\n        this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n        return this;\n      } // Adds a processing instruction\n      // `target` instruction target\n      // `value` instruction value\n\n    }, {\n      key: \"instruction\",\n      value: function instruction(target, value) {\n        var i, insTarget, insValue, len, node;\n        this.openCurrent();\n\n        if (target != null) {\n          target = getValue(target);\n        }\n\n        if (value != null) {\n          value = getValue(value);\n        }\n\n        if (Array.isArray(target)) {\n          // expand if array\n          for (i = 0, len = target.length; i < len; i++) {\n            insTarget = target[i];\n            this.instruction(insTarget);\n          }\n        } else if (isObject(target)) {\n          // expand if object\n          for (insTarget in target) {\n            if (!hasProp.call(target, insTarget)) continue;\n            insValue = target[insTarget];\n            this.instruction(insTarget, insValue);\n          }\n        } else {\n          if (isFunction(value)) {\n            value = value.apply();\n          }\n\n          node = new XMLProcessingInstruction(this, target, value);\n          this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n        }\n\n        return this;\n      } // Creates the xml declaration\n      // `version` A version number string, e.g. 1.0\n      // `encoding` Encoding declaration, e.g. UTF-8\n      // `standalone` standalone document declaration: true or false\n\n    }, {\n      key: \"declaration\",\n      value: function declaration(version, encoding, standalone) {\n        var node;\n        this.openCurrent();\n\n        if (this.documentStarted) {\n          throw new Error(\"declaration() must be the first node.\");\n        }\n\n        node = new XMLDeclaration(this, version, encoding, standalone);\n        this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n        return this;\n      } // Creates the document type declaration\n      // `root`  the name of the root node\n      // `pubID` the public identifier of the external subset\n      // `sysID` the system identifier of the external subset\n\n    }, {\n      key: \"doctype\",\n      value: function doctype(root, pubID, sysID) {\n        this.openCurrent();\n\n        if (root == null) {\n          throw new Error(\"Missing root node name.\");\n        }\n\n        if (this.root) {\n          throw new Error(\"dtd() must come before the root node.\");\n        }\n\n        this.currentNode = new XMLDocType(this, pubID, sysID);\n        this.currentNode.rootNodeName = root;\n        this.currentNode.children = false;\n        this.currentLevel++;\n        this.openTags[this.currentLevel] = this.currentNode;\n        return this;\n      } // Creates an element type declaration\n      // `name` element name\n      // `value` element content (defaults to #PCDATA)\n\n    }, {\n      key: \"dtdElement\",\n      value: function dtdElement(name, value) {\n        var node;\n        this.openCurrent();\n        node = new XMLDTDElement(this, name, value);\n        this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n        return this;\n      } // Creates an attribute declaration\n      // `elementName` the name of the element containing this attribute\n      // `attributeName` attribute name\n      // `attributeType` type of the attribute (defaults to CDATA)\n      // `defaultValueType` default value type (either #REQUIRED, #IMPLIED, #FIXED or\n      //                    #DEFAULT) (defaults to #IMPLIED)\n      // `defaultValue` default value of the attribute\n      //                (only used for #FIXED or #DEFAULT)\n\n    }, {\n      key: \"attList\",\n      value: function attList(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n        var node;\n        this.openCurrent();\n        node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);\n        this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n        return this;\n      } // Creates a general entity declaration\n      // `name` the name of the entity\n      // `value` internal entity value or an object with external entity details\n      // `value.pubID` public identifier\n      // `value.sysID` system identifier\n      // `value.nData` notation declaration\n\n    }, {\n      key: \"entity\",\n      value: function entity(name, value) {\n        var node;\n        this.openCurrent();\n        node = new XMLDTDEntity(this, false, name, value);\n        this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n        return this;\n      } // Creates a parameter entity declaration\n      // `name` the name of the entity\n      // `value` internal entity value or an object with external entity details\n      // `value.pubID` public identifier\n      // `value.sysID` system identifier\n\n    }, {\n      key: \"pEntity\",\n      value: function pEntity(name, value) {\n        var node;\n        this.openCurrent();\n        node = new XMLDTDEntity(this, true, name, value);\n        this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n        return this;\n      } // Creates a NOTATION declaration\n      // `name` the name of the notation\n      // `value` an object with external entity details\n      // `value.pubID` public identifier\n      // `value.sysID` system identifier\n\n    }, {\n      key: \"notation\",\n      value: function notation(name, value) {\n        var node;\n        this.openCurrent();\n        node = new XMLDTDNotation(this, name, value);\n        this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n        return this;\n      } // Gets the parent node\n\n    }, {\n      key: \"up\",\n      value: function up() {\n        if (this.currentLevel < 0) {\n          throw new Error(\"The document node has no parent.\");\n        }\n\n        if (this.currentNode) {\n          if (this.currentNode.children) {\n            this.closeNode(this.currentNode);\n          } else {\n            this.openNode(this.currentNode);\n          }\n\n          this.currentNode = null;\n        } else {\n          this.closeNode(this.openTags[this.currentLevel]);\n        }\n\n        delete this.openTags[this.currentLevel];\n        this.currentLevel--;\n        return this;\n      } // Ends the document\n\n    }, {\n      key: \"end\",\n      value: function end() {\n        while (this.currentLevel >= 0) {\n          this.up();\n        }\n\n        return this.onEnd();\n      } // Opens the current parent node\n\n    }, {\n      key: \"openCurrent\",\n      value: function openCurrent() {\n        if (this.currentNode) {\n          this.currentNode.children = true;\n          return this.openNode(this.currentNode);\n        }\n      } // Writes the opening tag of the current node or the entire node if it has\n      // no child nodes\n\n    }, {\n      key: \"openNode\",\n      value: function openNode(node) {\n        var att, chunk, name, ref;\n\n        if (!node.isOpen) {\n          if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {\n            this.root = node;\n          }\n\n          chunk = '';\n\n          if (node.type === NodeType.Element) {\n            this.writerOptions.state = WriterState.OpenTag;\n            chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<' + node.name;\n            ref = node.attribs;\n\n            for (name in ref) {\n              if (!hasProp.call(ref, name)) continue;\n              att = ref[name];\n              chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);\n            }\n\n            chunk += (node.children ? '>' : '/>') + this.writer.endline(node, this.writerOptions, this.currentLevel);\n            this.writerOptions.state = WriterState.InsideTag; // if node.type is NodeType.DocType\n          } else {\n            this.writerOptions.state = WriterState.OpenTag;\n            chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<!DOCTYPE ' + node.rootNodeName; // external identifier\n\n            if (node.pubID && node.sysID) {\n              chunk += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n            } else if (node.sysID) {\n              chunk += ' SYSTEM \"' + node.sysID + '\"';\n            } // internal subset\n\n\n            if (node.children) {\n              chunk += ' [';\n              this.writerOptions.state = WriterState.InsideTag;\n            } else {\n              this.writerOptions.state = WriterState.CloseTag;\n              chunk += '>';\n            }\n\n            chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);\n          }\n\n          this.onData(chunk, this.currentLevel);\n          return node.isOpen = true;\n        }\n      } // Writes the closing tag of the current node\n\n    }, {\n      key: \"closeNode\",\n      value: function closeNode(node) {\n        var chunk;\n\n        if (!node.isClosed) {\n          chunk = '';\n          this.writerOptions.state = WriterState.CloseTag;\n\n          if (node.type === NodeType.Element) {\n            chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '</' + node.name + '>' + this.writer.endline(node, this.writerOptions, this.currentLevel); // if node.type is NodeType.DocType\n          } else {\n            chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + ']>' + this.writer.endline(node, this.writerOptions, this.currentLevel);\n          }\n\n          this.writerOptions.state = WriterState.None;\n          this.onData(chunk, this.currentLevel);\n          return node.isClosed = true;\n        }\n      } // Called when a new chunk of XML is output\n      // `chunk` a string containing the XML chunk\n      // `level` current indentation level\n\n    }, {\n      key: \"onData\",\n      value: function onData(chunk, level) {\n        this.documentStarted = true;\n        return this.onDataCallback(chunk, level + 1);\n      } // Called when the XML document is completed\n\n    }, {\n      key: \"onEnd\",\n      value: function onEnd() {\n        this.documentCompleted = true;\n        return this.onEndCallback();\n      } // Returns debug string\n\n    }, {\n      key: \"debugInfo\",\n      value: function debugInfo(name) {\n        if (name == null) {\n          return \"\";\n        } else {\n          return \"node: <\" + name + \">\";\n        }\n      } // Node aliases\n\n    }, {\n      key: \"ele\",\n      value: function ele() {\n        return this.element.apply(this, arguments);\n      }\n    }, {\n      key: \"nod\",\n      value: function nod(name, attributes, text) {\n        return this.node(name, attributes, text);\n      }\n    }, {\n      key: \"txt\",\n      value: function txt(value) {\n        return this.text(value);\n      }\n    }, {\n      key: \"dat\",\n      value: function dat(value) {\n        return this.cdata(value);\n      }\n    }, {\n      key: \"com\",\n      value: function com(value) {\n        return this.comment(value);\n      }\n    }, {\n      key: \"ins\",\n      value: function ins(target, value) {\n        return this.instruction(target, value);\n      }\n    }, {\n      key: \"dec\",\n      value: function dec(version, encoding, standalone) {\n        return this.declaration(version, encoding, standalone);\n      }\n    }, {\n      key: \"dtd\",\n      value: function dtd(root, pubID, sysID) {\n        return this.doctype(root, pubID, sysID);\n      }\n    }, {\n      key: \"e\",\n      value: function e(name, attributes, text) {\n        return this.element(name, attributes, text);\n      }\n    }, {\n      key: \"n\",\n      value: function n(name, attributes, text) {\n        return this.node(name, attributes, text);\n      }\n    }, {\n      key: \"t\",\n      value: function t(value) {\n        return this.text(value);\n      }\n    }, {\n      key: \"d\",\n      value: function d(value) {\n        return this.cdata(value);\n      }\n    }, {\n      key: \"c\",\n      value: function c(value) {\n        return this.comment(value);\n      }\n    }, {\n      key: \"r\",\n      value: function r(value) {\n        return this.raw(value);\n      }\n    }, {\n      key: \"i\",\n      value: function i(target, value) {\n        return this.instruction(target, value);\n      } // Attribute aliases\n\n    }, {\n      key: \"att\",\n      value: function att() {\n        if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n          return this.attList.apply(this, arguments);\n        } else {\n          return this.attribute.apply(this, arguments);\n        }\n      }\n    }, {\n      key: \"a\",\n      value: function a() {\n        if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n          return this.attList.apply(this, arguments);\n        } else {\n          return this.attribute.apply(this, arguments);\n        }\n      } // DTD aliases\n      // att() and ele() are defined above\n\n    }, {\n      key: \"ent\",\n      value: function ent(name, value) {\n        return this.entity(name, value);\n      }\n    }, {\n      key: \"pent\",\n      value: function pent(name, value) {\n        return this.pEntity(name, value);\n      }\n    }, {\n      key: \"not\",\n      value: function not(name, value) {\n        return this.notation(name, value);\n      }\n    }]);\n\n    return XMLDocumentCB;\n  }();\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}