{"ast":null,"code":"'use strict'; // combine 2 matrixes\n// m1, m2 - [a, b, c, d, e, g]\n//\n\nfunction combine(m1, m2) {\n  return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];\n}\n\nfunction Matrix() {\n  if (!(this instanceof Matrix)) {\n    return new Matrix();\n  }\n\n  this.queue = []; // list of matrixes to apply\n\n  this.cache = null; // combined matrix cache\n}\n\nMatrix.prototype.matrix = function (m) {\n  if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0) {\n    return this;\n  }\n\n  this.cache = null;\n  this.queue.push(m);\n  return this;\n};\n\nMatrix.prototype.translate = function (tx, ty) {\n  if (tx !== 0 || ty !== 0) {\n    this.cache = null;\n    this.queue.push([1, 0, 0, 1, tx, ty]);\n  }\n\n  return this;\n};\n\nMatrix.prototype.scale = function (sx, sy) {\n  if (sx !== 1 || sy !== 1) {\n    this.cache = null;\n    this.queue.push([sx, 0, 0, sy, 0, 0]);\n  }\n\n  return this;\n};\n\nMatrix.prototype.rotate = function (angle, rx, ry) {\n  var rad, cos, sin;\n\n  if (angle !== 0) {\n    this.translate(rx, ry);\n    rad = angle * Math.PI / 180;\n    cos = Math.cos(rad);\n    sin = Math.sin(rad);\n    this.queue.push([cos, sin, -sin, cos, 0, 0]);\n    this.cache = null;\n    this.translate(-rx, -ry);\n  }\n\n  return this;\n};\n\nMatrix.prototype.skewX = function (angle) {\n  if (angle !== 0) {\n    this.cache = null;\n    this.queue.push([1, 0, Math.tan(angle * Math.PI / 180), 1, 0, 0]);\n  }\n\n  return this;\n};\n\nMatrix.prototype.skewY = function (angle) {\n  if (angle !== 0) {\n    this.cache = null;\n    this.queue.push([1, Math.tan(angle * Math.PI / 180), 0, 1, 0, 0]);\n  }\n\n  return this;\n}; // Flatten queue\n//\n\n\nMatrix.prototype.toArray = function () {\n  if (this.cache) {\n    return this.cache;\n  }\n\n  if (!this.queue.length) {\n    this.cache = [1, 0, 0, 1, 0, 0];\n    return this.cache;\n  }\n\n  this.cache = this.queue[0];\n\n  if (this.queue.length === 1) {\n    return this.cache;\n  }\n\n  for (var i = 1; i < this.queue.length; i++) {\n    this.cache = combine(this.cache, this.queue[i]);\n  }\n\n  return this.cache;\n}; // Apply list of matrixes to (x,y) point.\n// If `isRelative` set, `translate` component of matrix will be skipped\n//\n\n\nMatrix.prototype.calc = function (x, y, isRelative) {\n  var m; // Don't change point on empty transforms queue\n\n  if (!this.queue.length) {\n    return [x, y];\n  } // Calculate final matrix, if not exists\n  //\n  // NB. if you deside to apply transforms to point one-by-one,\n  // they should be taken in reverse order\n\n\n  if (!this.cache) {\n    this.cache = this.toArray();\n  }\n\n  m = this.cache; // Apply matrix to point\n\n  return [x * m[0] + y * m[2] + (isRelative ? 0 : m[4]), x * m[1] + y * m[3] + (isRelative ? 0 : m[5])];\n};\n\nmodule.exports = Matrix;","map":null,"metadata":{},"sourceType":"script"}