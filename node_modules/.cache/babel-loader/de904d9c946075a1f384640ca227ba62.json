{"ast":null,"code":"var inherits = require('inherits');\n\nvar EventEmitter = require('events').EventEmitter;\n\nmodule.exports = Queue;\nmodule.exports.default = Queue;\n\nfunction Queue(options) {\n  if (!(this instanceof Queue)) {\n    return new Queue(options);\n  }\n\n  EventEmitter.call(this);\n  options = options || {};\n  this.concurrency = options.concurrency || Infinity;\n  this.timeout = options.timeout || 0;\n  this.autostart = options.autostart || false;\n  this.results = options.results || null;\n  this.pending = 0;\n  this.session = 0;\n  this.running = false;\n  this.jobs = [];\n  this.timers = {};\n}\n\ninherits(Queue, EventEmitter);\nvar arrayMethods = ['pop', 'shift', 'indexOf', 'lastIndexOf'];\narrayMethods.forEach(function (method) {\n  Queue.prototype[method] = function () {\n    return Array.prototype[method].apply(this.jobs, arguments);\n  };\n});\n\nQueue.prototype.slice = function (begin, end) {\n  this.jobs = this.jobs.slice(begin, end);\n  return this;\n};\n\nQueue.prototype.reverse = function () {\n  this.jobs.reverse();\n  return this;\n};\n\nvar arrayAddMethods = ['push', 'unshift', 'splice'];\narrayAddMethods.forEach(function (method) {\n  Queue.prototype[method] = function () {\n    var methodResult = Array.prototype[method].apply(this.jobs, arguments);\n\n    if (this.autostart) {\n      this.start();\n    }\n\n    return methodResult;\n  };\n});\nObject.defineProperty(Queue.prototype, 'length', {\n  get: function get() {\n    return this.pending + this.jobs.length;\n  }\n});\n\nQueue.prototype.start = function (cb) {\n  if (cb) {\n    callOnErrorOrEnd.call(this, cb);\n  }\n\n  this.running = true;\n\n  if (this.pending >= this.concurrency) {\n    return;\n  }\n\n  if (this.jobs.length === 0) {\n    if (this.pending === 0) {\n      done.call(this);\n    }\n\n    return;\n  }\n\n  var self = this;\n  var job = this.jobs.shift();\n  var once = true;\n  var session = this.session;\n  var timeoutId = null;\n  var didTimeout = false;\n  var resultIndex = null;\n  var timeout = job.timeout || this.timeout;\n\n  function next(err, result) {\n    if (once && self.session === session) {\n      once = false;\n      self.pending--;\n\n      if (timeoutId !== null) {\n        delete self.timers[timeoutId];\n        clearTimeout(timeoutId);\n      }\n\n      if (err) {\n        self.emit('error', err, job);\n      } else if (didTimeout === false) {\n        if (resultIndex !== null) {\n          self.results[resultIndex] = Array.prototype.slice.call(arguments, 1);\n        }\n\n        self.emit('success', result, job);\n      }\n\n      if (self.session === session) {\n        if (self.pending === 0 && self.jobs.length === 0) {\n          done.call(self);\n        } else if (self.running) {\n          self.start();\n        }\n      }\n    }\n  }\n\n  if (timeout) {\n    timeoutId = setTimeout(function () {\n      didTimeout = true;\n\n      if (self.listeners('timeout').length > 0) {\n        self.emit('timeout', next, job);\n      } else {\n        next();\n      }\n    }, timeout);\n    this.timers[timeoutId] = timeoutId;\n  }\n\n  if (this.results) {\n    resultIndex = this.results.length;\n    this.results[resultIndex] = null;\n  }\n\n  this.pending++;\n  self.emit('start', job);\n  var promise = job(next);\n\n  if (promise && promise.then && typeof promise.then === 'function') {\n    promise.then(function (result) {\n      return next(null, result);\n    }).catch(function (err) {\n      return next(err || true);\n    });\n  }\n\n  if (this.running && this.jobs.length > 0) {\n    this.start();\n  }\n};\n\nQueue.prototype.stop = function () {\n  this.running = false;\n};\n\nQueue.prototype.end = function (err) {\n  clearTimers.call(this);\n  this.jobs.length = 0;\n  this.pending = 0;\n  done.call(this, err);\n};\n\nfunction clearTimers() {\n  for (var key in this.timers) {\n    var timeoutId = this.timers[key];\n    delete this.timers[key];\n    clearTimeout(timeoutId);\n  }\n}\n\nfunction callOnErrorOrEnd(cb) {\n  var self = this;\n  this.on('error', onerror);\n  this.on('end', onend);\n\n  function onerror(err) {\n    self.end(err);\n  }\n\n  function onend(err) {\n    self.removeListener('error', onerror);\n    self.removeListener('end', onend);\n    cb(err, this.results);\n  }\n}\n\nfunction done(err) {\n  this.session++;\n  this.running = false;\n  this.emit('end', err);\n}","map":null,"metadata":{},"sourceType":"script"}