{"ast":null,"code":"import zlib from 'zlib';\n\nvar range = function range(left, right, inclusive) {\n  var range = [];\n  var ascending = left < right;\n  var end = !inclusive ? right : ascending ? right + 1 : right - 1;\n\n  for (var i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {\n    range.push(i);\n  }\n\n  return range;\n};\n\nvar classCallCheck = function classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar toConsumableArray = function toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nvar PNG = function () {\n  createClass(PNG, null, [{\n    key: 'decode',\n    value: function decode(path, fn) {\n      {\n        throw new Error('PNG.decode not available in browser build');\n      }\n    }\n  }, {\n    key: 'load',\n    value: function load(path) {\n      {\n        throw new Error('PNG.load not available in browser build');\n      }\n    }\n  }]);\n\n  function PNG(data) {\n    var _this = this;\n\n    classCallCheck(this, PNG);\n    var i = void 0;\n    this.data = data;\n    this.pos = 8; // Skip the default header\n\n    this.palette = [];\n    this.imgData = [];\n    this.transparency = {};\n    this.text = {};\n\n    while (true) {\n      var end;\n      var chunkSize = this.readUInt32();\n\n      var section = function () {\n        var result = [];\n\n        for (i = 0; i < 4; i++) {\n          result.push(String.fromCharCode(_this.data[_this.pos++]));\n        }\n\n        return result;\n      }().join('');\n\n      switch (section) {\n        case 'IHDR':\n          // we can grab  interesting values from here (like width, height, etc)\n          this.width = this.readUInt32();\n          this.height = this.readUInt32();\n          this.bits = this.data[this.pos++];\n          this.colorType = this.data[this.pos++];\n          this.compressionMethod = this.data[this.pos++];\n          this.filterMethod = this.data[this.pos++];\n          this.interlaceMethod = this.data[this.pos++];\n          break;\n\n        case 'PLTE':\n          this.palette = this.read(chunkSize);\n          break;\n\n        case 'IDAT':\n          for (i = 0, end = chunkSize; i < end; i++) {\n            this.imgData.push(this.data[this.pos++]);\n          }\n\n          break;\n\n        case 'tRNS':\n          // This chunk can only occur once and it must occur after the\n          // PLTE chunk and before the IDAT chunk.\n          this.transparency = {};\n\n          switch (this.colorType) {\n            case 3:\n              // Indexed color, RGB. Each byte in this chunk is an alpha for\n              // the palette index in the PLTE (\"palette\") chunk up until the\n              // last non-opaque entry. Set up an array, stretching over all\n              // palette entries which will be 0 (opaque) or 1 (transparent).\n              this.transparency.indexed = this.read(chunkSize);\n              var short = 255 - this.transparency.indexed.length;\n\n              if (short > 0) {\n                var asc, end1;\n\n                for (i = 0, end1 = short, asc = 0 <= end1; asc ? i < end1 : i > end1; asc ? i++ : i--) {\n                  this.transparency.indexed.push(255);\n                }\n              }\n\n              break;\n\n            case 0:\n              // Greyscale. Corresponding to entries in the PLTE chunk.\n              // Grey is two bytes, range 0 .. (2 ^ bit-depth) - 1\n              this.transparency.grayscale = this.read(chunkSize)[0];\n              break;\n\n            case 2:\n              // True color with proper alpha channel.\n              this.transparency.rgb = this.read(chunkSize);\n              break;\n          }\n\n          break;\n\n        case 'tEXt':\n          var text = this.read(chunkSize);\n          var index = text.indexOf(0);\n          var key = String.fromCharCode.apply(String, toConsumableArray(Array.from(text.slice(0, index) || [])));\n          this.text[key] = String.fromCharCode.apply(String, toConsumableArray(Array.from(text.slice(index + 1) || [])));\n          break;\n\n        case 'IEND':\n          // we've got everything we need!\n          this.colors = function () {\n            switch (_this.colorType) {\n              case 0:\n              case 3:\n              case 4:\n                return 1;\n\n              case 2:\n              case 6:\n                return 3;\n            }\n          }();\n\n          this.hasAlphaChannel = [4, 6].includes(this.colorType);\n          var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);\n          this.pixelBitlength = this.bits * colors;\n\n          this.colorSpace = function () {\n            switch (_this.colors) {\n              case 1:\n                return 'DeviceGray';\n\n              case 3:\n                return 'DeviceRGB';\n            }\n          }();\n\n          this.imgData = new Buffer(this.imgData);\n          return;\n          break;\n\n        default:\n          // unknown (or unimportant) section, skip it\n          this.pos += chunkSize;\n      }\n\n      this.pos += 4; // Skip the CRC\n\n      if (this.pos > this.data.length) {\n        throw new Error(\"Incomplete or corrupt PNG file\");\n      }\n    }\n  }\n\n  createClass(PNG, [{\n    key: 'read',\n    value: function read(bytes) {\n      var _this2 = this;\n\n      return range(0, bytes, false).map(function (i) {\n        return _this2.data[_this2.pos++];\n      });\n    }\n  }, {\n    key: 'readUInt32',\n    value: function readUInt32() {\n      var b1 = this.data[this.pos++] << 24;\n      var b2 = this.data[this.pos++] << 16;\n      var b3 = this.data[this.pos++] << 8;\n      var b4 = this.data[this.pos++];\n      return b1 | b2 | b3 | b4;\n    }\n  }, {\n    key: 'readUInt16',\n    value: function readUInt16() {\n      var b1 = this.data[this.pos++] << 8;\n      var b2 = this.data[this.pos++];\n      return b1 | b2;\n    }\n  }, {\n    key: 'decodePixels',\n    value: function decodePixels(fn) {\n      var _this3 = this;\n\n      return zlib.inflate(this.imgData, function (err, data) {\n        if (err) {\n          throw err;\n        }\n\n        var pixelBytes = _this3.pixelBitlength / 8;\n        var scanlineLength = pixelBytes * _this3.width;\n        var pixels = new Buffer(scanlineLength * _this3.height);\n        var length = data.length;\n        var row = 0;\n        var pos = 0;\n        var c = 0;\n\n        while (pos < length) {\n          var byte, col, i, left, upper;\n          var end;\n          var end1;\n          var end2;\n          var end3;\n          var end4;\n\n          switch (data[pos++]) {\n            case 0:\n              // None\n              for (i = 0, end = scanlineLength; i < end; i++) {\n                pixels[c++] = data[pos++];\n              }\n\n              break;\n\n            case 1:\n              // Sub\n              for (i = 0, end1 = scanlineLength; i < end1; i++) {\n                byte = data[pos++];\n                left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n                pixels[c++] = (byte + left) % 256;\n              }\n\n              break;\n\n            case 2:\n              // Up\n              for (i = 0, end2 = scanlineLength; i < end2; i++) {\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                pixels[c++] = (upper + byte) % 256;\n              }\n\n              break;\n\n            case 3:\n              // Average\n              for (i = 0, end3 = scanlineLength; i < end3; i++) {\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n                upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                pixels[c++] = (byte + Math.floor((left + upper) / 2)) % 256;\n              }\n\n              break;\n\n            case 4:\n              // Paeth\n              for (i = 0, end4 = scanlineLength; i < end4; i++) {\n                var paeth, upperLeft;\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n\n                if (row === 0) {\n                  upper = upperLeft = 0;\n                } else {\n                  upper = pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                  upperLeft = col && pixels[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];\n                }\n\n                var p = left + upper - upperLeft;\n                var pa = Math.abs(p - left);\n                var pb = Math.abs(p - upper);\n                var pc = Math.abs(p - upperLeft);\n\n                if (pa <= pb && pa <= pc) {\n                  paeth = left;\n                } else if (pb <= pc) {\n                  paeth = upper;\n                } else {\n                  paeth = upperLeft;\n                }\n\n                pixels[c++] = (byte + paeth) % 256;\n              }\n\n              break;\n\n            default:\n              throw new Error('Invalid filter algorithm: ' + data[pos - 1]);\n          }\n\n          row++;\n        }\n\n        return fn(pixels);\n      });\n    }\n  }, {\n    key: 'decodePalette',\n    value: function decodePalette() {\n      var palette = this.palette;\n      var transparency = this.transparency.indexed || [];\n      var ret = new Buffer(transparency.length + palette.length);\n      var pos = 0;\n      var length = palette.length;\n      var c = 0;\n\n      for (var _i = 0, end = palette.length; _i < end; _i += 3) {\n        var left;\n        ret[pos++] = palette[_i];\n        ret[pos++] = palette[_i + 1];\n        ret[pos++] = palette[_i + 2];\n        ret[pos++] = (left = transparency[c++]) != null ? left : 255;\n      }\n\n      return ret;\n    }\n  }, {\n    key: 'copyToImageData',\n    value: function copyToImageData(imageData, pixels) {\n      var j = void 0,\n          k = void 0;\n      var colors = this.colors;\n      var palette = null;\n      var alpha = this.hasAlphaChannel;\n\n      if (this.palette.length) {\n        palette = this._decodedPalette != null ? this._decodedPalette : this._decodedPalette = this.decodePalette();\n        colors = 4;\n        alpha = true;\n      }\n\n      var data = (imageData != null ? imageData.data : undefined) || imageData;\n      var length = data.length;\n      var input = palette || pixels;\n      var i = j = 0;\n\n      if (colors === 1) {\n        while (i < length) {\n          k = palette ? pixels[i / 4] * 4 : j;\n          var v = input[k++];\n          data[i++] = v;\n          data[i++] = v;\n          data[i++] = v;\n          data[i++] = alpha ? input[k++] : 255;\n          j = k;\n        }\n      } else {\n        while (i < length) {\n          k = palette ? pixels[i / 4] * 4 : j;\n          data[i++] = input[k++];\n          data[i++] = input[k++];\n          data[i++] = input[k++];\n          data[i++] = alpha ? input[k++] : 255;\n          j = k;\n        }\n      }\n    }\n  }, {\n    key: 'decode',\n    value: function decode(fn) {\n      var _this4 = this;\n\n      var ret = new Buffer(this.width * this.height * 4);\n      return this.decodePixels(function (pixels) {\n        _this4.copyToImageData(ret, pixels);\n\n        return fn(ret);\n      });\n    }\n  }]);\n  return PNG;\n}();\n\nexport default PNG;","map":null,"metadata":{},"sourceType":"module"}