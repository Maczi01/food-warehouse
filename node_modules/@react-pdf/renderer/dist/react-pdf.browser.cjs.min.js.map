{"version":3,"file":"react-pdf.browser.cjs.min.js","sources":["../src/font/emoji.js","../src/font/hyphenation.js","../src/constants.js","../src/stylesheet/transformStyles.js","../src/font/font.js","../src/font/standard.js","../src/font/index.js","../src/render/save.js","../src/utils/url.js","../src/render/setLink.js","../src/render/restore.js","../src/node/isSvg.js","../src/node/isText.js","../src/node/isPage.js","../src/node/isLink.js","../src/node/isNote.js","../src/node/isImage.js","../src/node/isCanvas.js","../src/render/clipNode.js","../src/render/renderPath.js","../src/render/renderRect.js","../src/render/renderLine.js","../src/render/renderEllipse.js","../src/render/renderCircle.js","../src/render/renderSvgText.js","../src/svg/parsePoints.js","../src/render/renderPolyline.js","../src/render/renderPolygon.js","../src/utils/warning.js","../src/render/renderSvgImage.js","../src/render/applyTransformations.js","../src/node/isPath.js","../src/node/isRect.js","../src/node/isLine.js","../src/node/isTspan.js","../src/node/isGroup.js","../src/node/isCircle.js","../src/node/isTextInstance.js","../src/render/renderGroup.js","../src/node/isEllipse.js","../src/node/isPolygon.js","../src/node/isPolyline.js","../src/svg/normalizePath.js","../src/svg/getBoundingBox.js","../src/render/renderSvg.js","../src/render/renderText.js","../src/render/renderPage.js","../src/render/renderNote.js","../src/utils/matchPercent.js","../src/image/resolveObjectFit.js","../src/render/renderImage.js","../src/canvas/painter.js","../src/render/renderCanvas.js","../src/node/hasVerticalRuler.js","../src/node/hasHorizontalRuler.js","../src/render/renderRulers.js","../src/render/addMetadata.js","../src/render/renderDebug.js","../src/render/renderBorders.js","../src/render/setDestination.js","../src/render/renderBackground.js","../src/render/index.js","../src/utils/capitalize.js","../src/utils/upperFirst.js","../src/text/transformText.js","../src/text/standardFont.js","../src/text/fontSubstitution.js","../src/svg/layoutText.js","../src/node/isDefs.js","../src/svg/getDefs.js","../src/svg/replaceDefs.js","../src/svg/parseViewbox.js","../src/svg/getContainer.js","../src/svg/inheritProps.js","../src/svg/parseAspectRatio.js","../src/stylesheet/transformColors.js","../src/layout/resolveSvg.js","../src/layout/resolveZIndex.js","../src/layout/resolveRulers.js","../src/utils/png.js","../src/utils/jpeg.js","../src/utils/cache.js","../src/image/resolveImage.js","../src/utils/firstPass.js","../src/image/getSource.js","../src/image/fetchImage.js","../src/text/emoji.js","../src/layout/resolveAssets.js","../src/utils/castArray.js","../src/stylesheet/flatten.js","../src/stylesheet/expandStyles.js","../src/stylesheet/transformUnits.js","../src/stylesheet/resolveMediaQueries.js","../src/layout/resolveStyles.js","../src/node/getOrigin.js","../src/layout/resolveOrigins.js","../src/page/getOrientation.js","../src/page/isLandscape.js","../src/page/getSize.js","../src/utils/assocIfNil.js","../src/layout/resolvePageSizes.js","../src/text/lineIndexAtHeight.js","../src/text/heightAtLineIndex.js","../src/text/splitText.js","../src/node/splitNode.js","../src/node/createInstance.js","../src/node/getNodesHeight.js","../src/node/shouldBreak.js","../src/node/getPadding.js","../src/page/getContentArea.js","../src/text/ignorableChars.js","../src/text/getAttributedString.js","../src/text/layoutText.js","../src/layout/resolveTextLayout.js","../src/layout/resolveInheritance.js","../src/node/getMargin.js","../src/node/getPosition.js","../src/node/getDimension.js","../src/node/getBorderWidth.js","../src/node/setDisplay.js","../src/node/setOverflow.js","../src/node/setFlexWrap.js","../src/node/setYogaValue.js","../src/node/setFlexGrow.js","../src/node/setFlexBasis.js","../src/node/setAlign.js","../src/node/setAlignSelf.js","../src/node/setAlignItems.js","../src/node/setFlexShrink.js","../src/node/setAspectRatio.js","../src/node/setAlignContent.js","../src/node/setPositionType.js","../src/node/setFlexDirection.js","../src/node/setJustifyContent.js","../src/node/setMargin.js","../src/node/setPadding.js","../src/node/setBorderWidth.js","../src/node/setPosition.js","../src/node/setDimension.js","../src/svg/measureSvg.js","../src/text/linesWidth.js","../src/text/linesHeight.js","../src/text/measureText.js","../src/image/getRatio.js","../src/page/isHeightAuto.js","../src/image/measureImage.js","../src/canvas/measureCanvas.js","../src/layout/resolveDimensions.js","../src/layout/resolvePagination.js","../src/node/removeMargins.js","../src/layout/resolvePageMargins.js","../src/layout/resolveNoteChildren.js","../src/layout/resolvePagePaddings.js","../src/layout/resolvePercentRadius.js","../src/layout/resolvePercentHeight.js","../src/layout/resolveLinkSubstitution.js","../src/utils/asyncCompose.js","../src/layout/index.js","../src/utils/propsEqual.js","../src/renderer.js","../src/stylesheet/index.js","../src/index.js","../src/canvas.js","../src/dom.js"],"sourcesContent":["let emojiSource;\n\nexport const registerEmojiSource = ({ url, format = 'png' }) => {\n  emojiSource = { url, format };\n};\n\nexport const getEmojiSource = () => emojiSource;\n\nexport default {\n  registerEmojiSource,\n  getEmojiSource,\n};\n","let hyphenationCallback;\n\nexport const registerHyphenationCallback = callback => {\n  hyphenationCallback = callback;\n};\n\nexport const getHyphenationCallback = () => hyphenationCallback;\n\nexport default {\n  registerHyphenationCallback,\n  getHyphenationCallback,\n};\n","export const VIEW = 'VIEW';\nexport const TEXT = 'TEXT';\nexport const LINK = 'LINK';\nexport const PAGE = 'PAGE';\nexport const NOTE = 'NOTE';\nexport const IMAGE = 'IMAGE';\nexport const DOCUMENT = 'DOCUMENT';\nexport const CANVAS = 'CANVAS';\nexport const TEXT_INSTANCE = 'TEXT_INSTANCE';\nexport const SVG = 'SVG';\nexport const GROUP = 'G';\nexport const PATH = 'PATH';\nexport const RECT = 'RECT';\nexport const LINE = 'LINE';\nexport const CIRCLE = 'CIRCLE';\nexport const ELLIPSE = 'ELLIPSE';\nexport const POLYGON = 'POLYGON';\nexport const POLYLINE = 'POLYLINE';\nexport const DEFS = 'DEFS';\nexport const TSPAN = 'TSPAN';\nexport const CLIP_PATH = 'CLIP_PATH';\nexport const STOP = 'STOP';\nexport const LINEAR_GRADIENT = 'LINEAR_GRADIENT';\nexport const RADIAL_GRADIENT = 'RADIAL_GRADIENT';\n\nexport const DPI = 72; // 72pt per inch.\n\n// https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight#Common_weight_name_mapping\nexport const FONT_WEIGHTS = {\n  thin: 100,\n  hairline: 100,\n  ultralight: 200,\n  extralight: 200,\n  light: 300,\n  normal: 400,\n  medium: 500,\n  semibold: 600,\n  demibold: 600,\n  bold: 700,\n  ultrabold: 800,\n  extrabold: 800,\n  heavy: 900,\n  black: 900,\n};\n\nexport const PAGE_SIZES = {\n  '4A0': [4767.87, 6740.79],\n  '2A0': [3370.39, 4767.87],\n  A0: [2383.94, 3370.39],\n  A1: [1683.78, 2383.94],\n  A2: [1190.55, 1683.78],\n  A3: [841.89, 1190.55],\n  A4: [595.28, 841.89],\n  A5: [419.53, 595.28],\n  A6: [297.64, 419.53],\n  A7: [209.76, 297.64],\n  A8: [147.4, 209.76],\n  A9: [104.88, 147.4],\n  A10: [73.7, 104.88],\n  B0: [2834.65, 4008.19],\n  B1: [2004.09, 2834.65],\n  B2: [1417.32, 2004.09],\n  B3: [1000.63, 1417.32],\n  B4: [708.66, 1000.63],\n  B5: [498.9, 708.66],\n  B6: [354.33, 498.9],\n  B7: [249.45, 354.33],\n  B8: [175.75, 249.45],\n  B9: [124.72, 175.75],\n  B10: [87.87, 124.72],\n  C0: [2599.37, 3676.54],\n  C1: [1836.85, 2599.37],\n  C2: [1298.27, 1836.85],\n  C3: [918.43, 1298.27],\n  C4: [649.13, 918.43],\n  C5: [459.21, 649.13],\n  C6: [323.15, 459.21],\n  C7: [229.61, 323.15],\n  C8: [161.57, 229.61],\n  C9: [113.39, 161.57],\n  C10: [79.37, 113.39],\n  RA0: [2437.8, 3458.27],\n  RA1: [1729.13, 2437.8],\n  RA2: [1218.9, 1729.13],\n  RA3: [864.57, 1218.9],\n  RA4: [609.45, 864.57],\n  SRA0: [2551.18, 3628.35],\n  SRA1: [1814.17, 2551.18],\n  SRA2: [1275.59, 1814.17],\n  SRA3: [907.09, 1275.59],\n  SRA4: [637.8, 907.09],\n  EXECUTIVE: [521.86, 756.0],\n  FOLIO: [612.0, 936.0],\n  LEGAL: [612.0, 1008.0],\n  LETTER: [612.0, 792.0],\n  TABLOID: [792.0, 1224.0],\n};\n\nexport const PORTRAIT = 'portrait';\nexport const LANDSCAPE = 'landscape';\n\nexport const INHERITED_PROPERTIES = [\n  'color',\n  'fontFamily',\n  'fontSize',\n  'fontStyle',\n  'fontWeight',\n  'letterSpacing',\n  'opacity',\n  'textDecoration',\n  'lineHeight',\n  'textAlign',\n  'visibility',\n  'wordSpacing',\n];\n\nexport const SVG_INHERITED_PROPS = [\n  'x',\n  'y',\n  'clipPath',\n  'clipRule',\n  'opacity',\n  'fill',\n  'fillOpacity',\n  'fillRule',\n  'stroke',\n  'strokeLinecap',\n  'strokeLinejoin',\n  'strokeOpacity',\n  'strokeWidth',\n  'textAnchor',\n  ...INHERITED_PROPERTIES,\n];\n\nexport const RULER_WIDTH = 13;\nexport const RULER_COLOR = 'white';\nexport const RULER_FONT_SIZE = 6;\nexport const DEFAULT_RULER_STEPS = 50;\nexport const LINE_WIDTH = 0.5;\nexport const LINE_COLOR = 'gray';\nexport const GRID_COLOR = '#ababab';\n","import * as R from 'ramda';\n\nimport { FONT_WEIGHTS } from '../constants';\n\nconst BOX_MODEL_REGEX = /\\d+(px|in|mm|cm|pt|%|vw|vh|px)?/g;\nconst OBJECT_POSITION_REGEX = /\\d+(px|in|mm|cm|pt|%|vw|vh|px)?/g;\nconst BORDER_SHORTHAND_REGEX = /(\\d+(px|in|mm|cm|pt|vw|vh|px)?)\\s(\\S+)\\s(\\S+)/;\nconst TRANSFORM_ORIGIN_REGEX = /(-?\\d+(px|in|mm|cm|pt|%|vw|vh|px)?)|top|right|bottom|left|center/g;\n\nconst matchBoxModel = R.match(BOX_MODEL_REGEX);\nconst matchObjectPosition = R.match(OBJECT_POSITION_REGEX);\nconst matchBorderShorthand = R.match(BORDER_SHORTHAND_REGEX);\nconst matchTransformOrigin = R.match(TRANSFORM_ORIGIN_REGEX);\n\nconst isNumber = R.is(Number);\n\nconst isFontWeightStyle = key => key.match(/^fontWeight/);\n\nconst isBorderStyle = (key, value) =>\n  key.match(/^border(Top|Right|Bottom|Left)(Color|Width|Style)/) &&\n  typeof value === 'string';\n\nconst isBoxModelStyle = (key, value) =>\n  key.match(/^(margin)|(padding)/) && typeof value === 'string';\n\nconst isObjectPositionStyle = (key, value) =>\n  key.match(/^objectPosition/) && typeof value === 'string';\n\nconst isTransformOriginStyle = (key, value) =>\n  key.match(/^transformOrigin/) && typeof value === 'string';\n\nconst isFlexGrow = key => key === 'flexGrow';\n\nconst isFlexShrink = key => key === 'flexShrink';\n\nconst isFlexBasis = key => key === 'flexBasis';\n\nconst processBorders = (key, value) => {\n  const match = matchBorderShorthand(value);\n\n  if (match) {\n    if (key.match(/Color$/)) {\n      return match[4] || value;\n    } else if (key.match(/Style$/)) {\n      return match[3] || value;\n    } else if (key.match(/Width$/)) {\n      return match[1] || value;\n    } else {\n      throw new Error(`StyleSheet: Invalid '${value}' for '${key}'`);\n    }\n  }\n\n  return value;\n};\n\nconst processBoxModel = (key, value) => {\n  const match = matchBoxModel(value);\n\n  if (match) {\n    if (key.match(/Top$/)) {\n      return match[0];\n    } else if (key.match(/Right$/)) {\n      return match[1] || match[0];\n    } else if (key.match(/Bottom$/)) {\n      return match[2] || match[0];\n    } else if (key.match(/Left$/)) {\n      return match[3] || match[1] || match[0];\n    } else {\n      throw new Error(`StyleSheet: Invalid '${value}' for '${key}'`);\n    }\n  }\n\n  return value;\n};\n\nexport const processFontWeight = (key, value) => {\n  if (!value) return FONT_WEIGHTS.normal;\n  if (typeof value === 'number') return value;\n  return FONT_WEIGHTS[value.toLowerCase()];\n};\n\nexport const processObjectPosition = (key, value) => {\n  const match = matchObjectPosition(value);\n\n  if (match) {\n    if (key.match(/X$/)) {\n      return match[0] || value;\n    } else if (key.match(/Y$/)) {\n      return match[1] || value;\n    } else {\n      throw new Error(`StyleSheet: Invalid '${value}' for '${key}'`);\n    }\n  }\n\n  return value;\n};\n\nconst transformOffsetKeywords = value => {\n  switch (value) {\n    case 'top':\n    case 'left':\n      return '0%';\n    case 'right':\n    case 'bottom':\n      return '100%';\n    case 'center':\n      return '50%';\n    default:\n      return value;\n  }\n};\n\n// Transforms shorthand transformOrigin values\nconst processTransformOrigin = (key, value) => {\n  const match = matchTransformOrigin(value);\n\n  if (match) {\n    let result;\n\n    if (key.match(/X$/)) {\n      result = match[0] || value;\n    } else if (key.match(/Y$/)) {\n      result = match[1] || match[0] || value;\n    } else {\n      throw new Error(`StyleSheet: Invalid '${value}' for '${key}'`);\n    }\n\n    return transformOffsetKeywords(result);\n  }\n\n  return value;\n};\n\nconst processFlexGrow = (key, value) => {\n  if (isNumber(value)) return value;\n  const matches = value.split(' ');\n  return matches[0];\n};\n\nconst processFlexShrink = (key, value) => {\n  if (isNumber(value)) return value;\n  const matches = value.split(' ');\n  return matches[1];\n};\n\nconst processFlexBasis = (key, value) => {\n  if (isNumber(value)) return value;\n  const matches = value.split(' ');\n  return matches[2];\n};\n\nconst keepSame = (key, value) => value;\n\nconst matchNumber = R.when(R.is(String), R.test(/^-?\\d*\\.?\\d*$/));\n\nconst castFloat = R.when(matchNumber, v => parseFloat(v, 10));\n\n/**\n * Transforms style key-value\n *\n * @param {String} key style key\n * @param {String} value style value\n * @returns {String | Number} transformed style values\n */\nconst transformStyle = R.compose(\n  castFloat,\n  R.cond([\n    [isBorderStyle, processBorders],\n    [isBoxModelStyle, processBoxModel],\n    [isObjectPositionStyle, processObjectPosition],\n    [isTransformOriginStyle, processTransformOrigin],\n    [isFontWeightStyle, processFontWeight],\n    [isFlexGrow, processFlexGrow],\n    [isFlexShrink, processFlexShrink],\n    [isFlexBasis, processFlexBasis],\n    [R.T, keepSame],\n  ]),\n);\n\n/**\n * Transforms already expanded styles shortcuts into appropiate values\n * Ex. marginTopWidth: '2 solid red' -> marginTopWidth: 2\n *\n * @param {Object} styles expanded object\n * @returns {Object} transformed styles\n */\nconst transformStyles = R.mapObjIndexed(R.flip(transformStyle));\n\nexport default transformStyles;\n","import isUrl from 'is-url';\nimport fontkit from '@react-pdf/fontkit';\nimport fetch from 'cross-fetch';\n\nimport { processFontWeight } from '../stylesheet/transformStyles';\n\nconst fetchFont = async (src, options) => {\n  const response = await fetch(src, options);\n\n  const buffer = await (response.buffer\n    ? response.buffer()\n    : response.arrayBuffer());\n\n  return buffer.constructor.name === 'Buffer' ? buffer : Buffer.from(buffer);\n};\n\nclass FontSource {\n  constructor(src, fontFamily, fontStyle, fontWeight, options) {\n    this.src = src;\n    this.fontFamily = fontFamily;\n    this.fontStyle = fontStyle || 'normal';\n    this.fontWeight = processFontWeight(fontWeight) || 400;\n\n    this.data = null;\n    this.loading = false;\n    this.options = options;\n  }\n\n  async load() {\n    this.loading = true;\n\n    if (BROWSER || isUrl(this.src)) {\n      const { headers, body, method = 'GET' } = this.options;\n      const data = await fetchFont(this.src, { method, body, headers });\n      this.data = fontkit.create(data);\n    } else {\n      this.data = await new Promise((resolve, reject) =>\n        fontkit.open(this.src, (err, data) =>\n          err ? reject(err) : resolve(data),\n        ),\n      );\n    }\n\n    this.loading = false;\n  }\n}\n\nclass Font {\n  static create(family) {\n    return new Font(family);\n  }\n\n  constructor(family) {\n    this.family = family;\n    this.sources = [];\n  }\n\n  register({ src, fontWeight, fontStyle, ...options }) {\n    this.sources.push(\n      new FontSource(src, this.fontFamily, fontStyle, fontWeight, options),\n    );\n  }\n\n  resolve(descriptor) {\n    const { fontWeight = 400, fontStyle = 'normal' } = descriptor;\n    const styleSources = this.sources.filter(s => s.fontStyle === fontStyle);\n\n    // Weight resolution. https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight#Fallback_weights\n    const exactFit = styleSources.find(s => s.fontWeight === fontWeight);\n\n    if (exactFit) return exactFit;\n\n    let res;\n\n    if (fontWeight >= 400 && fontWeight <= 500) {\n      const leftOffset = styleSources.filter(s => s.fontWeight <= fontWeight);\n      const rightOffset = styleSources.filter(s => s.fontWeight > 500);\n      const fit = styleSources.filter(\n        s => s.fontWeight >= fontWeight && s.fontWeight < 500,\n      );\n\n      res = fit[0] || leftOffset[leftOffset.length - 1] || rightOffset[0];\n    }\n\n    const lt = styleSources.filter(s => s.fontWeight < fontWeight);\n    const gt = styleSources.filter(s => s.fontWeight > fontWeight);\n\n    if (fontWeight < 400) {\n      res = lt[lt.length - 1] || gt[0];\n    }\n\n    if (fontWeight > 500) {\n      res = gt[0] || lt[lt.length - 1];\n    }\n\n    if (!res) {\n      throw new Error(\n        `Could not resolve font for ${\n          this.fontFamily\n        }, fontWeight ${fontWeight}`,\n      );\n    }\n\n    return res;\n  }\n}\n\nexport default Font;\n","export default [\n  'Courier',\n  'Courier-Bold',\n  'Courier-Oblique',\n  'Helvetica',\n  'Helvetica-Bold',\n  'Helvetica-Oblique',\n  'Times-Roman',\n  'Times-Bold',\n  'Times-Italic',\n];\n","import font from './font';\nimport emoji from './emoji';\nimport standardFonts from './standard';\nimport hyphenation from './hyphenation';\n\nlet fonts = {};\n\nconst register = data => {\n  const { family } = data;\n\n  if (!fonts[family]) {\n    fonts[family] = font.create(family);\n  }\n\n  // Bulk loading\n  if (data.fonts) {\n    for (let i = 0; i < data.fonts.length; i++) {\n      fonts[family].register({ family, ...data.fonts[i] });\n    }\n  } else {\n    fonts[family].register(data);\n  }\n};\n\nconst getRegisteredFonts = () => fonts;\n\nconst getRegisteredFontFamilies = () => Object.keys(fonts);\n\nconst getFont = descriptor => {\n  const { fontFamily } = descriptor;\n  const isStandard = standardFonts.includes(fontFamily);\n\n  if (isStandard) return null;\n\n  if (!fonts[fontFamily]) {\n    throw new Error(\n      `Font family not registered: ${fontFamily}. Please register it calling Font.register() method.`,\n    );\n  }\n\n  return fonts[fontFamily].resolve(descriptor);\n};\n\nconst load = async function(descriptor) {\n  const { fontFamily } = descriptor;\n  const isStandard = standardFonts.includes(fontFamily);\n\n  if (isStandard) return;\n\n  const font = getFont(descriptor);\n\n  // We cache the font to avoid fetching it many times\n  if (!font.data && !font.loading) {\n    await font.load();\n  }\n};\n\nconst reset = function() {\n  for (const font in fonts) {\n    if (fonts.hasOwnProperty(font)) {\n      fonts[font].data = null;\n    }\n  }\n};\n\nconst clear = function() {\n  fonts = {};\n};\n\nexport default {\n  register,\n  getRegisteredFonts,\n  getRegisteredFontFamilies,\n  getFont,\n  load,\n  clear,\n  reset,\n  ...emoji,\n  ...hyphenation,\n};\n","import * as R from 'ramda';\n\nconst save = (ctx, node) => {\n  ctx.save();\n  return node;\n};\n\nexport default R.curryN(2, save);\n","const PROTOCOL_REGEXP = /^([a-z]+\\:(\\/\\/)?)/i;\nconst DEST_REGEXP = /^#.+/;\n\n/**\n * Add protocol th URL if valid\n *\n * @param {String} value url\n * @returns {String} corrected url\n */\nexport const getURL = value => {\n  if (!value) return '';\n\n  if (isSrcId(value)) return value; // don't modify it if it is an id\n\n  if (typeof value === 'string' && !value.match(PROTOCOL_REGEXP)) {\n    return `http://${value}`;\n  }\n\n  return value;\n};\n\nexport const isSrcId = src => src.match(DEST_REGEXP);\n\nexport const setLink = node => {\n  if (!node.src) {\n    return;\n  }\n\n  const { top, left, width, height } = node.getAbsoluteLayout();\n  const instanceMethod = isSrcId(node.src) ? 'goTo' : 'link';\n  const nodeSrc = isSrcId(node.src) ? node.src.slice(1) : node.src;\n\n  node.root.instance[instanceMethod](left, top, width, height, nodeSrc);\n};\n\nexport const setDestination = node => {\n  if (!node.props.id) {\n    return;\n  }\n\n  const { top } = node.getAbsoluteLayout();\n  node.root.instance.addNamedDestination(node.props.id, 'XYZ', null, top, null);\n};\n","import * as R from 'ramda';\n\nimport { getURL } from '../utils/url';\n\nconst DEST_REGEXP = /^#.+/;\n\nconst isSrcId = R.test(DEST_REGEXP);\n\nconst getSource = R.compose(\n  R.either(R.path(['props', 'src']), R.path(['props', 'href'])),\n);\n\nconst setLink = (ctx, node) => {\n  const { top, left, width, height } = node.box;\n  const src = getSource(node);\n  const instanceMethod = isSrcId(src) ? 'goTo' : 'link';\n  const value = isSrcId(src) ? src.slice(1) : getURL(src);\n\n  if (value) {\n    ctx[instanceMethod](left, top, width, height, value);\n  }\n\n  return node;\n};\n\nexport default R.curryN(2, setLink);\n","import * as R from 'ramda';\n\nconst restore = (ctx, node) => {\n  ctx.restore();\n  return node;\n};\n\nexport default R.curryN(2, restore);\n","import * as R from 'ramda';\n\nimport { SVG } from '../constants';\n\n/**\n * Checks if node is svg\n *\n * @param {Object} node\n * @returns {Boolean} is node svg?\n */\nconst isSvg = R.propEq('type', SVG);\n\nexport default isSvg;\n","import * as R from 'ramda';\n\nimport { TEXT } from '../constants';\n\n/**\n * Checks if node is text\n *\n * @param {Object} node\n * @returns {Boolean} is node text?\n */\nconst isText = R.propEq('type', TEXT);\n\nexport default isText;\n","import * as R from 'ramda';\n\nimport { PAGE } from '../constants';\n\n/**\n * Checks if node is page\n *\n * @param {Object} node\n * @returns {Boolean} is node page?\n */\nconst isPage = R.propEq('type', PAGE);\n\nexport default isPage;\n","import * as R from 'ramda';\n\nimport { LINK, TEXT } from '../constants';\n\n/**\n * Checks if node has valid source prop\n *\n * @param {Object} node\n * @returns {Boolean} does node have source prop?\n */\nconst hasSource = R.either(\n  R.hasPath(['props', 'src']),\n  R.hasPath(['props', 'href']),\n);\n\n/**\n * Checks if node is link\n *\n * @param {Object} node\n * @returns {Boolean} is node link?\n */\nconst isLink = R.either(\n  R.propEq('type', LINK),\n  R.both(R.propEq('type', TEXT), hasSource),\n);\n\nexport default isLink;\n","import * as R from 'ramda';\n\nimport { NOTE } from '../constants';\n\n/**\n * Checks if node is note\n *\n * @param {Object} node\n * @returns {Boolean} is node note?\n */\nconst isNote = R.propEq('type', NOTE);\n\nexport default isNote;\n","import * as R from 'ramda';\n\nimport { IMAGE } from '../constants';\n\n/**\n * Checks if node is image\n *\n * @param {Object} node\n * @returns {Boolean} is node image?\n */\nconst isImage = R.propEq('type', IMAGE);\n\nexport default isImage;\n","import * as R from 'ramda';\n\nimport { CANVAS } from '../constants';\n\n/**\n * Checks if node is canvas\n *\n * @param {Object} node\n * @returns {Boolean} is node canvas?\n */\nconst isCanvas = R.propEq('type', CANVAS);\n\nexport default isCanvas;\n","import * as R from 'ramda';\n\n// This constant is used to approximate a symmetrical arc using a cubic\n// Bezier curve.\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nconst clipNode = (ctx, node) => {\n  const { top, left, width, height } = node.box;\n\n  const {\n    borderTopLeftRadius = 0,\n    borderTopRightRadius = 0,\n    borderBottomRightRadius = 0,\n    borderBottomLeftRadius = 0,\n  } = node.style;\n\n  // Border top\n  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  const ctr = rtr * (1.0 - KAPPA);\n\n  ctx.moveTo(left + rtr, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(\n    left + width - ctr,\n    top,\n    left + width,\n    top + ctr,\n    left + width,\n    top + rtr,\n  );\n\n  // Border right\n  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  const cbr = rbr * (1.0 - KAPPA);\n\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(\n    left + width,\n    top + height - cbr,\n    left + width - cbr,\n    top + height,\n    left + width - rbr,\n    top + height,\n  );\n\n  // Border bottom\n  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  const cbl = rbl * (1.0 - KAPPA);\n\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(\n    left + cbl,\n    top + height,\n    left,\n    top + height - cbl,\n    left,\n    top + height - rbl,\n  );\n\n  // Border left\n  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  const ctl = rtl * (1.0 - KAPPA);\n\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n\n  return node;\n};\n\nexport default R.curryN(2, clipNode);\n","import * as R from 'ramda';\n\nconst renderPath = ctx =>\n  R.tap(node => {\n    const d = R.path(['props', 'd'], node);\n    if (d) ctx.path(node.props.d);\n  });\n\nexport default renderPath;\n","import * as R from 'ramda';\n\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nconst getProp = (d, p, v) => R.pathOr(d, ['props', p], v);\n\nconst renderRect = ctx => node => {\n  const x = getProp(0, 'x', node);\n  const y = getProp(0, 'y', node);\n  const rx = getProp(0, 'rx', node);\n  const ry = getProp(0, 'ry', node);\n  const width = getProp(0, 'width', node);\n  const height = getProp(0, 'height', node);\n\n  if (!width || !height) return node;\n\n  if (rx && ry) {\n    const krx = rx * KAPPA;\n    const kry = ry * KAPPA;\n\n    ctx.moveTo(x + rx, y);\n    ctx.lineTo(x - rx + width, y);\n    ctx.bezierCurveTo(\n      x - rx + width + krx,\n      y,\n      x + width,\n      y + ry - kry,\n      x + width,\n      y + ry,\n    );\n    ctx.lineTo(x + width, y + height - ry);\n    ctx.bezierCurveTo(\n      x + width,\n      y + height - ry + kry,\n      x - rx + width + krx,\n      y + height,\n      x - rx + width,\n      y + height,\n    );\n    ctx.lineTo(x + rx, y + height);\n    ctx.bezierCurveTo(\n      x + rx - krx,\n      y + height,\n      x,\n      y + height - ry + kry,\n      x,\n      y + height - ry,\n    );\n    ctx.lineTo(x, y + ry);\n    ctx.bezierCurveTo(x, y + ry - kry, x + rx - krx, y, x + rx, y);\n  } else {\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + width, y);\n    ctx.lineTo(x + width, y + height);\n    ctx.lineTo(x, y + height);\n  }\n\n  ctx.closePath();\n\n  return node;\n};\n\nexport default renderRect;\n","import * as R from 'ramda';\n\nconst getProp = (p, v) => R.path(['props', p], v);\n\nconst renderLine = ctx => node => {\n  const x1 = getProp('x1', node);\n  const y1 = getProp('y1', node);\n  const x2 = getProp('x2', node);\n  const y2 = getProp('y2', node);\n\n  ctx.moveTo(x1, y1);\n  ctx.lineTo(x2, y2);\n\n  return node;\n};\n\nexport default renderLine;\n","import * as R from 'ramda';\n\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nconst getProp = (p, v) => R.path(['props', p], v);\n\nexport const drawEllipse = (ctx, cx, cy, rx, ry) => {\n  const x = cx - rx;\n  const y = cy - ry;\n  const ox = rx * KAPPA;\n  const oy = ry * KAPPA;\n  const xe = x + rx * 2;\n  const ye = y + ry * 2;\n  const xm = x + rx;\n  const ym = y + ry;\n\n  ctx.moveTo(x, ym);\n  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n  ctx.closePath();\n};\n\nconst renderEllipse = ctx =>\n  R.tap(node => {\n    const cx = getProp('cx', node);\n    const cy = getProp('cy', node);\n    const rx = getProp('rx', node);\n    const ry = getProp('ry', node);\n\n    drawEllipse(ctx, cx, cy, rx, ry);\n  });\n\nexport default renderEllipse;\n","import * as R from 'ramda';\n\nimport { drawEllipse } from './renderEllipse';\n\nconst getProp = (p, v) => R.path(['props', p], v);\n\nconst renderCircle = ctx =>\n  R.tap(node => {\n    const cx = getProp('cx', node);\n    const cy = getProp('cy', node);\n    const r = getProp('r', node);\n\n    drawEllipse(ctx, cx, cy, r, r);\n  });\n\nexport default renderCircle;\n","import * as R from 'ramda';\n\nimport runWidth from '@react-pdf/textkit/run/advanceWidth';\nimport lineWidth from '@react-pdf/textkit/attributedString/advanceWidth';\n\nconst renderRun = (ctx, run) => {\n  const runAdvanceWidth = runWidth(run);\n  const { font, fontSize, color, opacity } = run.attributes;\n\n  ctx.fillColor(color);\n  ctx.fillOpacity(opacity);\n\n  if (font.sbix || (font.COLR && font.CPAL)) {\n    ctx.save();\n    ctx.translate(0, -run.ascent);\n\n    for (let i = 0; i < run.glyphs.length; i++) {\n      const position = run.positions[i];\n      const glyph = run.glyphs[i];\n\n      ctx.save();\n      ctx.translate(position.xOffset, position.yOffset);\n\n      glyph.render(ctx, fontSize);\n\n      ctx.restore();\n      ctx.translate(position.xAdvance, position.yAdvance);\n    }\n\n    ctx.restore();\n  } else {\n    ctx.font(typeof font.name === 'string' ? font.name : font, fontSize);\n\n    try {\n      ctx._addGlyphs(run.glyphs, run.positions, 0, 0);\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  ctx.translate(runAdvanceWidth, 0);\n};\n\nconst renderSpan = (ctx, line, textAnchor) => {\n  ctx.save();\n\n  const x = R.pathOr(0, ['box', 'x'], line);\n  const y = R.pathOr(0, ['box', 'y'], line);\n  const width = lineWidth(line);\n\n  switch (textAnchor) {\n    case 'middle':\n      ctx.translate(x - width / 2, y);\n      break;\n    case 'end':\n      ctx.translate(x - width, y);\n      break;\n    default:\n      ctx.translate(x, y);\n      break;\n  }\n\n  for (const run of line.runs) {\n    renderRun(ctx, run);\n  }\n\n  ctx.restore();\n};\n\nconst renderSvgText = ctx => node => {\n  for (const span of node.children) {\n    renderSpan(ctx, span.lines[0], span.props.textAnchor);\n  }\n\n  return node;\n};\n\nexport default renderSvgText;\n","import * as R from 'ramda';\n\nconst isOdd = x => x % 2 !== 0;\n\nconst lengthIsOdd = R.o(isOdd, R.prop('length'));\n\nconst parsePoints = R.compose(\n  R.splitEvery(2),\n  R.map(parseFloat),\n  R.when(lengthIsOdd, R.slice(0, -1)),\n  R.split(/\\s+/),\n  R.replace(/(\\d)-(\\d)/g, '$1 -$2'),\n  R.replace(/,/g, ' '),\n  R.trim,\n);\n\nexport default parsePoints;\n","import * as R from 'ramda';\n\nimport parsePoints from '../svg/parsePoints';\n\nexport const drawPolyline = ctx => points => {\n  if (points.length > 0) {\n    ctx.moveTo(points[0][0], points[0][1]);\n    points.slice(1).forEach(p => ctx.lineTo(p[0], p[1]));\n  }\n};\n\nconst renderPolyline = ctx =>\n  R.tap(\n    R.compose(\n      drawPolyline(ctx),\n      parsePoints,\n      R.pathOr('', ['props', 'points']),\n    ),\n  );\n\nexport default renderPolyline;\n","import * as R from 'ramda';\n\nimport renderPolyline from './renderPolyline';\n\nconst closePath = ctx => R.tap(() => ctx.closePath());\n\nconst renderPolygon = ctx =>\n  R.compose(\n    closePath(ctx),\n    renderPolyline(ctx),\n  );\n\nexport default renderPolygon;\n","function printWarning(format, ...args) {\n  let argIndex = 0;\n  const message = 'Warning: ' + format.replace(/%s/g, () => args[argIndex++]);\n\n  if (typeof console !== 'undefined') {\n    console.error(message);\n  }\n\n  try {\n    throw new Error(message);\n  } catch (x) {}\n}\n\nconst __DEV__ = process.env.NODE_ENV !== 'production';\n\nconst warning = __DEV__\n  ? (condition, format, ...args) => {\n      if (format === undefined) {\n        throw new Error(\n          '`warning(condition, format, ...args)` requires a warning ' +\n            'message argument',\n        );\n      }\n      if (!condition) {\n        printWarning(format, ...args);\n      }\n    }\n  : () => {};\n\nexport default warning;\n","import * as R from 'ramda';\n\nimport save from './save';\nimport restore from './restore';\nimport warning from '../utils/warning';\n\nconst drawImage = ctx => node => {\n  const { x, y } = node.props;\n  const { width, height, opacity } = node.style;\n  const paddingTop = node.box.paddingLeft || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n\n  if (node.image.data) {\n    if (width !== 0 && height !== 0) {\n      ctx\n        .fillOpacity(opacity || 1)\n        .image(node.image.data, x + paddingLeft, y + paddingTop, {\n          width,\n          height,\n        });\n    } else {\n      warning(\n        false,\n        `Image with src '${node.props.href}' skipped due to invalid dimensions`,\n      );\n    }\n  }\n\n  return node;\n};\n\nconst renderImage = (ctx, node) => {\n  R.compose(\n    restore(ctx),\n    drawImage(ctx),\n    save(ctx),\n  )(node);\n\n  return node;\n};\n\nexport default R.curryN(2, renderImage);\n","import * as R from 'ramda';\n\n// TODO: Implement using only matrices to support skew and even more operations than css.\n\nconst getRotation = transform => {\n  const match = /rotate\\((-?\\d+.?\\d+)(.+)\\)/g.exec(transform);\n\n  if (match && match[1] && match[2]) {\n    const value = match[1];\n    return match[2] === 'rad' ? (value * 180) / Math.PI : value;\n  }\n\n  return 0;\n};\n\nconst getTranslateX = transform => {\n  const matchX = /translateX\\((-?\\d+\\.?d*)\\)/g.exec(transform);\n  const matchGeneric = /translate\\((-?\\d+\\.?d*).*(,|\\s)\\s*(-?\\d+\\.?d*).*\\)/g.exec(\n    transform,\n  );\n\n  if (matchX && matchX[1]) return matchX[1];\n  if (matchGeneric && matchGeneric[1]) return matchGeneric[1];\n\n  return 0;\n};\n\nconst getTranslateY = transform => {\n  const matchY = /translateY\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  const matchGeneric = /translate\\((-?\\d+\\.?\\d*).*(,|\\s)\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(\n    transform,\n  );\n\n  if (matchY && matchY[1]) return matchY[1];\n  if (matchGeneric && matchGeneric[3]) return matchGeneric[3];\n\n  return 0;\n};\n\nconst getScaleX = transform => {\n  const matchX = /scaleX\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  const matchGeneric = /scale\\((-?\\d+\\.?\\d*).*,?\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(\n    transform,\n  );\n\n  if (matchX && matchX[1]) return matchX[1];\n  if (matchGeneric && matchGeneric[1]) return matchGeneric[1];\n\n  return 1;\n};\n\nconst getScaleY = transform => {\n  const matchY = /scaleY\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  const matchGeneric = /scale\\((-?\\d+\\.?\\d*).*,?\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(\n    transform,\n  );\n\n  if (matchY && matchY[1]) return matchY[1];\n  if (matchGeneric && matchGeneric[2]) return matchGeneric[2];\n\n  return 1;\n};\n\nconst getMatrix = transform => {\n  const match = /matrix\\(([^,]+),([^,]+),([^,]+),([^,]+),([^,]+),([^,]+)\\)/g.exec(\n    transform,\n  );\n  if (match) return match.slice(1, 7);\n  return null;\n};\n\nconst applySingleTransformation = (ctx, transform, origin) => {\n  if (/rotate/g.test(transform)) {\n    ctx.rotate(getRotation(transform), { origin });\n  } else if (/scaleX/g.test(transform)) {\n    ctx.scale(getScaleX(transform), 1, { origin });\n  } else if (/scaleY/g.test(transform)) {\n    ctx.scale(1, getScaleY(transform), { origin });\n  } else if (/scale/g.test(transform)) {\n    ctx.scale(getScaleX(transform), getScaleY(transform), {\n      origin,\n    });\n  } else if (/translateX/g.test(transform)) {\n    ctx.translate(getTranslateX(transform), 1, { origin });\n  } else if (/translateY/g.test(transform)) {\n    ctx.translate(1, getTranslateY(transform), { origin });\n  } else if (/translate/g.test(transform)) {\n    ctx.translate(getTranslateX(transform), getTranslateY(transform), {\n      origin,\n    });\n  } else if (/matrix/g.test(transform)) {\n    ctx.transform(...getMatrix(transform));\n  }\n};\n\nconst applyTransformations = (ctx, node) => {\n  if (!node.origin) return node;\n\n  let match;\n  const re = /[a-zA-Z]+\\([^)]+\\)/g;\n  const origin = [node.origin.left, node.origin.top];\n  const transform =\n    (node.style && node.style.transform) ||\n    (node.props && node.props.transform) ||\n    '';\n\n  while ((match = re.exec(transform)) != null) {\n    applySingleTransformation(ctx, match[0], origin);\n  }\n\n  return node;\n};\n\nexport default R.curryN(2, applyTransformations);\n","import * as R from 'ramda';\n\nimport { PATH } from '../constants';\n\n/**\n * Checks if node is path\n *\n * @param {Object} node\n * @returns {Boolean} is node path?\n */\nconst isPath = R.propEq('type', PATH);\n\nexport default isPath;\n","import * as R from 'ramda';\n\nimport { RECT } from '../constants';\n\n/**\n * Checks if node is rect\n *\n * @param {Object} node\n * @returns {Boolean} is node rect?\n */\nconst isRect = R.propEq('type', RECT);\n\nexport default isRect;\n","import * as R from 'ramda';\n\nimport { LINE } from '../constants';\n\n/**\n * Checks if node is line\n *\n * @param {Object} node\n * @returns {Boolean} is node line?\n */\nconst isLine = R.propEq('type', LINE);\n\nexport default isLine;\n","import * as R from 'ramda';\n\nimport { TSPAN } from '../constants';\n\n/**\n * Checks if node is tspan\n *\n * @param {Object} node\n * @returns {Boolean} is node tspan?\n */\nconst isTspan = R.propEq('type', TSPAN);\n\nexport default isTspan;\n","import * as R from 'ramda';\n\nimport { GROUP } from '../constants';\n\n/**\n * Checks if node is group\n *\n * @param {Object} node\n * @returns {Boolean} is node group?\n */\nconst isGroup = R.propEq('type', GROUP);\n\nexport default isGroup;\n","import * as R from 'ramda';\n\nimport { CIRCLE } from '../constants';\n\n/**\n * Checks if node is circle\n *\n * @param {Object} node\n * @returns {Boolean} is node circle?\n */\nconst isCircle = R.propEq('type', CIRCLE);\n\nexport default isCircle;\n","import * as R from 'ramda';\n\nimport { TEXT_INSTANCE } from '../constants';\n\n/**\n * Checks if node is text intance\n *\n * @param {Object} node\n * @returns {Boolean} is node text intance?\n */\nconst isTextInstance = R.propEq('type', TEXT_INSTANCE);\n\nexport default isTextInstance;\n","import * as R from 'ramda';\n\nconst renderGroup = () => R.identity;\n\nexport default renderGroup;\n","import * as R from 'ramda';\n\nimport { ELLIPSE } from '../constants';\n\n/**\n * Checks if node is ellipse\n *\n * @param {Object} node\n * @returns {Boolean} is node ellipse?\n */\nconst isEllipse = R.propEq('type', ELLIPSE);\n\nexport default isEllipse;\n","import * as R from 'ramda';\n\nimport { POLYGON } from '../constants';\n\n/**\n * Checks if node is polygon\n *\n * @param {Object} node\n * @returns {Boolean} is node polygon?\n */\nconst isPolygon = R.propEq('type', POLYGON);\n\nexport default isPolygon;\n","import * as R from 'ramda';\n\nimport { POLYLINE } from '../constants';\n\n/**\n * Checks if node is polyline\n *\n * @param {Object} node\n * @returns {Boolean} is node polyline?\n */\nconst isPolyline = R.propEq('type', POLYLINE);\n\nexport default isPolyline;\n","import arcToCurve from 'svg-arc-to-cubic-bezier';\n\n// From https://github.com/jkroso/normalize-svg-path/blob/master/index.js\n// Copied here because an import issue with 'svg-arc-to-cubic-bezier'\nconst normalizePath = path => {\n  const result = [];\n\n  let prev;\n  let bezierX = 0;\n  let bezierY = 0;\n  let startX = 0;\n  let startY = 0;\n  let quadX = null;\n  let quadY = null;\n  let x = 0;\n  let y = 0;\n\n  for (let i = 0, len = path.length; i < len; i++) {\n    let seg = path[i];\n    const command = seg[0];\n\n    switch (command) {\n      case 'M':\n        startX = seg[1];\n        startY = seg[2];\n        break;\n      case 'A':\n        const curves = arcToCurve({\n          px: x,\n          py: y,\n          cx: seg[6],\n          cy: seg[7],\n          rx: seg[1],\n          ry: seg[2],\n          xAxisRotation: seg[3],\n          largeArcFlag: seg[4],\n          sweepFlag: seg[5],\n        });\n\n        // null-curves\n        if (!curves.length) continue;\n\n        for (let j = 0, c; j < curves.length; j++) {\n          c = curves[j];\n          seg = ['C', c.x1, c.y1, c.x2, c.y2, c.x, c.y];\n          if (j < curves.length - 1) result.push(seg);\n        }\n\n        break;\n      case 'S':\n        // default control point\n        let cx = x;\n        let cy = y;\n        if (prev === 'C' || prev === 'S') {\n          cx += cx - bezierX; // reflect the previous command's control\n          cy += cy - bezierY; // point relative to the current point\n        }\n        seg = ['C', cx, cy, seg[1], seg[2], seg[3], seg[4]];\n        break;\n      case 'T':\n        if (prev === 'Q' || prev === 'T') {\n          quadX = x * 2 - quadX; // as with 'S' reflect previous control point\n          quadY = y * 2 - quadY;\n        } else {\n          quadX = x;\n          quadY = y;\n        }\n        seg = quadratic(x, y, quadX, quadY, seg[1], seg[2]);\n        break;\n      case 'Q':\n        quadX = seg[1];\n        quadY = seg[2];\n        seg = quadratic(x, y, seg[1], seg[2], seg[3], seg[4]);\n        break;\n      case 'L':\n        seg = line(x, y, seg[1], seg[2]);\n        break;\n      case 'H':\n        seg = line(x, y, seg[1], y);\n        break;\n      case 'V':\n        seg = line(x, y, x, seg[1]);\n        break;\n      case 'Z':\n        seg = line(x, y, startX, startY);\n        break;\n      default:\n        break;\n    }\n\n    // update state\n    prev = command;\n    x = seg[seg.length - 2];\n    y = seg[seg.length - 1];\n    if (seg.length > 4) {\n      bezierX = seg[seg.length - 4];\n      bezierY = seg[seg.length - 3];\n    } else {\n      bezierX = x;\n      bezierY = y;\n    }\n    result.push(seg);\n  }\n\n  return result;\n};\n\nconst line = (x1, y1, x2, y2) => {\n  return ['C', x1, y1, x2, y2, x2, y2];\n};\n\nconst quadratic = (x1, y1, cx, cy, x2, y2) => {\n  return [\n    'C',\n    x1 / 3 + (2 / 3) * cx,\n    y1 / 3 + (2 / 3) * cy,\n    x2 / 3 + (2 / 3) * cx,\n    y2 / 3 + (2 / 3) * cy,\n    x2,\n    y2,\n  ];\n};\n\nexport default normalizePath;\n","import * as R from 'ramda';\nimport absPath from 'abs-svg-path';\nimport parsePath from 'parse-svg-path';\n\nimport isRect from '../node/isRect';\nimport isLine from '../node/isLine';\nimport isPath from '../node/isPath';\nimport isCircle from '../node/isCircle';\nimport isPolygon from '../node/isPolygon';\nimport isEllipse from '../node/isEllipse';\nimport isPolyline from '../node/isPolyline';\nimport normalizePath from '../svg/normalizePath';\nimport parsePoints from './parsePoints';\n\n// From https://github.com/dy/svg-path-bounds/blob/master/index.js\nconst getPathBoundingBox = node => {\n  const path = R.compose(\n    normalizePath,\n    absPath,\n    parsePath,\n    R.pathOr('', ['props', 'd']),\n  )(node);\n\n  if (!path.length) return [0, 0, 0, 0];\n\n  const bounds = [Infinity, Infinity, -Infinity, -Infinity];\n\n  for (let i = 0, l = path.length; i < l; i++) {\n    const points = path[i].slice(1);\n\n    for (let j = 0; j < points.length; j += 2) {\n      if (points[j + 0] < bounds[0]) bounds[0] = points[j + 0];\n      if (points[j + 1] < bounds[1]) bounds[1] = points[j + 1];\n      if (points[j + 0] > bounds[2]) bounds[2] = points[j + 0];\n      if (points[j + 1] > bounds[3]) bounds[3] = points[j + 1];\n    }\n  }\n\n  return bounds;\n};\n\nconst getCircleBoundingBox = node => {\n  const r = R.pathOr(0, ['props', 'r'], node);\n  const cx = R.pathOr(0, ['props', 'cx'], node);\n  const cy = R.pathOr(0, ['props', 'cy'], node);\n\n  return [cx - r, cy - r, cx + r, cy + r];\n};\n\nconst getEllipseBoundingBox = node => {\n  const cx = R.pathOr(0, ['props', 'cx'], node);\n  const cy = R.pathOr(0, ['props', 'cy'], node);\n  const rx = R.pathOr(0, ['props', 'rx'], node);\n  const ry = R.pathOr(0, ['props', 'ry'], node);\n\n  return [cx - rx, cy - ry, cx + rx, cy + ry];\n};\n\nconst getLineBoundingBox = node => {\n  const x1 = R.pathOr(0, ['props', 'x1'], node);\n  const y1 = R.pathOr(0, ['props', 'y1'], node);\n  const x2 = R.pathOr(0, ['props', 'x2'], node);\n  const y2 = R.pathOr(0, ['props', 'y2'], node);\n\n  return [R.min(x1, x2), R.min(y1, y2), R.max(x1, x2), R.max(y1, y2)];\n};\n\nconst getRectBoundingBox = node => {\n  const x = R.pathOr(0, ['props', 'x'], node);\n  const y = R.pathOr(0, ['props', 'y'], node);\n  const width = R.pathOr(0, ['props', 'width'], node);\n  const height = R.pathOr(0, ['props', 'height'], node);\n\n  return [x, y, x + width, y + height];\n};\n\nconst max = R.reduce(R.max, -Infinity);\nconst min = R.reduce(R.min, Infinity);\n\nconst getPolylineBoundingBox = node => {\n  const points = R.compose(\n    parsePoints,\n    R.pathOr([], ['props', 'points']),\n  )(node);\n\n  const xValues = R.pluck(0, points);\n  const yValues = R.pluck(1, points);\n\n  return [min(xValues), min(yValues), max(xValues), max(yValues)];\n};\n\nconst getBoundingBox = R.cond([\n  [isRect, getRectBoundingBox],\n  [isLine, getLineBoundingBox],\n  [isPath, getPathBoundingBox],\n  [isCircle, getCircleBoundingBox],\n  [isEllipse, getEllipseBoundingBox],\n  [isPolygon, getPolylineBoundingBox],\n  [isPolyline, getPolylineBoundingBox],\n  [R.T, R.always([0, 0, 0, 0])],\n]);\n\nexport default getBoundingBox;\n","import * as R from 'ramda';\n\nimport save from './save';\nimport restore from './restore';\nimport clipNode from './clipNode';\nimport renderPath from './renderPath';\nimport renderRect from './renderRect';\nimport renderLine from './renderLine';\nimport renderCircle from './renderCircle';\nimport renderSvgText from './renderSvgText';\nimport renderEllipse from './renderEllipse';\nimport renderPolygon from './renderPolygon';\nimport renderPolyline from './renderPolyline';\nimport renderSvgImage from './renderSvgImage';\nimport applyTransformations from './applyTransformations';\nimport isPath from '../node/isPath';\nimport isText from '../node/isText';\nimport isRect from '../node/isRect';\nimport isLine from '../node/isLine';\nimport isTspan from '../node/isTspan';\nimport isImage from '../node/isImage';\nimport isGroup from '../node/isGroup';\nimport isCircle from '../node/isCircle';\nimport isTextInstance from '../node/isTextInstance';\nimport renderGroup from './renderGroup';\nimport isEllipse from '../node/isEllipse';\nimport isPolygon from '../node/isPolygon';\nimport isPolyline from '../node/isPolyline';\nimport getBoundingBox from '../svg/getBoundingBox';\nimport { LINEAR_GRADIENT, RADIAL_GRADIENT } from '../constants';\n\nconst warnUnsupportedNode = R.tap(node => {\n  console.warn(`SVG node of type ${node.type} is not currenty supported`);\n});\n\nconst getProp = (d, p, v) => R.pathOr(d, ['props', p], v);\n\nconst setStrokeWidth = ctx => node => {\n  const lineWidth = getProp(0, 'strokeWidth', node);\n  if (lineWidth) ctx.lineWidth(lineWidth);\n  return node;\n};\n\nconst setStrokeColor = ctx => node => {\n  const strokeColor = getProp(null, 'stroke', node);\n  if (strokeColor) ctx.strokeColor(strokeColor);\n  return node;\n};\n\nconst setOpacity = ctx => node => {\n  const opacity = getProp(null, 'opacity', node);\n  if (opacity) ctx.opacity(opacity);\n  return node;\n};\n\nconst setFillOpacity = ctx => node => {\n  const fillOpacity = getProp(null, 'fillOpacity', node);\n  if (fillOpacity) ctx.fillOpacity(fillOpacity);\n  return node;\n};\n\nconst setStrokeOpacity = ctx => node => {\n  const strokeOpacity = getProp(null, 'strokeOpacity', node);\n  if (strokeOpacity) ctx.strokeOpacity(strokeOpacity);\n  return node;\n};\n\nconst setLineJoin = ctx => node => {\n  const lineJoin = getProp(null, 'strokeLinejoin', node);\n  if (lineJoin) ctx.lineJoin(lineJoin);\n  return node;\n};\n\nconst setLineCap = ctx => node => {\n  const lineCap = getProp(null, 'strokeLinecap', node);\n  if (lineCap) ctx.lineCap(lineCap);\n  return node;\n};\n\nconst setLineDash = ctx => node => {\n  const value = getProp(null, 'strokeDasharray', node);\n\n  if (value) {\n    const dashArray = R.compose(\n      R.map(R.o(parseFloat, R.trim)),\n      R.split(','),\n    )(value);\n\n    ctx.dash(dashArray[0], { space: dashArray[1] });\n  }\n  return node;\n};\n\nconst hasLinearGradientFill = R.pathEq(\n  ['props', 'fill', 'type'],\n  LINEAR_GRADIENT,\n);\n\nconst hasRadialGradientFill = R.pathEq(\n  ['props', 'fill', 'type'],\n  RADIAL_GRADIENT,\n);\n\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L104\nconst setLinearGradientFill = ctx =>\n  R.tap(node => {\n    const bbox = getBoundingBox(node);\n    const gradient = getProp(null, 'fill', node);\n\n    const x1 = R.pathOr(0, ['props', 'x1'], gradient);\n    const y1 = R.pathOr(0, ['props', 'y1'], gradient);\n    const x2 = R.pathOr(1, ['props', 'x2'], gradient);\n    const y2 = R.pathOr(0, ['props', 'y2'], gradient);\n\n    const m0 = bbox[2] - bbox[0];\n    const m3 = bbox[3] - bbox[1];\n    const m4 = bbox[0];\n    const m5 = bbox[1];\n\n    const gx1 = m0 * x1 + m4;\n    const gy1 = m3 * y1 + m5;\n    const gx2 = m0 * x2 + m4;\n    const gy2 = m3 * y2 + m5;\n\n    const grad = ctx.linearGradient(gx1, gy1, gx2, gy2);\n\n    gradient.children.forEach(stop => {\n      grad.stop(\n        stop.props.offset,\n        stop.props.stopColor,\n        stop.props.stopOpacity,\n      );\n    });\n\n    ctx.fill(grad);\n  });\n\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L155\nconst setRadialGradientFill = ctx =>\n  R.tap(node => {\n    const bbox = getBoundingBox(node);\n    const gradient = getProp(null, 'fill', node);\n\n    const cx = R.pathOr(0.5, ['props', 'cx'], gradient);\n    const cy = R.pathOr(0.5, ['props', 'cy'], gradient);\n    const fx = R.pathOr(cx, ['props', 'fx'], gradient);\n    const fy = R.pathOr(cy, ['props', 'fy'], gradient);\n    const r = R.pathOr(0.5, ['props', 'r'], gradient);\n\n    const m0 = bbox[2] - bbox[0];\n    const m3 = bbox[3] - bbox[1];\n    const m4 = bbox[0];\n    const m5 = bbox[1];\n\n    const gr = r * m0;\n    const gcx = m0 * cx + m4;\n    const gcy = m3 * cy + m5;\n    const gfx = m0 * fx + m4;\n    const gfy = m3 * fy + m5;\n\n    const grad = ctx.radialGradient(gfx, gfy, 0, gcx, gcy, gr);\n\n    gradient.children.forEach(stop => {\n      grad.stop(\n        stop.props.offset,\n        stop.props.stopColor,\n        stop.props.stopOpacity,\n      );\n    });\n\n    ctx.fill(grad);\n  });\n\nconst setFillColor = ctx =>\n  R.tap(node => {\n    const fillColor = getProp(null, 'fill', node);\n    if (fillColor) ctx.fillColor(fillColor);\n  });\n\nconst setFill = ctx =>\n  R.cond([\n    [hasLinearGradientFill, setLinearGradientFill(ctx)],\n    [hasRadialGradientFill, setRadialGradientFill(ctx)],\n    [R.T, setFillColor(ctx)],\n  ]);\n\nconst draw = ctx => node => {\n  const props = R.propOr({}, 'props', node);\n\n  if (props.fill && props.stroke) {\n    ctx.fillAndStroke(props.fillRule);\n  } else if (props.fill) {\n    ctx.fill(props.fillRule);\n  } else if (props.stroke) {\n    ctx.stroke();\n  } else {\n    ctx.save();\n    ctx.opacity(0);\n    ctx.fill(null);\n    ctx.restore();\n  }\n\n  return node;\n};\n\nconst renderNode = ctx =>\n  R.cond([\n    [isTspan, R.identity],\n    [isTextInstance, R.identity],\n    [isPath, renderPath(ctx)],\n    [isRect, renderRect(ctx)],\n    [isLine, renderLine(ctx)],\n    [isGroup, renderGroup(ctx)],\n    [isText, renderSvgText(ctx)],\n    [isCircle, renderCircle(ctx)],\n    [isImage, renderSvgImage(ctx)],\n    [isEllipse, renderEllipse(ctx)],\n    [isPolygon, renderPolygon(ctx)],\n    [isPolyline, renderPolyline(ctx)],\n    [R.T, warnUnsupportedNode],\n  ]);\n\nconst drawNode = ctx =>\n  R.compose(\n    draw(ctx),\n    renderNode(ctx),\n    applyTransformations(ctx),\n    setOpacity(ctx),\n    setFillOpacity(ctx),\n    setStrokeOpacity(ctx),\n    setFill(ctx),\n    setStrokeColor(ctx),\n    setStrokeWidth(ctx),\n    setLineJoin(ctx),\n    setLineDash(ctx),\n    setLineCap(ctx),\n  );\n\nconst clipPath = ctx => node => {\n  const value = R.path(['props', 'clipPath'], node);\n\n  if (value) {\n    R.compose(\n      () => ctx.clip(),\n      R.forEach(renderNode(ctx)),\n      R.propOr([], 'children'),\n    )(value);\n  }\n\n  return node;\n};\n\nconst drawChildren = ctx => node =>\n  R.compose(\n    R.map(\n      R.compose(\n        restore(ctx),\n        drawChildren(ctx),\n        drawNode(ctx),\n        clipPath(ctx),\n        save(ctx),\n      ),\n    ),\n    R.propOr([], 'children'),\n  )(node);\n\nconst defaultsZero = R.pathOr(0);\n\nconst preserveAspectRatio = ctx => node => {\n  const { width, height } = node.box;\n  const { viewBox, preserveAspectRatio = {} } = node.props;\n  const { meetOrSlice = 'meet', align = 'xMidYMid' } = preserveAspectRatio;\n\n  if (viewBox == null || width == null || height == null) return node;\n\n  const x = viewBox ? viewBox.minX : 0;\n  const y = viewBox ? viewBox.minY : 0;\n  const logicalWidth = viewBox ? viewBox.maxX : width;\n  const logicalHeight = viewBox ? viewBox.maxY : height;\n\n  const logicalRatio = logicalWidth / logicalHeight;\n  const physicalRatio = width / height;\n  const scaleX = width / logicalWidth;\n  const scaleY = height / logicalHeight;\n\n  if (align === 'none') {\n    ctx.scale(scaleX, scaleY);\n    ctx.translate(-x, -y);\n    return node;\n  }\n\n  if (\n    (logicalRatio < physicalRatio && meetOrSlice === 'meet') ||\n    (logicalRatio >= physicalRatio && meetOrSlice === 'slice')\n  ) {\n    ctx.scale(scaleY, scaleY);\n\n    switch (align) {\n      case 'xMinYMin':\n      case 'xMinYMid':\n      case 'xMinYMax':\n        ctx.translate(-x, -y);\n        break;\n\n      case 'xMidYMin':\n      case 'xMidYMid':\n      case 'xMidYMax':\n        ctx.translate(\n          -x - (logicalWidth - (width * logicalHeight) / height) / 2,\n          -y,\n        );\n        break;\n\n      default:\n        ctx.translate(\n          -x - (logicalWidth - (width * logicalHeight) / height),\n          -y,\n        );\n    }\n  } else {\n    ctx.scale(scaleX, scaleX);\n\n    switch (align) {\n      case 'xMinYMin':\n      case 'xMidYMin':\n      case 'xMaxYMin':\n        ctx.translate(-x, -y);\n        break;\n\n      case 'xMinYMid':\n      case 'xMidYMid':\n      case 'xMaxYMid':\n        ctx.translate(\n          -x,\n          -y - (logicalHeight - (height * logicalWidth) / width) / 2,\n        );\n        break;\n\n      default:\n        ctx.translate(\n          -x,\n          -y - (logicalHeight - (height * logicalWidth) / width),\n        );\n    }\n  }\n\n  return node;\n};\n\nconst moveToOrigin = ctx => node => {\n  const { top, left } = node.box;\n\n  const paddingLeft = defaultsZero('paddingLeft', node.box);\n  const paddingTop = defaultsZero('paddingTop', node.box);\n\n  ctx.translate(left + paddingLeft, top + paddingTop);\n\n  return node;\n};\n\nconst renderSvg = (ctx, node) => {\n  R.compose(\n    restore(ctx),\n    drawChildren(ctx),\n    preserveAspectRatio(ctx),\n    moveToOrigin(ctx),\n    clipNode(ctx),\n    save(ctx),\n  )(node);\n\n  return node;\n};\n\nexport default R.curryN(2, renderSvg);\n","import * as R from 'ramda';\nimport PDFRenderer from '@react-pdf/textkit/renderers/pdf';\n\nconst renderText = (ctx, node) => {\n  const { top, left } = node.box;\n  const paddingTop = R.pathOr(0, ['box', 'paddingTop'], node);\n  const paddingLeft = R.pathOr(0, ['box', 'paddingLeft'], node);\n  const initialY = node.lines[0] ? node.lines[0].box.y : 0;\n\n  ctx.save();\n  ctx.translate(left + paddingLeft, top + paddingTop - initialY);\n\n  PDFRenderer.render(ctx, [node.lines]);\n  ctx.restore();\n\n  return node;\n};\n\nexport default R.curryN(2, renderText);\n","import * as R from 'ramda';\n\nconst renderPage = (ctx, node) => {\n  const { width, height } = node.box;\n\n  ctx.addPage({ size: [width, height], margin: 0 });\n\n  return node;\n};\n\nexport default R.curryN(2, renderPage);\n","import * as R from 'ramda';\n\nconst renderNote = (ctx, node) => {\n  const { top, left } = node.box;\n  const value = node.children[0] ? node.children[0].value : '';\n\n  ctx.note(left, top, 0, 0, value);\n\n  return node;\n};\n\nexport default R.curryN(2, renderNote);\n","const isPercent = value => /((-)?\\d+\\.?\\d*)%/g.exec(value);\n\n/**\n * Get percentage value of input\n *\n * @param {String} value\n * @returns {Object} percent value (if matches)\n */\nconst matchPercent = value => {\n  const match = isPercent(value);\n\n  if (match) {\n    const value = parseFloat(match[1], 10);\n    const percent = value / 100;\n\n    return {\n      value,\n      percent,\n      absValue: Math.abs(value),\n      absPercent: Math.abs(percent),\n    };\n  }\n\n  return null;\n};\n\nexport default matchPercent;\n","import matchPercent from '../utils/matchPercent';\n\nconst isNumeric = n => {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n};\n\nconst applyContainObjectFit = (cw, ch, iw, ih, px, py) => {\n  const cr = cw / ch;\n  const ir = iw / ih;\n\n  const pxp = matchPercent(px);\n  const pyp = matchPercent(py);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n\n  if (cr > ir) {\n    const height = ch;\n    const width = height * ir;\n    const yOffset = isNumeric(py) ? py : 0;\n    const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n\n    return { width, height, xOffset, yOffset };\n  } else {\n    const width = cw;\n    const height = width / ir;\n    const xOffset = isNumeric(px) ? px : 0;\n    const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n\n    return { width, height, yOffset, xOffset };\n  }\n};\n\nconst applyNoneObjectFit = (cw, ch, iw, ih, px, py) => {\n  const width = iw;\n  const height = ih;\n  const pxp = matchPercent(px);\n  const pyp = matchPercent(py);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n  const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n  const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n\n  return { width, height, xOffset, yOffset };\n};\n\nconst applyCoverObjectFit = (cw, ch, iw, ih, px, py) => {\n  const ir = iw / ih;\n  const cr = cw / ch;\n\n  const pxp = matchPercent(px);\n  const pyp = matchPercent(py);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n\n  if (cr > ir) {\n    const width = cw;\n    const height = width / ir;\n    const xOffset = isNumeric(px) ? px : 0;\n    const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n    return { width, height, yOffset, xOffset };\n  } else {\n    const height = ch;\n    const width = height * ir;\n    const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n    const yOffset = isNumeric(py) ? py : 0;\n    return { width, height, xOffset, yOffset };\n  }\n};\n\nconst applyScaleDownObjectFit = (cw, ch, iw, ih, px, py) => {\n  const containDimension = applyContainObjectFit(cw, ch, iw, ih, px, py);\n  const noneDimension = applyNoneObjectFit(cw, ch, iw, ih, px, py);\n\n  return containDimension.width < noneDimension.width\n    ? containDimension\n    : noneDimension;\n};\n\nconst applyFillObjectFit = (cw, ch, px, py) => {\n  return {\n    width: cw,\n    height: ch,\n    xOffset: matchPercent(px) ? 0 : px || 0,\n    yOffset: matchPercent(py) ? 0 : py || 0,\n  };\n};\n\nconst resolveObjectFit = (type = 'fill', cw, ch, iw, ih, px, py) => {\n  switch (type) {\n    case 'contain':\n      return applyContainObjectFit(cw, ch, iw, ih, px, py);\n    case 'cover':\n      return applyCoverObjectFit(cw, ch, iw, ih, px, py);\n    case 'none':\n      return applyNoneObjectFit(cw, ch, iw, ih, px, py);\n    case 'scale-down':\n      return applyScaleDownObjectFit(cw, ch, iw, ih, px, py);\n    default:\n      return applyFillObjectFit(cw, ch, px, py);\n  }\n};\n\nexport default resolveObjectFit;\n","import * as R from 'ramda';\n\nimport save from './save';\nimport restore from './restore';\nimport clipNode from './clipNode';\nimport warning from '../utils/warning';\nimport resolveObjectFit from '../image/resolveObjectFit';\n\nconst drawImage = ctx => node => {\n  const { left, top } = node.box;\n  const { opacity, objectPositionX, objectPositionY } = node.style;\n  const paddingTop = node.box.paddingLeft || 0;\n  const paddingRight = node.box.paddingRight || 0;\n  const paddingBottom = node.box.paddingBottom || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n\n  const { width, height, xOffset, yOffset } = resolveObjectFit(\n    node.style.objectFit,\n    node.box.width - paddingLeft - paddingRight,\n    node.box.height - paddingTop - paddingBottom,\n    node.image.width,\n    node.image.height,\n    objectPositionX,\n    objectPositionY,\n  );\n\n  if (node.image.data) {\n    if (width !== 0 && height !== 0) {\n      ctx\n        .fillOpacity(opacity || 1)\n        .image(\n          node.image.data,\n          left + paddingLeft + xOffset,\n          top + paddingTop + yOffset,\n          {\n            width,\n            height,\n          },\n        );\n    } else {\n      warning(\n        false,\n        `Image with src '${node.props.src}' skipped due to invalid dimensions`,\n      );\n    }\n  }\n\n  return node;\n};\n\nconst renderImage = (ctx, node) => {\n  R.compose(\n    restore(ctx),\n    drawImage(ctx),\n    clipNode(ctx),\n    save(ctx),\n  )(node);\n\n  return node;\n};\n\nexport default R.curryN(2, renderImage);\n","export const availableMethods = [\n  'dash',\n  'clip',\n  'save',\n  'path',\n  'fill',\n  'font',\n  'text',\n  'rect',\n  'scale',\n  'moveTo',\n  'lineTo',\n  'stroke',\n  'rotate',\n  'circle',\n  'lineCap',\n  'opacity',\n  'ellipse',\n  'polygon',\n  'restore',\n  'lineJoin',\n  'fontSize',\n  'fillColor',\n  'lineWidth',\n  'translate',\n  'miterLimit',\n  'strokeColor',\n  'fillOpacity',\n  'roundedRect',\n  'strokeOpacity',\n  'bezierCurveTo',\n  'quadraticCurveTo',\n  'linearGradient',\n  'radialGradient',\n];\n\nconst painter = function(ctx) {\n  const p = availableMethods.reduce(\n    (acc, prop) => ({\n      ...acc,\n      [prop]: (...args) => {\n        ctx[prop](...args);\n        return p;\n      },\n    }),\n    {},\n  );\n\n  return p;\n};\n\nexport default painter;\n","import * as R from 'ramda';\n\nimport painter from '../canvas/painter';\nimport warning from '../utils/warning';\n\nconst defaultsZero = R.pathOr(0);\n\nconst renderCanvas = (ctx, node) => {\n  const { top, left, width, height } = node.box;\n\n  const paddingLeft = defaultsZero('paddingLeft', node.box);\n  const paddingRight = defaultsZero('paddingRight', node.box);\n  const paddingTop = defaultsZero('paddingTop', node.box);\n  const paddingBottom = defaultsZero('paddingBottom', node.box);\n\n  const availableWidth = width - paddingLeft - paddingRight;\n  const availableHeight = height - paddingTop - paddingBottom;\n\n  warning(\n    availableWidth && availableHeight,\n    'Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it.',\n  );\n\n  ctx.save().translate(left + paddingLeft, top + paddingTop);\n\n  if (node.props.paint) {\n    node.props.paint(painter(ctx), availableWidth, availableHeight);\n  }\n\n  ctx.restore();\n\n  return node;\n};\n\nexport default R.curryN(2, renderCanvas);\n","import * as R from 'ramda';\n\n/**\n * Checks if page should render vertical ruler\n *\n * @param {Object} page\n * @returns {boolean} has vertical ruler\n */\nconst hasVerticalRuler = R.either(\n  R.hasPath(['props', 'ruler']),\n  R.hasPath(['props', 'verticalRuler']),\n);\n\nexport default hasVerticalRuler;\n","import * as R from 'ramda';\n\n/**\n * Checks if page should render horizontal ruler\n *\n * @param {Object} page\n * @returns {boolean} has horizontal ruler\n */\nconst hasHorizontalRuler = R.either(\n  R.hasPath(['props', 'ruler']),\n  R.hasPath(['props', 'horizontalRuler']),\n);\n\nexport default hasHorizontalRuler;\n","import * as R from 'ramda';\n\nimport matchPercent from '../utils/matchPercent';\nimport hasVerticalRuler from '../node/hasVerticalRuler';\nimport hasHorizontalRuler from '../node/hasHorizontalRuler';\nimport {\n  RULER_WIDTH,\n  RULER_COLOR,\n  LINE_COLOR,\n  GRID_COLOR,\n  LINE_WIDTH,\n  RULER_FONT_SIZE,\n  DEFAULT_RULER_STEPS,\n} from '../constants';\n\nconst range = (max, steps) =>\n  Array.from({ length: Math.ceil(max / steps) }, (_, i) => i * steps);\n\nconst matchPercentage = value => {\n  const match = matchPercent(value);\n  return match ? 100 / match.value : null;\n};\n\nconst getVerticalSteps = page => {\n  const value =\n    page.props.horizontalRulerSteps ||\n    page.props.rulerSteps ||\n    DEFAULT_RULER_STEPS;\n\n  if (typeof value === 'string') {\n    const percentage = matchPercentage(value);\n    if (percentage) {\n      const width = page.box.width - (hasVerticalRuler(page) ? RULER_WIDTH : 0);\n      return width / percentage;\n    }\n    throw new Error('Page: Invalid horizontal steps value');\n  }\n\n  return value;\n};\n\nconst getHorizontalSteps = page => {\n  const value =\n    page.props.verticalRulerSteps ||\n    page.props.rulerSteps ||\n    DEFAULT_RULER_STEPS;\n\n  if (typeof value === 'string') {\n    const percentage = matchPercentage(value);\n    if (percentage) {\n      const height =\n        page.box.height - (hasVerticalRuler(page) ? RULER_WIDTH : 0);\n      return height / percentage;\n    }\n    throw new Error('Page: Invalid horizontal steps value');\n  }\n\n  return value;\n};\n\nconst renderVerticalRuler = ctx => page => {\n  const width = page.box.width;\n  const height = page.box.height;\n  const offset = hasHorizontalRuler(page) ? RULER_WIDTH : 0;\n  const hRange = range(width, getVerticalSteps(page));\n\n  ctx\n    .rect(offset, 0, width, RULER_WIDTH)\n    .fill(RULER_COLOR)\n    .moveTo(offset, RULER_WIDTH)\n    .lineTo(width, RULER_WIDTH)\n    .stroke(LINE_COLOR);\n\n  hRange.map(step => {\n    ctx\n      .moveTo(offset + step, 0)\n      .lineTo(offset + step, RULER_WIDTH)\n      .stroke(LINE_COLOR)\n      .fillColor('black')\n      .text(`${Math.round(step)}`, offset + step + 1, 1);\n\n    if (step !== 0) {\n      ctx\n        .moveTo(offset + step, RULER_WIDTH)\n        .lineTo(offset + step, height)\n        .stroke(GRID_COLOR);\n    }\n  });\n\n  return page;\n};\n\nconst renderHorizontalRuler = ctx => page => {\n  const width = page.box.width;\n  const height = page.box.height;\n  const offset = hasVerticalRuler(page) ? RULER_WIDTH : 0;\n  const hRange = range(height, getHorizontalSteps(page));\n\n  ctx\n    .rect(0, offset, RULER_WIDTH, height)\n    .fill(RULER_COLOR)\n    .moveTo(RULER_WIDTH, hasHorizontalRuler(page) ? RULER_WIDTH : 0)\n    .lineTo(RULER_WIDTH, height)\n    .stroke(LINE_COLOR);\n\n  hRange.map(step => {\n    ctx\n      .moveTo(0, offset + step)\n      .lineTo(RULER_WIDTH, offset + step)\n      .stroke(LINE_COLOR)\n      .fillColor('black')\n      .text(`${Math.round(step)}`, 1, offset + step + 1);\n\n    if (step !== 0) {\n      ctx\n        .moveTo(RULER_WIDTH, offset + step)\n        .lineTo(width, offset + step)\n        .stroke(GRID_COLOR);\n    }\n  });\n\n  return page;\n};\n\nconst renderRulers = (ctx, page) => {\n  ctx\n    .save()\n    .lineWidth(LINE_WIDTH)\n    .fontSize(RULER_FONT_SIZE)\n    .opacity(1);\n\n  R.compose(\n    R.when(hasVerticalRuler, renderVerticalRuler(ctx)),\n    R.when(hasHorizontalRuler, renderHorizontalRuler(ctx)),\n  )(page);\n\n  ctx.restore();\n\n  return page;\n};\n\nexport default R.curryN(2, renderRulers);\n","import * as R from 'ramda';\n\nconst getDocumentProp = target => (or, prop) =>\n  R.pathOr(or, ['props', prop], target);\n\nconst setPDFMetadata = target => (key, value) => {\n  if (value) target.info[key] = value;\n};\n\n/**\n * Set document instance metadata\n *\n * @param {Object} ctx document instance\n * @param {Object} doc document root\n */\nconst addMetadata = (ctx, doc) => {\n  const getProp = getDocumentProp(doc);\n  const setProp = setPDFMetadata(ctx);\n\n  const title = getProp(null, 'title');\n  const author = getProp(null, 'author');\n  const subject = getProp(null, 'subject');\n  const keywords = getProp(null, 'keywords');\n  const creator = getProp('react-pdf', 'creator');\n  const producer = getProp('react-pdf', 'producer');\n\n  setProp('Title', title);\n  setProp('Author', author);\n  setProp('Subject', subject);\n  setProp('Keywords', keywords);\n  setProp('Creator', creator);\n  setProp('Producer', producer);\n\n  return doc;\n};\n\nexport default R.curryN(2, addMetadata);\n","import * as R from 'ramda';\n\nimport save from './save';\nimport restore from './restore';\n\nconst CONTENT_COLOR = '#a1c6e7';\nconst PADDING_COLOR = '#c4deb9';\nconst MARGIN_COLOR = '#f8cca1';\n\nconst shouldDebug = R.pathEq(['props', 'debug'], true);\n\n// TODO: Draw debug boxes using clipping to enhance quality\n\nconst debugContent = ctx =>\n  R.tap(node => {\n    const {\n      left,\n      top,\n      width,\n      height,\n      paddingLeft,\n      paddingTop,\n      paddingRight,\n      paddingBottom,\n      borderLeftWidth,\n      borderTopWidth,\n      borderRightWidth,\n      borderBottomWidth,\n    } = node.box;\n\n    ctx\n      .fillColor(CONTENT_COLOR)\n      .opacity(0.5)\n      .rect(\n        left + paddingLeft + borderLeftWidth,\n        top + paddingTop + borderTopWidth,\n        width - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth,\n        height -\n          paddingTop -\n          paddingBottom -\n          borderTopWidth -\n          borderBottomWidth,\n      )\n      .fill();\n  });\n\nconst debugPadding = ctx =>\n  R.tap(node => {\n    const {\n      left,\n      top,\n      width,\n      height,\n      paddingLeft,\n      paddingTop,\n      paddingRight,\n      paddingBottom,\n      borderLeftWidth,\n      borderTopWidth,\n      borderRightWidth,\n      borderBottomWidth,\n    } = node.box;\n\n    ctx.fillColor(PADDING_COLOR).opacity(0.5);\n\n    // Padding top\n    ctx\n      .rect(\n        left + paddingLeft + borderLeftWidth,\n        top + borderTopWidth,\n        width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth,\n        paddingTop,\n      )\n      .fill();\n\n    // Padding left\n    ctx\n      .rect(\n        left + borderLeftWidth,\n        top + borderTopWidth,\n        paddingLeft,\n        height - borderTopWidth - borderBottomWidth,\n      )\n      .fill();\n\n    // Padding right\n    ctx\n      .rect(\n        left + width - paddingRight - borderRightWidth,\n        top + borderTopWidth,\n        paddingRight,\n        height - borderTopWidth - borderBottomWidth,\n      )\n      .fill();\n\n    // Padding bottom\n    ctx\n      .rect(\n        left + paddingLeft + borderLeftWidth,\n        top + height - paddingBottom - borderBottomWidth,\n        width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth,\n        paddingBottom,\n      )\n      .fill();\n  });\n\nconst debugMargin = ctx =>\n  R.tap(node => {\n    const {\n      left,\n      top,\n      width,\n      height,\n      marginLeft,\n      marginTop,\n      marginRight,\n      marginBottom,\n    } = node.box;\n    ctx.fillColor(MARGIN_COLOR).opacity(0.5);\n\n    // Margin top\n    ctx.rect(left, top - marginTop, width, marginTop).fill();\n\n    // Margin left\n    ctx\n      .rect(\n        left - marginLeft,\n        top - marginTop,\n        marginLeft,\n        height + marginTop + marginBottom,\n      )\n      .fill();\n\n    // Margin right\n    ctx\n      .rect(\n        left + width,\n        top - marginTop,\n        marginRight,\n        height + marginTop + marginBottom,\n      )\n      .fill();\n\n    // Margin bottom\n    ctx.rect(left, top + height, width, marginBottom).fill();\n  });\n\nconst debugText = ctx =>\n  R.tap(node => {\n    const {\n      left,\n      top,\n      width,\n      height,\n      marginLeft,\n      marginTop,\n      marginRight,\n      marginBottom,\n    } = node.box;\n\n    const roundedWidth = Math.round(width + marginLeft + marginRight);\n    const roundedHeight = Math.round(height + marginTop + marginBottom);\n\n    ctx\n      .fontSize(4)\n      .opacity(1)\n      .fillColor('black')\n      .text(\n        `${roundedWidth} x ${roundedHeight}`,\n        left - marginLeft,\n        Math.max(top - marginTop - 4, 1),\n      );\n  });\n\nconst debugOrigin = ctx =>\n  R.tap(node => {\n    if (node.origin) {\n      ctx\n        .circle(node.origin.left, node.origin.top, 3)\n        .fill('red')\n        .circle(node.origin.left, node.origin.top, 5)\n        .stroke('red');\n    }\n  });\n\nconst renderDebug = ctx =>\n  R.tap(\n    R.when(\n      shouldDebug,\n      R.compose(\n        restore(ctx),\n        debugOrigin(ctx),\n        debugText(ctx),\n        debugMargin(ctx),\n        debugPadding(ctx),\n        debugContent(ctx),\n        save(ctx),\n      ),\n    ),\n  );\n\nexport default renderDebug;\n","import * as R from 'ramda';\n\n// Ref: https://www.w3.org/TR/css-backgrounds-3/#borders\n\n// This constant is used to approximate a symmetrical arc using a cubic Bezier curve.\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nconst clipBorderTop = (ctx, layout, style, rtr, rtl) => {\n  const { top, left, width, height } = layout;\n  const { borderTopWidth, borderRightWidth, borderLeftWidth } = style;\n\n  // Clip outer top border edge\n  ctx.moveTo(left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n\n  // Ellipse coefficients outer top right cap\n  const c0 = rtr * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(\n    left + width - c0,\n    top,\n    left + width,\n    top + c0,\n    left + width,\n    top + rtr,\n  );\n\n  // Move down in case the margin exceedes the radius\n  const topRightYCoord = top + Math.max(borderTopWidth, rtr);\n  ctx.lineTo(left + width, topRightYCoord);\n\n  // Clip inner top right cap\n  ctx.lineTo(left + width - borderRightWidth, topRightYCoord);\n\n  // Ellipse coefficients inner top right cap\n  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  const c1 = innerTopRightRadiusX * (1.0 - KAPPA);\n  const c2 = innerTopRightRadiusY * (1.0 - KAPPA);\n\n  // Clip inner top right cap\n  ctx.bezierCurveTo(\n    left + width - borderRightWidth,\n    top + borderTopWidth + c2,\n    left + width - borderRightWidth - c1,\n    top + borderTopWidth,\n    left + width - borderRightWidth - innerTopRightRadiusX,\n    top + borderTopWidth,\n  );\n\n  // Clip inner top border edge\n  ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth);\n\n  // Ellipse coefficients inner top left cap\n  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  const c3 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  const c4 = innerTopLeftRadiusY * (1.0 - KAPPA);\n  const topLeftYCoord = top + Math.max(borderTopWidth, rtl);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(\n    left + borderLeftWidth + c3,\n    top + borderTopWidth,\n    left + borderLeftWidth,\n    top + borderTopWidth + c4,\n    left + borderLeftWidth,\n    topLeftYCoord,\n  );\n  ctx.lineTo(left, topLeftYCoord);\n\n  // Move down in case the margin exceedes the radius\n  ctx.lineTo(left, top + rtl);\n\n  // Ellipse coefficients outer top left cap\n  const c5 = rtl * (1.0 - KAPPA);\n\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border top cap joins\n  if (borderRightWidth) {\n    const trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderLeftWidth) {\n    const trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nconst fillBorderTop = (ctx, layout, style, rtr, rtl) => {\n  const { top, left, width } = layout;\n  const {\n    borderTopColor,\n    borderTopWidth,\n    borderTopStyle,\n    borderRightWidth,\n    borderLeftWidth,\n  } = style;\n\n  const c0 = rtl * (1.0 - KAPPA);\n  const c1 = rtr * (1.0 - KAPPA);\n\n  ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(\n    left + width - c1,\n    top,\n    left + width,\n    top + c1,\n    left + width,\n    top + rtr,\n  );\n\n  ctx.strokeColor(borderTopColor);\n  ctx.lineWidth(\n    Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2,\n  );\n\n  if (borderTopStyle === 'dashed') {\n    ctx.dash(borderTopWidth * 2, { space: borderTopWidth * 1.2 });\n  } else if (borderTopStyle === 'dotted') {\n    ctx.dash(borderTopWidth, { space: borderTopWidth * 1.2 });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nconst clipBorderRight = (ctx, layout, style, rtr, rbr) => {\n  const { top, left, width, height } = layout;\n  const { borderTopWidth, borderRightWidth, borderBottomWidth } = style;\n\n  // Clip outer right border edge\n  ctx.moveTo(left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr);\n\n  // Ellipse coefficients outer bottom right cap\n  const c0 = rbr * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(\n    left + width,\n    top + height - c0,\n    left + width - c0,\n    top + height,\n    left + width - rbr,\n    top + height,\n  );\n\n  // Move left in case the margin exceedes the radius\n  const topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);\n  ctx.lineTo(topBottomXCoord, top + height);\n\n  // Clip inner bottom right cap\n  ctx.lineTo(topBottomXCoord, top + height - borderBottomWidth);\n\n  // Ellipse coefficients inner bottom right cap\n  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  const c1 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  const c2 = innerBottomRightRadiusY * (1.0 - KAPPA);\n\n  // Clip inner top right cap\n  ctx.bezierCurveTo(\n    left + width - borderRightWidth - c1,\n    top + height - borderBottomWidth,\n    left + width - borderRightWidth,\n    top + height - borderBottomWidth - c2,\n    left + width - borderRightWidth,\n    top + height - Math.max(rbr, borderBottomWidth),\n  );\n\n  // Clip inner right border edge\n  ctx.lineTo(\n    left + width - borderRightWidth,\n    top + Math.max(rtr, borderTopWidth),\n  );\n\n  // Ellipse coefficients inner top right cap\n  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  const c3 = innerTopRightRadiusX * (1.0 - KAPPA);\n  const c4 = innerTopRightRadiusY * (1.0 - KAPPA);\n  const topRightXCoord = left + width - Math.max(rtr, borderRightWidth);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(\n    left + width - borderRightWidth,\n    top + borderTopWidth + c4,\n    left + width - borderRightWidth - c3,\n    top + borderTopWidth,\n    topRightXCoord,\n    top + borderTopWidth,\n  );\n  ctx.lineTo(topRightXCoord, top);\n\n  // Move right in case the margin exceedes the radius\n  ctx.lineTo(left + width - rtr, top);\n\n  // Ellipse coefficients outer top right cap\n  const c5 = rtr * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(\n    left + width - c5,\n    top,\n    left + width,\n    top + c5,\n    left + width,\n    top + rtr,\n  );\n\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border right cap joins\n  if (borderTopWidth) {\n    const trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderBottomWidth) {\n    const brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nconst fillBorderRight = (ctx, layout, style, rtr, rbr) => {\n  const { top, left, width, height } = layout;\n  const {\n    borderRightColor,\n    borderRightStyle,\n    borderRightWidth,\n    borderTopWidth,\n    borderBottomWidth,\n  } = style;\n\n  const c0 = rbr * (1.0 - KAPPA);\n  const c1 = rtr * (1.0 - KAPPA);\n\n  ctx.moveTo(left + width - rtr, top);\n  ctx.bezierCurveTo(\n    left + width - c1,\n    top,\n    left + width,\n    top + c1,\n    left + width,\n    top + rtr,\n  );\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(\n    left + width,\n    top + height - c0,\n    left + width - c0,\n    top + height,\n    left + width - rbr,\n    top + height,\n  );\n\n  ctx.strokeColor(borderRightColor);\n  ctx.lineWidth(\n    Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2,\n  );\n\n  if (borderRightStyle === 'dashed') {\n    ctx.dash(borderRightWidth * 2, { space: borderRightWidth * 1.2 });\n  } else if (borderRightStyle === 'dotted') {\n    ctx.dash(borderRightWidth, { space: borderRightWidth * 1.2 });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nconst clipBorderBottom = (ctx, layout, style, rbl, rbr) => {\n  const { top, left, width, height } = layout;\n  const { borderBottomWidth, borderRightWidth, borderLeftWidth } = style;\n\n  // Clip outer top border edge\n  ctx.moveTo(left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height);\n\n  // Ellipse coefficients outer top right cap\n  const c0 = rbl * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(\n    left + c0,\n    top + height,\n    left,\n    top + height - c0,\n    left,\n    top + height - rbl,\n  );\n\n  // Move up in case the margin exceedes the radius\n  const bottomLeftYCoord = top + height - Math.max(borderBottomWidth, rbl);\n  ctx.lineTo(left, bottomLeftYCoord);\n\n  // Clip inner bottom left cap\n  ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord);\n\n  // Ellipse coefficients inner top right cap\n  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  const c1 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  const c2 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n\n  // Clip inner bottom left cap\n  ctx.bezierCurveTo(\n    left + borderLeftWidth,\n    top + height - borderBottomWidth - c2,\n    left + borderLeftWidth + c1,\n    top + height - borderBottomWidth,\n    left + borderLeftWidth + innerBottomLeftRadiusX,\n    top + height - borderBottomWidth,\n  );\n\n  // Clip inner bottom border edge\n  ctx.lineTo(\n    left + width - Math.max(rbr, borderRightWidth),\n    top + height - borderBottomWidth,\n  );\n\n  // Ellipse coefficients inner top left cap\n  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  const c3 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  const c4 = innerBottomRightRadiusY * (1.0 - KAPPA);\n  const bottomRightYCoord = top + height - Math.max(borderBottomWidth, rbr);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(\n    left + width - borderRightWidth - c3,\n    top + height - borderBottomWidth,\n    left + width - borderRightWidth,\n    top + height - borderBottomWidth - c4,\n    left + width - borderRightWidth,\n    bottomRightYCoord,\n  );\n  ctx.lineTo(left + width, bottomRightYCoord);\n\n  // Move down in case the margin exceedes the radius\n  ctx.lineTo(left + width, top + height - rbr);\n\n  // Ellipse coefficients outer top left cap\n  const c5 = rbr * (1.0 - KAPPA);\n\n  // Clip outer top left cap\n  ctx.bezierCurveTo(\n    left + width,\n    top + height - c5,\n    left + width - c5,\n    top + height,\n    left + width - rbr,\n    top + height,\n  );\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border bottom cap joins\n  if (borderRightWidth) {\n    const brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderLeftWidth) {\n    const trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nconst fillBorderBottom = (ctx, layout, style, rbl, rbr) => {\n  const { top, left, width, height } = layout;\n  const {\n    borderBottomColor,\n    borderBottomStyle,\n    borderBottomWidth,\n    borderRightWidth,\n    borderLeftWidth,\n  } = style;\n\n  const c0 = rbl * (1.0 - KAPPA);\n  const c1 = rbr * (1.0 - KAPPA);\n\n  ctx.moveTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(\n    left + width,\n    top + height - c1,\n    left + width - c1,\n    top + height,\n    left + width - rbr,\n    top + height,\n  );\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(\n    left + c0,\n    top + height,\n    left,\n    top + height - c0,\n    left,\n    top + height - rbl,\n  );\n\n  ctx.strokeColor(borderBottomColor);\n  ctx.lineWidth(\n    Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2,\n  );\n\n  if (borderBottomStyle === 'dashed') {\n    ctx.dash(borderBottomWidth * 2, { space: borderBottomWidth * 1.2 });\n  } else if (borderBottomStyle === 'dotted') {\n    ctx.dash(borderBottomWidth, { space: borderBottomWidth * 1.2 });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nconst clipBorderLeft = (ctx, layout, style, rbl, rtl) => {\n  const { top, left, width, height } = layout;\n  const { borderTopWidth, borderLeftWidth, borderBottomWidth } = style;\n\n  // Clip outer left border edge\n  ctx.moveTo(left, top + height - rbl);\n  ctx.lineTo(left, top + rtl);\n\n  // Ellipse coefficients outer top left cap\n  const c0 = rtl * (1.0 - KAPPA);\n\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n\n  // Move right in case the margin exceedes the radius\n  const topLeftCoordX = left + Math.max(borderLeftWidth, rtl);\n  ctx.lineTo(topLeftCoordX, top);\n\n  // Clip inner top left cap\n  ctx.lineTo(topLeftCoordX, top + borderTopWidth);\n\n  // Ellipse coefficients inner top left cap\n  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  const c1 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  const c2 = innerTopLeftRadiusY * (1.0 - KAPPA);\n\n  // Clip inner top right cap\n  ctx.bezierCurveTo(\n    left + borderLeftWidth + c1,\n    top + borderTopWidth,\n    left + borderLeftWidth,\n    top + borderTopWidth + c2,\n    left + borderLeftWidth,\n    top + Math.max(rtl, borderTopWidth),\n  );\n\n  // Clip inner left border edge\n  ctx.lineTo(\n    left + borderLeftWidth,\n    top + height - Math.max(rbl, borderBottomWidth),\n  );\n\n  // Ellipse coefficients inner bottom left cap\n  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  const c3 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  const c4 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n  const bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(\n    left + borderLeftWidth,\n    top + height - borderBottomWidth - c4,\n    left + borderLeftWidth + c3,\n    top + height - borderBottomWidth,\n    bottomLeftXCoord,\n    top + height - borderBottomWidth,\n  );\n  ctx.lineTo(bottomLeftXCoord, top + height);\n\n  // Move left in case the margin exceedes the radius\n  ctx.lineTo(left + rbl, top + height);\n\n  // Ellipse coefficients outer top right cap\n  const c5 = rbl * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(\n    left + c5,\n    top + height,\n    left,\n    top + height - c5,\n    left,\n    top + height - rbl,\n  );\n\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border right cap joins\n  if (borderBottomWidth) {\n    const trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderBottomWidth) {\n    const trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nconst fillBorderLeft = (ctx, layout, style, rbl, rtl) => {\n  const { top, left, height } = layout;\n  const {\n    borderLeftColor,\n    borderLeftStyle,\n    borderLeftWidth,\n    borderTopWidth,\n    borderBottomWidth,\n  } = style;\n\n  const c0 = rbl * (1.0 - KAPPA);\n  const c1 = rtl * (1.0 - KAPPA);\n\n  ctx.moveTo(left + rbl, top + height);\n  ctx.bezierCurveTo(\n    left + c0,\n    top + height,\n    left,\n    top + height - c0,\n    left,\n    top + height - rbl,\n  );\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);\n\n  ctx.strokeColor(borderLeftColor);\n  ctx.lineWidth(\n    Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2,\n  );\n\n  if (borderLeftStyle === 'dashed') {\n    ctx.dash(borderLeftWidth * 2, { space: borderLeftWidth * 1.2 });\n  } else if (borderLeftStyle === 'dotted') {\n    ctx.dash(borderLeftWidth, { space: borderLeftWidth * 1.2 });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nconst shouldRenderBorders = node =>\n  node.box &&\n  (node.box.borderTopWidth ||\n    node.box.borderRightWidth ||\n    node.box.borderBottomWidth ||\n    node.box.borderLeftWidth);\n\nconst renderBorders = (ctx, node) => {\n  if (!shouldRenderBorders(node)) return node;\n\n  const {\n    width,\n    height,\n    borderTopWidth,\n    borderLeftWidth,\n    borderRightWidth,\n    borderBottomWidth,\n  } = node.box;\n\n  const {\n    opacity,\n    borderTopLeftRadius = 0,\n    borderTopRightRadius = 0,\n    borderBottomLeftRadius = 0,\n    borderBottomRightRadius = 0,\n    borderTopColor = 'black',\n    borderTopStyle = 'solid',\n    borderLeftColor = 'black',\n    borderLeftStyle = 'solid',\n    borderRightColor = 'black',\n    borderRightStyle = 'solid',\n    borderBottomColor = 'black',\n    borderBottomStyle = 'solid',\n  } = node.style;\n\n  const style = {\n    borderTopColor,\n    borderTopWidth,\n    borderTopStyle,\n    borderLeftColor,\n    borderLeftWidth,\n    borderLeftStyle,\n    borderRightColor,\n    borderRightWidth,\n    borderRightStyle,\n    borderBottomColor,\n    borderBottomWidth,\n    borderBottomStyle,\n    borderTopLeftRadius,\n    borderTopRightRadius,\n    borderBottomLeftRadius,\n    borderBottomRightRadius,\n  };\n\n  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n\n  ctx.save();\n  ctx.strokeOpacity(opacity);\n\n  if (borderTopWidth) {\n    ctx.save();\n    clipBorderTop(ctx, node.box, style, rtr, rtl);\n    fillBorderTop(ctx, node.box, style, rtr, rtl);\n    ctx.restore();\n  }\n\n  if (borderRightWidth) {\n    ctx.save();\n    clipBorderRight(ctx, node.box, style, rtr, rbr);\n    fillBorderRight(ctx, node.box, style, rtr, rbr);\n    ctx.restore();\n  }\n\n  if (borderBottomWidth) {\n    ctx.save();\n    clipBorderBottom(ctx, node.box, style, rbl, rbr);\n    fillBorderBottom(ctx, node.box, style, rbl, rbr);\n    ctx.restore();\n  }\n\n  if (borderLeftWidth) {\n    ctx.save();\n    clipBorderLeft(ctx, node.box, style, rbl, rtl);\n    fillBorderLeft(ctx, node.box, style, rbl, rtl);\n    ctx.restore();\n  }\n\n  ctx.restore();\n\n  return node;\n};\n\nexport default R.curryN(2, renderBorders);\n","import * as R from 'ramda';\n\nconst setDestination = ctx =>\n  R.tap(node => {\n    if (node.props.id) {\n      ctx.addNamedDestination(node.props.id, 'XYZ', null, node.box.top, null);\n    }\n  });\n\nexport default setDestination;\n","import * as R from 'ramda';\n\nimport save from './save';\nimport restore from './restore';\nimport clipNode from './clipNode';\n\nconst drawBackground = ctx => node => {\n  if (node.box && node.style.backgroundColor) {\n    const { top, left, width, height } = node.box;\n\n    ctx\n      .fillOpacity(node.style.opacity || 1)\n      .fillColor(node.style.backgroundColor)\n      .rect(left, top, width, height)\n      .fill();\n  }\n\n  return node;\n};\n\nconst shouldRenderBackground = R.hasPath(['style', 'backgroundColor']);\n\nconst renderBackground = (ctx, node) => {\n  R.when(\n    shouldRenderBackground,\n    R.compose(\n      restore(ctx),\n      drawBackground(ctx),\n      clipNode(ctx),\n      save(ctx),\n    ),\n  )(node);\n\n  return node;\n};\n\nexport default R.curryN(2, renderBackground);\n","import * as R from 'ramda';\n\nimport Font from '../font';\nimport save from './save';\nimport setLink from './setLink';\nimport restore from './restore';\nimport isSvg from '../node/isSvg';\nimport isText from '../node/isText';\nimport isPage from '../node/isPage';\nimport isLink from '../node/isLink';\nimport isNote from '../node/isNote';\nimport isImage from '../node/isImage';\nimport isCanvas from '../node/isCanvas';\nimport renderSvg from './renderSvg';\nimport renderText from './renderText';\nimport renderPage from './renderPage';\nimport renderNote from './renderNote';\nimport renderImage from './renderImage';\nimport renderCanvas from './renderCanvas';\nimport renderRulers from './renderRulers';\nimport addMetadata from './addMetadata';\nimport renderDebug from './renderDebug';\nimport renderBorders from './renderBorders';\nimport setDestination from './setDestination';\nimport renderBackground from './renderBackground';\nimport applyTransformations from './applyTransformations';\n\nconst shouldRenderChildren = v => !isText(v) && !isSvg(v);\n\nconst renderChildren = ctx => node => {\n  save(ctx, node);\n\n  ctx.translate(node.box.left, node.box.top);\n\n  R.compose(\n    R.forEach(renderNode(ctx)),\n    R.pathOr([], ['children']),\n  )(node);\n\n  restore(ctx, node);\n\n  return node;\n};\n\nconst renderNode = ctx => node =>\n  R.compose(\n    restore(ctx),\n    renderDebug(ctx),\n    setDestination(ctx),\n    R.when(shouldRenderChildren, renderChildren(ctx)),\n    R.when(R.either(isText, isLink), setLink(ctx)),\n    R.cond([\n      [isText, renderText(ctx)],\n      [isNote, renderNote(ctx)],\n      [isImage, renderImage(ctx)],\n      [isCanvas, renderCanvas(ctx)],\n      [isSvg, renderSvg(ctx)],\n      [R.T, R.identity],\n    ]),\n    renderBorders(ctx),\n    renderBackground(ctx),\n    applyTransformations(ctx),\n    save(ctx),\n    R.when(isPage, renderPage(ctx)),\n  )(node);\n\nconst renderDocument = ctx =>\n  R.compose(\n    R.forEach(\n      R.compose(\n        renderRulers(ctx),\n        renderNode(ctx),\n      ),\n    ),\n    R.pathOr([], ['children']),\n  );\n\nconst render = (ctx, doc) => {\n  addMetadata(ctx)(doc);\n  renderDocument(ctx)(doc);\n\n  ctx.end();\n  Font.reset(); // TODO: move outside\n\n  return ctx;\n};\n\nexport default render;\n","/**\n * Capitalize first letter of each word\n *\n * @param {String} string\n * @returns {String} capitalized string\n */\nconst capitalize = value => {\n  if (!value) return value;\n  return value.replace(/(^|\\s)\\S/g, l => l.toUpperCase());\n};\n\nexport default capitalize;\n","import * as R from 'ramda';\n\n/**\n * Capitalize first letter of string\n *\n * @param {String} string\n * @returns {String} capitalized string\n */\nconst upperFirst = R.ifElse(\n  R.isNil,\n  R.identity,\n  R.compose(\n    R.join(''),\n    R.juxt([\n      R.compose(\n        R.toUpper,\n        R.head,\n      ),\n      R.tail,\n    ]),\n  ),\n);\n\nexport default R.memoizeWith(R.identity, upperFirst);\n","import capitalize from '../utils/capitalize';\nimport upperFirst from '../utils/upperFirst';\n\n/**\n * Apply transformation to text string\n *\n * @param {String} text\n * @param {String} transformation type\n * @returns {String} transformed text\n */\nconst transformText = (text, transformation) => {\n  switch (transformation) {\n    case 'uppercase':\n      return text.toUpperCase();\n    case 'lowercase':\n      return text.toLowerCase();\n    case 'capitalize':\n      return capitalize(text);\n    case 'upperfirst':\n      return upperFirst(text);\n    default:\n      return text;\n  }\n};\n\nexport default transformText;\n","import { PDFFont } from '@react-pdf/pdfkit';\n\nclass StandardFont {\n  constructor(src) {\n    this.name = src;\n    this.src = PDFFont.open(null, src);\n  }\n\n  layout(str) {\n    const [encoded, positions] = this.src.encode(str);\n\n    return {\n      positions,\n      stringIndices: positions.map((_, i) => i),\n      glyphs: encoded.map((g, i) => {\n        const glyph = this.getGlyph(parseInt(g, 16));\n        glyph.advanceWidth = positions[i].advanceWidth;\n        return glyph;\n      }),\n    };\n  }\n\n  glyphForCodePoint(codePoint) {\n    const glyph = this.getGlyph(codePoint);\n    glyph.advanceWidth = 400;\n    return glyph;\n  }\n\n  getGlyph(id) {\n    return {\n      id,\n      _font: this.src,\n      codePoints: [id],\n      isLigature: false,\n      name: this.src.font.characterToGlyph(id),\n    };\n  }\n\n  hasGlyphForCodePoint(codePoint) {\n    return this.src.font.characterToGlyph(codePoint) !== '.notdef';\n  }\n\n  // Based on empirical observation\n  get ascent() {\n    return 900;\n  }\n\n  // Based on empirical observation\n  get descent() {\n    switch (this.name) {\n      case 'Times-Roman':\n      case 'Times-Bold':\n      case 'Times-Italic':\n        return -220;\n      case 'Courier':\n      case 'Courier-Bold':\n      case 'Courier-Oblique':\n        return -230;\n      default:\n        return -200;\n    }\n  }\n\n  get lineGap() {\n    return 0;\n  }\n\n  get unitsPerEm() {\n    return 1000;\n  }\n}\n\nexport default StandardFont;\n","import * as R from 'ramda';\n\nimport StandardFont from './standardFont';\n\nconst fontCache = {};\n\nconst IGNORED_CODE_POINTS = [173];\n\nconst getFontSize = R.pathOr(12, ['attributes', 'fontSize']);\n\nconst getOrCreateFont = name => {\n  if (fontCache[name]) return fontCache[name];\n\n  const font = new StandardFont(name);\n  fontCache[name] = font;\n\n  return font;\n};\n\nconst getFallbackFont = () => getOrCreateFont('Helvetica');\n\nconst shouldFallbackToFont = (codePoint, font) =>\n  !IGNORED_CODE_POINTS.includes(codePoint) &&\n  !font.hasGlyphForCodePoint(codePoint) &&\n  getFallbackFont().hasGlyphForCodePoint(codePoint);\n\nconst fontSubstitution = () => ({ string, runs }) => {\n  let lastFont = null;\n  let lastIndex = 0;\n  let index = 0;\n\n  const res = [];\n\n  for (const run of runs) {\n    const fontSize = getFontSize(run);\n    const defaultFont =\n      typeof run.attributes.font === 'string'\n        ? getOrCreateFont(run.attributes.font)\n        : run.attributes.font;\n\n    if (string.length === 0) {\n      res.push({ start: 0, end: 0, attributes: { font: defaultFont } });\n      break;\n    }\n\n    for (const char of string.slice(run.start, run.end)) {\n      const codePoint = char.codePointAt();\n      const shouldFallback = shouldFallbackToFont(codePoint, defaultFont);\n      const font = shouldFallback ? getFallbackFont() : defaultFont;\n\n      // If the default font does not have a glyph and the fallback font does, we use it\n      if (font !== lastFont) {\n        if (lastFont) {\n          res.push({\n            start: lastIndex,\n            end: index,\n            attributes: {\n              font: lastFont,\n              scale: lastFont ? fontSize / lastFont.unitsPerEm : 0,\n            },\n          });\n        }\n\n        lastFont = font;\n        lastIndex = index;\n      }\n\n      index += char.length;\n    }\n  }\n\n  if (lastIndex < string.length) {\n    const fontSize = getFontSize(R.last(runs));\n\n    res.push({\n      start: lastIndex,\n      end: string.length,\n      attributes: {\n        font: lastFont,\n        scale: lastFont ? fontSize / lastFont.unitsPerEm : 0,\n      },\n    });\n  }\n\n  return { string, runs: res };\n};\n\nexport default fontSubstitution;\n","import * as R from 'ramda';\nimport layoutEngine from '@react-pdf/textkit/layout';\nimport linebreaker from '@react-pdf/textkit/engines/linebreaker';\nimport justification from '@react-pdf/textkit/engines/justification';\nimport textDecoration from '@react-pdf/textkit/engines/textDecoration';\nimport scriptItemizer from '@react-pdf/textkit/engines/scriptItemizer';\nimport wordHyphenation from '@react-pdf/textkit/engines/wordHyphenation';\nimport AttributedString from '@react-pdf/textkit/attributedString';\n\nimport Font from '../font';\nimport transformText from '../text/transformText';\nimport isTextInstance from '../node/isTextInstance';\nimport fontSubstitution from '../text/fontSubstitution';\n\nconst engines = {\n  linebreaker,\n  justification,\n  textDecoration,\n  scriptItemizer,\n  wordHyphenation,\n  fontSubstitution,\n};\n\nconst engine = layoutEngine(engines);\n\nconst layoutOptions = {\n  hyphenationCallback: Font.getHyphenationCallback(),\n  shrinkWhitespaceFactor: { before: -0.5, after: -0.5 },\n};\n\nconst getFragments = instance => {\n  if (!instance) return [{ string: '' }];\n\n  const fragments = [];\n\n  const {\n    fill = 'black',\n    fontFamily = 'Helvetica',\n    fontWeight,\n    fontStyle,\n    fontSize = 18,\n    textDecoration,\n    textDecorationColor,\n    textDecorationStyle,\n    textTransform,\n    opacity,\n  } = instance.props;\n\n  const obj = Font.getFont({ fontFamily, fontWeight, fontStyle });\n  const font = obj ? obj.data : fontFamily;\n\n  const attributes = {\n    font,\n    opacity,\n    fontSize,\n    color: fill,\n    underlineStyle: textDecorationStyle,\n    underline: textDecoration === 'underline',\n    underlineColor: textDecorationColor || fill,\n    strike: textDecoration === 'line-through',\n    strikeStyle: textDecorationStyle,\n    strikeColor: textDecorationColor || fill,\n  };\n\n  instance.children.forEach(child => {\n    if (isTextInstance(child)) {\n      fragments.push({\n        string: transformText(child.value, textTransform),\n        attributes,\n      });\n    } else {\n      if (child) {\n        fragments.push(...getFragments(child));\n      }\n    }\n  });\n\n  return fragments;\n};\n\nconst getAttributedString = instance =>\n  AttributedString.fromFragments(getFragments(instance));\n\nconst AlmostInfinity = 999999999999;\n\nconst layoutTspan = node => {\n  const attributedString = getAttributedString(node);\n\n  const x = R.pathOr(0, ['props', 'x'], node);\n  const y = R.pathOr(0, ['props', 'y'], node);\n\n  const container = { x, y, width: AlmostInfinity, height: AlmostInfinity };\n\n  const lines = R.compose(\n    R.reduce(R.concat, []),\n    engine,\n  )(attributedString, container, layoutOptions);\n\n  return R.assoc('lines', lines, node);\n};\n\nconst layoutText = R.evolve({\n  children: R.map(layoutTspan),\n});\n\nexport default layoutText;\n","import * as R from 'ramda';\n\nimport { DEFS } from '../constants';\n\n/**\n * Checks if node is svg defs\n *\n * @param {Object} node\n * @returns {Boolean} is node svg defs?\n */\nconst isDefs = R.propEq('type', DEFS);\n\nexport default isDefs;\n","import * as R from 'ramda';\n\nimport isDefs from '../node/isDefs';\n\nconst getChildren = R.propOr([], 'children');\n\nconst getId = R.path(['props', 'id']);\n\nconst getDefs = R.compose(\n  R.map(R.prop(0)),\n  R.groupBy(getId),\n  getChildren,\n  R.defaultTo({}),\n  R.find(isDefs),\n  getChildren,\n);\n\nexport default getDefs;\n","import * as R from 'ramda';\n\nimport getDefs from './getDefs';\nimport isDefs from '../node/isDefs';\n\nconst isNotDefs = R.complement(isDefs);\n\nconst detachDefs = R.evolve({\n  children: R.filter(isNotDefs),\n});\n\nconst URL_REGEX = /url\\(['\"]?#([^'\"]+)['\"]?\\)/;\n\nconst replaceDef = defs =>\n  R.compose(\n    R.when(\n      R.test(URL_REGEX),\n      R.compose(\n        R.prop(R.__, defs),\n        R.prop(1),\n        R.match(URL_REGEX),\n      ),\n    ),\n    R.defaultTo(''),\n  );\n\nconst parseNodeDefs = defs => node =>\n  R.compose(\n    R.evolve({\n      props: R.evolve({\n        fill: replaceDef(defs),\n        clipPath: replaceDef(defs),\n      }),\n    }),\n    R.evolve({ children: R.map(parseNodeDefs(defs)) }),\n  )(node);\n\nconst parseDefs = root => {\n  const defs = getDefs(root);\n  return R.evolve({ children: R.map(parseNodeDefs(defs)) }, root);\n};\n\nconst replaceDefs = R.compose(\n  detachDefs,\n  parseDefs,\n);\n\nexport default replaceDefs;\n","const parseViewbox = value => {\n  if (!value) return null;\n  const values = value.split(/[,\\s]+/).map(parseFloat);\n  if (values.length !== 4) return null;\n  return { minX: values[0], minY: values[1], maxX: values[2], maxY: values[3] };\n};\n\nexport default parseViewbox;\n","import parseViewBox from './parseViewbox';\n\nconst getContainer = node => {\n  const viewbox = parseViewBox(node.props.viewBox);\n\n  if (viewbox) {\n    return { width: viewbox.maxX, height: viewbox.maxY };\n  }\n\n  if (node.props.width && node.props.height) {\n    return {\n      width: parseFloat(node.props.width),\n      height: parseFloat(node.props.height),\n    };\n  }\n\n  return { width: 0, height: 0 };\n};\n\nexport default getContainer;\n","import * as R from 'ramda';\n\nimport { SVG_INHERITED_PROPS } from '../constants';\n\nconst getInheritProps = R.compose(\n  R.pick(SVG_INHERITED_PROPS),\n  R.propOr({}, 'props'),\n);\n\nconst inheritProps = node => {\n  const props = getInheritProps(node);\n\n  return R.evolve({\n    children: R.map(\n      R.compose(\n        inheritProps,\n        R.evolve({\n          props: R.merge(props),\n        }),\n      ),\n    ),\n  })(node);\n};\n\nexport default inheritProps;\n","const parseAspectRatio = value => {\n  const match = value\n    .replace(/[\\s\\r\\t\\n]+/gm, ' ')\n    .replace(/^defer\\s/, '')\n    .split(' ');\n\n  const align = match[0] || 'xMidYMid';\n  const meetOrSlice = match[1] || 'meet';\n\n  return { align, meetOrSlice };\n};\n\nexport default parseAspectRatio;\n","import * as R from 'ramda';\nimport colorString from 'color-string';\nimport hlsToHex from 'hsl-to-hex';\n\nconst isRgb = R.test(/rgb/g);\nconst isRgba = R.test(/rgba/g);\nconst isHsl = R.test(/hsl/g);\nconst isHsla = R.test(/hsla/g);\n\n/**\n * Transform rgb color to hexa\n *\n * @param {String} styles value\n * @returns {Object} transformed value\n */\nconst parseRgb = R.compose(\n  colorString.to.hex,\n  colorString.get.rgb,\n);\n\n/**\n * Transform Hsl color to hexa\n *\n * @param {String} styles value\n * @returns {Object} transformed value\n */\nconst parseHsl = R.compose(\n  R.toUpper,\n  R.apply(hlsToHex),\n  R.map(Math.round),\n  colorString.get.hsl,\n);\n\n/**\n * Transform given color to hexa\n *\n * @param {String} styles value\n * @returns {Object} transformed value\n */\nexport const transformColor = value =>\n  R.cond([\n    [isRgba, parseRgb],\n    [isRgb, parseRgb],\n    [isHsla, parseHsl],\n    [isHsl, parseHsl],\n    [R.T, R.always(value)],\n  ])(value);\n\n/**\n * Transform rbg and cmyk colors to hexa\n *\n * @param {Object} styles object\n * @returns {Object} transformed styles\n */\nconst transformColors = styles => R.map(transformColor, styles);\n\nexport default transformColors;\n","import * as R from 'ramda';\n\nimport isSvg from '../node/isSvg';\nimport isText from '../node/isText';\n\nimport layoutText from '../svg/layoutText';\nimport replaceDefs from '../svg/replaceDefs';\nimport getContainer from '../svg/getContainer';\nimport parseViewbox from '../svg/parseViewbox';\nimport inheritProps from '../svg/inheritProps';\nimport matchPercent from '../utils/matchPercent';\nimport isTextInstance from '../node/isTextInstance';\nimport parseAspectRatio from '../svg/parseAspectRatio';\nimport { transformColor } from '../stylesheet/transformColors';\n\nconst STYLE_PROPS = [\n  'width',\n  'height',\n  'color',\n  'stroke',\n  'strokeWidth',\n  'opacity',\n  'fillOpacity',\n  'strokeOpacity',\n  'fill',\n  'fillRule',\n  'clipPath',\n  'offset',\n  'transform',\n  'strokeLinejoin',\n  'strokeLinecap',\n  'strokeDasharray',\n];\n\nconst VERTICAL_PROPS = ['y', 'y1', 'y2', 'height', 'cy', 'ry'];\nconst HORIZONTAL_PROPS = ['x', 'x1', 'x2', 'width', 'cx', 'rx'];\n\nconst transformPercent = container =>\n  R.mapObjIndexed((value, key) => {\n    const match = matchPercent(value);\n\n    if (match && VERTICAL_PROPS.includes(key)) {\n      return match.percent * container.height;\n    }\n\n    if (match && HORIZONTAL_PROPS.includes(key)) {\n      return match.percent * container.width;\n    }\n\n    return value;\n  });\n\nconst parsePercent = value => {\n  const match = matchPercent(value);\n  return match ? match.percent : parseFloat(value);\n};\n\nconst parseProps = container =>\n  R.compose(\n    R.evolve({\n      props: R.o(\n        R.evolve({\n          x: parseFloat,\n          x1: parseFloat,\n          x2: parseFloat,\n          y: parseFloat,\n          y1: parseFloat,\n          y2: parseFloat,\n          r: parseFloat,\n          rx: parseFloat,\n          ry: parseFloat,\n          cx: parseFloat,\n          cy: parseFloat,\n          width: parseFloat,\n          height: parseFloat,\n          offset: parsePercent,\n          fill: transformColor,\n          opacity: parsePercent,\n          stroke: transformColor,\n          stopOpacity: parsePercent,\n          stopColor: transformColor,\n        }),\n        transformPercent(container),\n      ),\n    }),\n  );\n\nconst mergeStyles = node => {\n  const style = R.propOr({}, 'style', node);\n  return R.evolve({ props: R.merge(style) }, node);\n};\n\nconst removeNoneValues = R.evolve({\n  props: R.map(R.when(R.equals('none'), R.always(null))),\n});\n\nconst pickStyleProps = node => {\n  const styleProps = R.o(R.pick(STYLE_PROPS), R.propOr({}, 'props'))(node);\n  return R.evolve({ style: R.merge(styleProps) }, node);\n};\n\nconst parseSvgProps = R.evolve({\n  props: R.evolve({\n    width: parseFloat,\n    height: parseFloat,\n    viewBox: parseViewbox,\n    preserveAspectRatio: parseAspectRatio,\n  }),\n});\n\nconst wrapBetweenTspan = node => ({\n  type: 'TSPAN',\n  props: {},\n  children: [node],\n});\n\nconst addMissingTspan = R.when(\n  isText,\n  R.evolve({\n    children: R.map(R.when(isTextInstance, wrapBetweenTspan)),\n  }),\n);\n\nconst resolveSvgNode = container =>\n  R.compose(\n    parseProps(container),\n    addMissingTspan,\n    removeNoneValues,\n    mergeStyles,\n  );\n\nconst resolveChildren = container => node =>\n  R.evolve({\n    children: R.map(\n      R.compose(\n        resolveChildren(container),\n        resolveSvgNode(container),\n      ),\n    ),\n  })(node);\n\nconst parseText = node =>\n  R.ifElse(\n    isText,\n    layoutText,\n    R.evolve({\n      children: R.map(parseText),\n    }),\n  )(node);\n\nconst resolveSvgRoot = node => {\n  const container = getContainer(node);\n\n  return R.compose(\n    replaceDefs,\n    parseText,\n    parseSvgProps,\n    pickStyleProps,\n    inheritProps,\n    resolveChildren(container),\n  )(node);\n};\n\nconst resolveSvg = node =>\n  R.compose(\n    R.evolve({ children: R.map(resolveSvg) }),\n    R.when(isSvg, resolveSvgRoot),\n  )(node);\n\nexport default resolveSvg;\n","import * as R from 'ramda';\nimport { SVG, DOCUMENT } from '../constants';\n\nconst getZIndex = R.path(['style', 'zIndex']);\n\nconst isType = R.propEq('type');\n\nconst shouldNotSort = R.anyPass([isType(DOCUMENT), isType(SVG)]);\n\nconst sortZIndex = (a, b) => {\n  const za = getZIndex(a);\n  const zb = getZIndex(b);\n\n  if (!za && !zb) return 0;\n  if (!za) return 1;\n  if (!zb) return -1;\n\n  return zb - za;\n};\n\n/**\n * Sort children by zIndex value\n *\n * @param {Object} node\n * @returns {Object} node\n */\nconst resolveZIndex = node =>\n  R.compose(\n    R.evolve({ children: R.map(resolveZIndex) }),\n    R.unless(shouldNotSort, R.evolve({ children: R.sort(sortZIndex) })),\n  )(node);\n\nexport default resolveZIndex;\n","import * as R from 'ramda';\n\nimport { RULER_WIDTH } from '../constants';\nimport hasVerticalRuler from '../node/hasVerticalRuler';\nimport hasHorizontalRuler from '../node/hasHorizontalRuler';\n\n/**\n * Adjust page size given ruler props\n *\n * @param {Object} page\n * @returns {boolean} page with size altered by ruler props\n */\nconst adjustPageSize = R.compose(\n  R.when(\n    hasVerticalRuler,\n    R.evolve({\n      box: { height: R.add(RULER_WIDTH) },\n      children: R.map(\n        R.evolve({\n          box: { top: R.add(RULER_WIDTH) },\n        }),\n      ),\n    }),\n  ),\n  R.when(\n    hasHorizontalRuler,\n    R.evolve({\n      box: { width: R.add(RULER_WIDTH) },\n      children: R.map(\n        R.evolve({\n          box: { left: R.add(RULER_WIDTH) },\n        }),\n      ),\n    }),\n  ),\n);\n\n/**\n * Adjust pages size given ruler props\n *\n * @param {Object} root\n * @returns {boolean} root with pages size altered by ruler props\n */\nconst resolveRulers = R.evolve({\n  children: R.map(adjustPageSize),\n});\n\nexport default resolveRulers;\n","import PNG from '@react-pdf/png-js';\n\nPNG.isValid = function(data) {\n  try {\n    return !!new PNG(data);\n  } catch (e) {\n    return false;\n  }\n};\n\nexport default PNG;\n","// Extracted from https://github.com/devongovett/pdfkit/blob/master/lib/image/jpeg.coffee\n\nconst MARKERS = [\n  0xffc0,\n  0xffc1,\n  0xffc2,\n  0xffc3,\n  0xffc5,\n  0xffc6,\n  0xffc7,\n  0xffc8,\n  0xffc9,\n  0xffca,\n  0xffcb,\n  0xffcc,\n  0xffcd,\n  0xffce,\n  0xffcf,\n];\n\nclass JPEG {\n  data = null;\n  width = null;\n  height = null;\n\n  constructor(data) {\n    this.data = data;\n\n    if (data.readUInt16BE(0) !== 0xffd8) {\n      throw new Error('SOI not found in JPEG');\n    }\n\n    let marker;\n    let pos = 2;\n\n    while (pos < data.length) {\n      marker = data.readUInt16BE(pos);\n      pos += 2;\n      if (MARKERS.includes(marker)) {\n        break;\n      }\n      pos += data.readUInt16BE(pos);\n    }\n\n    if (!MARKERS.includes(marker)) {\n      throw new Error('Invalid JPEG.');\n    }\n\n    pos += 3;\n    this.height = data.readUInt16BE(pos);\n\n    pos += 2;\n    this.width = data.readUInt16BE(pos);\n  }\n}\n\nJPEG.isValid = function(data) {\n  if (!data || !Buffer.isBuffer(data) || data.readUInt16BE(0) !== 0xffd8) {\n    return false;\n  }\n\n  let marker;\n  let pos = 2;\n\n  while (pos < data.length) {\n    marker = data.readUInt16BE(pos);\n    pos += 2;\n    if (MARKERS.includes(marker)) {\n      break;\n    }\n    pos += data.readUInt16BE(pos);\n  }\n\n  if (!MARKERS.includes(marker)) {\n    return false;\n  }\n\n  return true;\n};\n\nexport default JPEG;\n","const createCache = ({ limit = 100 } = {}) => {\n  let cache = {};\n  let keys = [];\n\n  return {\n    get: key => cache[key],\n    set: (key, value) => {\n      keys.push(key);\n      if (keys.length > limit) {\n        delete cache[keys.shift()];\n      }\n      cache[key] = value;\n    },\n    reset: () => {\n      cache = {};\n      keys = [];\n    },\n    length: () => keys.length,\n  };\n};\n\nexport default createCache;\n","import fs from 'fs';\nimport url from 'url';\nimport path from 'path';\nimport fetch from 'cross-fetch';\n\nimport PNG from '../utils/png';\nimport JPEG from '../utils/jpeg';\nimport createCache from '../utils/cache';\n\nexport const IMAGE_CACHE = createCache({ limit: 30 });\n\nexport const getAbsoluteLocalPath = src => {\n  if (BROWSER) {\n    throw new Error('Cannot check local paths in client-side environment');\n  }\n\n  const { protocol, auth, host, port, hostname, path: pathname } = url.parse(\n    src,\n  );\n  const absolutePath = path.resolve(pathname);\n  if ((protocol && protocol !== 'file:') || auth || host || port || hostname) {\n    return undefined;\n  }\n  return absolutePath;\n};\n\nconst fetchLocalFile = src =>\n  new Promise((resolve, reject) => {\n    try {\n      if (BROWSER) {\n        return reject(new Error('Cannot fetch local file in this environemnt'));\n      }\n      const absolutePath = getAbsoluteLocalPath(src);\n      if (!absolutePath) {\n        return reject(new Error(`Cannot fetch non-local path: ${src}`));\n      }\n      fs.readFile(absolutePath, (err, data) =>\n        err ? reject(err) : resolve(data),\n      );\n    } catch (err) {\n      reject(err);\n    }\n  });\n\nconst fetchRemoteFile = async (uri, options) => {\n  const response = await fetch(uri, options);\n\n  const buffer = await (response.buffer\n    ? response.buffer()\n    : response.arrayBuffer());\n\n  return buffer.constructor.name === 'Buffer' ? buffer : Buffer.from(buffer);\n};\n\nconst isValidFormat = format => {\n  const lower = format.toLowerCase();\n  return lower === 'jpg' || lower === 'jpeg' || lower === 'png';\n};\n\nconst guessFormat = buffer => {\n  let format;\n\n  if (JPEG.isValid(buffer)) {\n    format = 'jpg';\n  } else if (PNG.isValid(buffer)) {\n    format = 'png';\n  }\n\n  return format;\n};\n\nconst isCompatibleBase64 = ({ uri }) =>\n  /^data:image\\/[a-zA-Z]*;base64,[^\"]*/g.test(uri);\n\nfunction getImage(body, extension) {\n  switch (extension.toLowerCase()) {\n    case 'jpg':\n    case 'jpeg':\n      return new JPEG(body);\n    case 'png':\n      return new PNG(body);\n    default:\n      return null;\n  }\n}\n\nconst resolveBase64Image = ({ uri }) => {\n  const match = /^data:image\\/([a-zA-Z]*);base64,([^\"]*)/g.exec(uri);\n  const format = match[1];\n  const data = match[2];\n\n  if (!isValidFormat(format)) {\n    throw new Error(`Base64 image invalid format: ${format}`);\n  }\n\n  return new Promise(resolve => {\n    return resolve(getImage(Buffer.from(data, 'base64'), format));\n  });\n};\n\nconst resolveImageFromData = src => {\n  if (src.data && src.format) {\n    return new Promise(resolve => resolve(getImage(src.data, src.format)));\n  }\n\n  throw new Error(`Invalid data given for local file: ${JSON.stringify(src)}`);\n};\n\nconst resolveBufferImage = buffer => {\n  const format = guessFormat(buffer);\n\n  if (format) {\n    return new Promise(resolve => resolve(getImage(buffer, format)));\n  }\n};\n\nconst getImageFormat = body => {\n  const isPng =\n    body[0] === 137 &&\n    body[1] === 80 &&\n    body[2] === 78 &&\n    body[3] === 71 &&\n    body[4] === 13 &&\n    body[5] === 10 &&\n    body[6] === 26 &&\n    body[7] === 10;\n\n  const isJpg = body[0] === 255 && body[1] === 216 && body[2] === 255;\n\n  let extension = '';\n  if (isPng) {\n    extension = 'png';\n  } else if (isJpg) {\n    extension = 'jpg';\n  } else {\n    throw new Error('Not valid image extension');\n  }\n\n  return extension;\n};\n\nconst resolveImageFromUrl = async src => {\n  const { uri, body, headers, method = 'GET' } = src;\n\n  const data =\n    !BROWSER && getAbsoluteLocalPath(uri)\n      ? await fetchLocalFile(uri)\n      : await fetchRemoteFile(uri, { body, headers, method });\n\n  const extension = getImageFormat(data);\n\n  return getImage(data, extension);\n};\n\nconst resolveImage = (src, { cache = true } = {}) => {\n  const cacheKey = src.data ? src.data.toString() : src.uri;\n\n  if (cache && IMAGE_CACHE.get(cacheKey)) {\n    return IMAGE_CACHE.get(cacheKey);\n  }\n\n  let image;\n  if (isCompatibleBase64(src)) {\n    image = resolveBase64Image(src);\n  } else if (Buffer.isBuffer(src)) {\n    image = resolveBufferImage(src);\n  } else if (typeof src === 'object' && src.data) {\n    image = resolveImageFromData(src);\n  } else {\n    image = resolveImageFromUrl(src);\n  }\n\n  if (!image) {\n    throw new Error('Cannot resolve image');\n  }\n\n  if (cache) {\n    IMAGE_CACHE.set(cacheKey, image);\n  }\n\n  return image;\n};\n\nexport default resolveImage;\n","import * as R from 'ramda';\n\nconst isNotNil = R.complement(R.isNil);\n\n/**\n * Takes a list of predicates and returns the first predicate result that returns true for a given list of arguments\n *\n * @param  {...any} predicates\n * @param  {any} value\n */\nconst firstPass = (...fns) => value => {\n  let res;\n\n  for (const fn of fns) {\n    res = fn(value);\n    if (isNotNil(res)) return res;\n  }\n\n  return res;\n};\n\nexport default firstPass;\n","import * as R from 'ramda';\n\nimport firstPass from '../utils/firstPass';\n\n/**\n * Get image source\n *\n * @param {Object} image node\n * @returns {String} image src\n */\nconst getSource = R.compose(\n  R.when(R.is(String), src => ({ uri: src })),\n  firstPass(\n    R.path(['props', 'src']),\n    R.path(['props', 'source']),\n    R.path(['props', 'href']),\n  ),\n);\n\nexport default getSource;\n","import resolveImage from './resolveImage';\nimport getSource from './getSource';\nimport warning from '../utils/warning';\n\n/**\n * Resolves async src if passed\n *\n * @param {string | Function} src\n * @returns {object} resolved src\n */\nconst resolveSrc = async src =>\n  typeof src === 'function' ? { uri: await src() } : src;\n\n/**\n * Fetches image and append data to node\n * Ideally this fn should be immutable.\n *\n * @param {Object} node\n */\nconst fetchImage = async node => {\n  const src = getSource(node);\n  const { cache } = node.props;\n\n  if (!src) {\n    warning(false, 'Image should receive either a \"src\" or \"source\" prop');\n    return;\n  }\n\n  try {\n    const source = await resolveSrc(src);\n    node.image = await resolveImage(source, { cache });\n  } catch (e) {\n    node.image = { width: 0, height: 0 };\n    console.warn(e.message);\n  }\n};\n\nexport default fetchImage;\n","/* eslint-disable no-cond-assign */\nimport emojiRegex from 'emoji-regex';\n\nimport Font from '../font';\nimport resolveImage from '../image/resolveImage';\n\n// Caches emoji images data\nconst emojis = {};\nconst regex = emojiRegex();\n\nconst reflect = promise => (...args) => promise(...args).then(v => v, e => e);\n\n// Returns a function to be able to mock resolveImage.\nconst makeFetchEmojiImage = () => reflect(resolveImage);\n\n/**\n * When an emoji as no color, it might still have 2 parts,\n * the canonical emoji and an empty string.\n * ex.\n *   (no color) Array.from('❤️') => [\"❤\", \"️\"]\n *   (w/ color) Array.from('👍🏿') => [\"👍\", \"🏿\"]\n *\n * The empty string needs to be removed otherwise the generated\n * url will be incorect.\n */\nconst _removeNoColor = x => x !== '️';\n\nconst getCodePoints = string =>\n  Array.from(string)\n    .filter(_removeNoColor)\n    .map(char => char.codePointAt(0).toString(16))\n    .join('-');\n\nconst buildEmojiUrl = emoji => {\n  const { url, format } = Font.getEmojiSource();\n  return `${url}${getCodePoints(emoji)}.${format}`;\n};\n\nexport const fetchEmojis = string => {\n  const emojiSource = Font.getEmojiSource();\n\n  if (!emojiSource || !emojiSource.url) return [];\n\n  const promises = [];\n\n  let match;\n  while ((match = regex.exec(string))) {\n    const emoji = match[0];\n\n    if (!emojis[emoji] || emojis[emoji].loading) {\n      const emojiUrl = buildEmojiUrl(emoji);\n\n      emojis[emoji] = { loading: true };\n      const fetchEmojiImage = makeFetchEmojiImage();\n      promises.push(\n        fetchEmojiImage({ uri: emojiUrl }).then(image => {\n          emojis[emoji].loading = false;\n          emojis[emoji].data = image.data;\n        }),\n      );\n    }\n  }\n\n  return promises;\n};\n\nexport const embedEmojis = fragments => {\n  const result = [];\n\n  for (let i = 0; i < fragments.length; i++) {\n    const fragment = fragments[i];\n\n    let match;\n    let lastIndex = 0;\n\n    while ((match = regex.exec(fragment.string))) {\n      const index = match.index;\n      const emoji = match[0];\n      const emojiSize = fragment.attributes.fontSize;\n      const chunk = fragment.string.slice(lastIndex, index + match[0].length);\n\n      // If emoji image was found, we create a new fragment with the\n      // correct attachment and object substitution character;\n      if (emojis[emoji] && emojis[emoji].data) {\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0xfffc)),\n          attributes: {\n            ...fragment.attributes,\n            attachment: {\n              width: emojiSize,\n              height: emojiSize,\n              yOffset: Math.floor(emojiSize * 0.1),\n              image: emojis[emoji].data,\n            },\n          },\n        });\n      } else {\n        // If no emoji data, we just replace the emoji with a nodef char\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0)),\n          attributes: fragment.attributes,\n        });\n      }\n\n      lastIndex = index + emoji.length;\n    }\n\n    if (lastIndex < fragment.string.length) {\n      result.push({\n        string: fragment.string.slice(lastIndex),\n        attributes: fragment.attributes,\n      });\n    }\n  }\n\n  return result;\n};\n","import * as R from 'ramda';\n\nimport Font from '../font';\nimport isImage from '../node/isImage';\nimport fetchImage from '../image/fetchImage';\nimport { fetchEmojis } from '../text/emoji';\n\n/**\n * Get all asset promises that need to be resolved\n *\n * @param {Object} root node\n * @returns {Array} asset promises\n */\nconst fetchAssets = node => {\n  const promises = [];\n  const listToExplore = node.children.slice(0);\n\n  while (listToExplore.length > 0) {\n    const node = listToExplore.shift();\n\n    if (isImage(node)) {\n      promises.push(fetchImage(node));\n    }\n\n    if (node.style && node.style.fontFamily) {\n      promises.push(Font.load(node.style));\n    }\n\n    if (typeof node === 'string') {\n      promises.push(...fetchEmojis(node));\n    }\n\n    if (typeof node.value === 'string') {\n      promises.push(...fetchEmojis(node.value));\n    }\n\n    if (node.children) {\n      node.children.forEach(childNode => {\n        listToExplore.push(childNode);\n      });\n    }\n  }\n\n  return promises;\n};\n\n/**\n * Fetch image, font and emoji assets in parallel.\n * Layout process will not be resumed until promise resolves.\n *\n * @param {Object} root node\n * @returns {Object} root node\n */\nconst resolveAssets = node =>\n  R.compose(\n    R.then(R.always(node)),\n    p => Promise.all(p),\n    fetchAssets,\n  )(node);\n\nexport default resolveAssets;\n","import * as R from 'ramda';\n\n/**\n * Checks if value is not an array\n *\n * @param {any} value\n * @returns {Boolean} isn't value an array\n */\nconst isNotArray = R.complement(R.is(Array));\n\n/**\n * Casts value to array\n *\n * @param {any} value\n * @returns {Array} casted value\n */\nconst castArray = R.when(isNotArray, v => [v]);\n\nexport default castArray;\n","import * as R from 'ramda';\n\nimport castArray from '../utils/castArray';\n\n/**\n * Remove nil values from array\n *\n * @param {Array} array\n * @returns {Array} array without nils\n */\nconst compact = R.filter(Boolean);\n\n/**\n * Checks if value is array\n *\n * @param {any} value\n * @returns {Boolean} is value an array\n */\nconst isArray = R.is(Array);\n\n/**\n * Merges style objects array\n *\n * @param {Array} style objects array\n * @returns {Object} merged style object\n */\nconst mergeStyles = styles =>\n  styles.reduce((acc, style) => {\n    const s = isArray(style) ? flatten(style) : style;\n\n    Object.keys(s).forEach(key => {\n      if (s[key] !== null && s[key] !== undefined) {\n        acc[key] = s[key];\n      }\n    });\n\n    return acc;\n  }, {});\n\n/**\n * Flattens an array of style objects, into one aggregated style object.\n *\n * @param {Array} style objects array\n * @returns {Object} flatted style object\n */\nconst flatten = R.compose(\n  mergeStyles,\n  compact,\n  castArray,\n);\n\nexport default flatten;\n","const hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Expand rules\n */\nconst styleShorthands = {\n  margin: {\n    marginTop: true,\n    marginRight: true,\n    marginBottom: true,\n    marginLeft: true,\n  },\n  marginHorizontal: {\n    marginLeft: true,\n    marginRight: true,\n  },\n  marginVertical: {\n    marginTop: true,\n    marginBottom: true,\n  },\n  padding: {\n    paddingTop: true,\n    paddingRight: true,\n    paddingBottom: true,\n    paddingLeft: true,\n  },\n  paddingHorizontal: {\n    paddingLeft: true,\n    paddingRight: true,\n  },\n  paddingVertical: {\n    paddingTop: true,\n    paddingBottom: true,\n  },\n  border: {\n    borderTopColor: true,\n    borderTopStyle: true,\n    borderTopWidth: true,\n    borderRightColor: true,\n    borderRightStyle: true,\n    borderRightWidth: true,\n    borderBottomColor: true,\n    borderBottomStyle: true,\n    borderBottomWidth: true,\n    borderLeftColor: true,\n    borderLeftStyle: true,\n    borderLeftWidth: true,\n  },\n  borderTop: {\n    borderTopColor: true,\n    borderTopStyle: true,\n    borderTopWidth: true,\n  },\n  borderRight: {\n    borderRightColor: true,\n    borderRightStyle: true,\n    borderRightWidth: true,\n  },\n  borderBottom: {\n    borderBottomColor: true,\n    borderBottomStyle: true,\n    borderBottomWidth: true,\n  },\n  borderLeft: {\n    borderLeftColor: true,\n    borderLeftStyle: true,\n    borderLeftWidth: true,\n  },\n  borderColor: {\n    borderTopColor: true,\n    borderRightColor: true,\n    borderBottomColor: true,\n    borderLeftColor: true,\n  },\n  borderRadius: {\n    borderTopLeftRadius: true,\n    borderTopRightRadius: true,\n    borderBottomRightRadius: true,\n    borderBottomLeftRadius: true,\n  },\n  borderStyle: {\n    borderTopStyle: true,\n    borderRightStyle: true,\n    borderBottomStyle: true,\n    borderLeftStyle: true,\n  },\n  borderWidth: {\n    borderTopWidth: true,\n    borderRightWidth: true,\n    borderBottomWidth: true,\n    borderLeftWidth: true,\n  },\n  objectPosition: {\n    objectPositionX: true,\n    objectPositionY: true,\n  },\n  transformOrigin: {\n    transformOriginX: true,\n    transformOriginY: true,\n  },\n  flex: {\n    flexGrow: true,\n    flexShrink: true,\n    flexBasis: true,\n  },\n};\n\n/**\n * Expand the shorthand properties to isolate every declaration from the others.\n *\n * @param { Object } style object\n * @returns { Object } expanded style object\n */\nconst expandStyles = style => {\n  if (!style) return style;\n\n  const propsArray = Object.keys(style);\n  const resolvedStyle = {};\n\n  for (let i = 0; i < propsArray.length; i++) {\n    const key = propsArray[i];\n    const value = style[key];\n\n    if (styleShorthands[key]) {\n      const expandedProps = styleShorthands[key];\n\n      for (const propName in expandedProps) {\n        if (hasOwnProperty.call(expandedProps, propName)) {\n          resolvedStyle[propName] = value;\n        }\n      }\n    } else {\n      resolvedStyle[key] = value;\n    }\n  }\n\n  return resolvedStyle;\n};\n\nexport default expandStyles;\n","import * as R from 'ramda';\n\nimport { DPI } from '../constants';\n\nconst MM_FACTOR = (1 / 25.4) * DPI;\n\nconst CM_FACTOR = (1 / 2.54) * DPI;\n\n/**\n * Parses scalar value in value and unit pairs\n *\n * @param {String} scalar value\n * @returns {Object} parsed value\n */\nconst parseValue = value => {\n  const match = /^(-?\\d*\\.?\\d+)(in|mm|cm|pt|vh|vw|px)?$/g.exec(value);\n\n  return match\n    ? { value: parseFloat(match[1], 10), unit: match[2] || 'pt' }\n    : { value, unit: undefined };\n};\n\n/**\n * Transform given scalar value\n *\n * @param {Object} container\n * @param {String} styles value\n * @returns {Object} transformed value\n */\nconst transformUnit = R.curryN(2, (container, value) => {\n  const scalar = parseValue(value);\n\n  switch (scalar.unit) {\n    case 'in':\n      return scalar.value * DPI;\n    case 'mm':\n      return scalar.value * MM_FACTOR;\n    case 'cm':\n      return scalar.value * CM_FACTOR;\n    case 'vh':\n      return scalar.value * (container.height / 100);\n    case 'vw':\n      return scalar.value * (container.width / 100);\n    default:\n      return scalar.value;\n  }\n});\n\n/**\n * Transform units on given styles object.\n * Container is given to calculate vh and vw\n *\n * @param {Object} container\n * @param {Object} styles object\n * @returns {Object} transformed styles\n */\nconst transformUnits = (container, styles) =>\n  R.map(transformUnit(container), styles);\n\nexport default R.curryN(2, transformUnits);\n","import * as R from 'ramda';\nimport matchMedia from 'media-engine';\n\n/**\n * Resolves media queries in styles object\n *\n * @param {Object} container\n * @param {Object} styles object\n */\nconst resolveMediaQueries = (container, styles) => {\n  return Object.keys(styles).reduce((acc, key) => {\n    if (/@media/.test(key)) {\n      return {\n        ...acc,\n        ...matchMedia({ [key]: styles[key] }, container),\n      };\n    }\n\n    return { ...acc, [key]: styles[key] };\n  }, {});\n};\n\nexport default R.curryN(2, resolveMediaQueries);\n","import * as R from 'ramda';\n\nimport isLink from '../node/isLink';\nimport flattenStyles from '../stylesheet/flatten';\nimport expandStyles from '../stylesheet/expandStyles';\nimport transformUnits from '../stylesheet/transformUnits';\nimport transformStyles from '../stylesheet/transformStyles';\nimport transformColors from '../stylesheet/transformColors';\nimport resolveMediaQueries from '../stylesheet/resolveMediaQueries';\n\nconst LINK_STYLES = {\n  color: 'blue',\n  textDecoration: 'underline',\n};\n\n/**\n * Filter styles with `none` value\n *\n * @param {Object} style object\n * @returns {Object} style without none values\n */\nconst filterNoneValues = R.reject(R.equals('none'));\n\n/**\n * Resolves styles\n *\n * @param {Object} container\n * @param {Object} node\n * @param {Object} style object\n * @returns {Object} resolved style object\n */\nconst resolveStyles = container =>\n  R.compose(\n    transformUnits(container),\n    transformColors,\n    transformStyles,\n    expandStyles,\n    resolveMediaQueries(container),\n    filterNoneValues,\n    flattenStyles,\n  );\n\n/**\n * Resolves node styles\n *\n * @param {Object} container\n * @param {Object} document node\n * @returns {Object} node (and subnodes) with resolved styles\n */\nconst resolveNodeStyles = container => node =>\n  R.o(\n    R.when(isLink, R.evolve({ style: R.merge(LINK_STYLES) })),\n    R.evolve({\n      style: resolveStyles(container),\n      children: R.map(resolveNodeStyles(container)),\n    }),\n  )(node);\n\n/**\n * Resolves page styles\n *\n * @param {Object} document page\n * @returns {Object} document page with resolved styles\n */\nconst resolvePageStyles = page => {\n  const box = R.prop('box', page);\n  const style = R.prop('style', page);\n  const container = R.isEmpty(box) ? style : box;\n\n  return R.evolve({\n    style: resolveStyles(container),\n    children: R.map(resolveNodeStyles(container)),\n  })(page);\n};\n\n/**\n * Resolves root styles\n *\n * @param {Object} document root\n * @returns {Object} document root with resolved styles\n */\nexport default R.evolve({\n  children: R.map(resolvePageStyles),\n});\n","import * as R from 'ramda';\n\nimport matchPercent from '../utils/matchPercent';\n\nconst getTransformStyle = s => R.pathOr('50%', ['style', s]);\n\n/**\n * Get node origin\n *\n * @param {Object} node\n * @returns {Object} node origin\n */\nconst getOrigin = node => {\n  if (!node.box) return {};\n\n  const { left, top, width, height } = node.box;\n  const transformOriginX = getTransformStyle('transformOriginX')(node);\n  const transformOriginY = getTransformStyle('transformOriginY')(node);\n\n  const percentX = matchPercent(transformOriginX);\n  const percentY = matchPercent(transformOriginY);\n\n  const offsetX = percentX ? width * percentX.percent : transformOriginX;\n  const offsetY = percentY ? height * percentY.percent : transformOriginY;\n\n  return { left: left + offsetX, top: top + offsetY };\n};\n\nexport default getOrigin;\n","import * as R from 'ramda';\n\nimport getOrigin from '../node/getOrigin';\n\n/**\n * Resolve node origin\n *\n * @param {Object} node\n * @returns {Object} node with origin attribute\n */\nconst resolveNodeOrigin = node =>\n  R.compose(\n    R.evolve({ children: R.map(resolveNodeOrigin) }),\n    R.converge(R.assoc('origin'), [getOrigin, R.identity]),\n  )(node);\n\n/**\n * Resolve document origins\n *\n * @param {Object} document root\n * @returns {Object} documrnt root\n */\nconst resolveOrigin = R.evolve({\n  children: R.map(resolveNodeOrigin),\n});\n\nexport default resolveOrigin;\n","import * as R from 'ramda';\n\nimport { PORTRAIT, LANDSCAPE } from '../constants';\n\nconst VALID_ORIENTATIONS = [PORTRAIT, LANDSCAPE];\n\n/**\n * Get page orientation. Defaults to landscape\n *\n * @param { Object } page object\n * @returns { String } page orientation\n */\nconst getOrientation = R.compose(\n  R.ifElse(\n    R.includes(R.__, VALID_ORIENTATIONS),\n    R.identity,\n    R.always(PORTRAIT),\n  ),\n  R.pathOr(PORTRAIT, ['props', 'orientation']),\n);\n\nexport default getOrientation;\n","import * as R from 'ramda';\n\nimport getOrientation from './getOrientation';\n\nimport { LANDSCAPE } from '../constants';\n\nconst isLandscape = R.compose(\n  R.equals(LANDSCAPE),\n  getOrientation,\n);\n\nexport default isLandscape;\n","import * as R from 'ramda';\n\nimport isLandscape from './isLandscape';\nimport { PAGE_SIZES } from '../constants';\n\n/**\n * Transforms array into size object\n *\n * @param {Array} array\n * @returns {Object} size object with width and height\n */\nconst toSizeObject = R.applySpec({\n  width: R.prop(0),\n  height: R.prop(1),\n});\n\n/**\n * Flip size object\n *\n * @param {Object} size object\n * @returns {Object} flipped size object\n */\nconst flipSizeObject = R.applySpec({\n  width: R.prop('height'),\n  height: R.prop('width'),\n});\n\n/**\n * Returns size object from a given string\n *\n * @param {String} page size string\n * @returns {Object} size object with width and height\n */\nconst getStringSize = R.compose(\n  toSizeObject,\n  R.prop(R.__, PAGE_SIZES),\n  R.toUpper,\n);\n\n/**\n * Returns size object from a single number\n *\n * @param {Number} page size number\n * @returns {Object} size object with width and height\n */\nconst getNumberSize = R.compose(\n  toSizeObject,\n  v => [v],\n);\n\n/**\n * Throws invalid size error\n *\n * @param {String} invalid page size input\n */\nconst throwInvalidError = size => {\n  throw new Error(`Invalid Page size: ${JSON.stringify(size)}`);\n};\n\n/**\n * Return page size in an object { width, height }\n *\n * @param {Object} page instance\n * @returns {Object} size object with width and height\n */\nconst getSize = page => {\n  const size = R.compose(\n    R.cond([\n      [R.is(String), getStringSize],\n      [R.is(Array), toSizeObject],\n      [R.is(Number), getNumberSize],\n      [R.is(Object), R.identity],\n      [R.T, throwInvalidError],\n    ]),\n    R.pathOr('A4', ['props', 'size']),\n  )(page);\n\n  return isLandscape(page) ? flipSizeObject(size) : size;\n};\n\nexport default getSize;\n","import * as R from 'ramda';\n\n/**\n * Add empt box prop if not present in node\n *\n * @param {Object} node\n * @returns {Object} node with box prop\n */\nconst assocIfNil = (key, value, target) =>\n  R.when(\n    R.compose(\n      R.isNil,\n      R.prop(key),\n    ),\n    R.assoc(key, value),\n  )(target);\n\nexport default R.curryN(3, assocIfNil);\n","import * as R from 'ramda';\n\nimport getPageSize from '../page/getSize';\nimport assocIfNil from '../utils/assocIfNil';\n\n/**\n * Resolves page size\n *\n * @param {Object} page\n * @returns {Object} page with resolved size in style attribute\n */\nexport const resolvePageSize = page => {\n  const size = getPageSize(page);\n  return R.evolve({ style: R.merge(R.__, size) })(page);\n};\n\n/**\n * Resolves page sizes\n *\n * @param {Object} document root\n * @returns {Object} document root with resolved page sizes\n */\nconst resolvePageSizes = R.evolve({\n  children: R.map(\n    R.compose(\n      resolvePageSize,\n      assocIfNil('style', {}),\n    ),\n  ),\n});\n\nexport default resolvePageSizes;\n","/**\n * Get line index at given height\n *\n * @param {Object} node\n * @param {Number} height\n */\nconst lineIndexAtHeight = (node, height) => {\n  let y = 0;\n\n  if (!node.lines) return 0;\n\n  for (let i = 0; i < node.lines.length; i++) {\n    const line = node.lines[i];\n    if (y + line.box.height > height) return i;\n    y += line.box.height;\n  }\n\n  return node.lines.length;\n};\n\nexport default lineIndexAtHeight;\n","/**\n * Get height for given text line index\n *\n * @param {Object} node\n * @param {Number} index\n */\nconst heightAtLineIndex = (node, index) => {\n  let counter = 0;\n\n  if (!node.lines) return counter;\n\n  for (let i = 0; i < index; i++) {\n    const line = node.lines[i];\n\n    if (!line) break;\n\n    counter += line.box.height;\n  }\n\n  return counter;\n};\n\nexport default heightAtLineIndex;\n","import * as R from 'ramda';\n\nimport lineIndexAtHeight from './lineIndexAtHeight';\nimport heightAtLineIndex from './heightAtLineIndex';\n\nconst zero = R.always(0);\n\nconst getTop = R.pathOr(0, ['box', 'top']);\n\nconst getWidows = R.pathOr(2, ['props', 'widows']);\n\nconst getOrphans = R.pathOr(2, ['props', 'orphans']);\n\nconst getLineBreak = (node, height) => {\n  const top = getTop(node);\n  const widows = getWidows(node);\n  const orphans = getOrphans(node);\n  const linesQuantity = node.lines.length;\n  const slicedLine = lineIndexAtHeight(node, height - top);\n\n  if (slicedLine === 0) {\n    return 0;\n  } else if (linesQuantity < orphans) {\n    return linesQuantity;\n  } else if (slicedLine < orphans || linesQuantity < orphans + widows) {\n    return 0;\n  } else if (linesQuantity === orphans + widows) {\n    return orphans;\n  } else if (linesQuantity - slicedLine < widows) {\n    return linesQuantity - widows;\n  }\n\n  return slicedLine;\n};\n\nconst splitText = (node, height) => {\n  const slicedLineIndex = getLineBreak(node, height);\n  const currentHeight = heightAtLineIndex(node, slicedLineIndex);\n  const nextHeight = node.box.height - currentHeight;\n\n  const current = R.evolve(\n    {\n      lines: R.slice(0, slicedLineIndex),\n      style: R.evolve({\n        marginBottom: zero,\n        paddingBottom: zero,\n        borderBottomWidth: zero,\n        borderBottomLeftRadius: zero,\n        borderBottomRightRadius: zero,\n      }),\n      box: {\n        height: R.always(currentHeight),\n        borderBottomWidth: zero,\n      },\n    },\n    node,\n  );\n\n  const next = R.evolve(\n    {\n      lines: R.slice(slicedLineIndex, Infinity),\n      style: R.evolve({\n        marginTop: zero,\n        paddingTop: zero,\n        borderTopWidth: zero,\n        borderTopLeftRadius: zero,\n        borderTopRightRadius: zero,\n      }),\n      box: {\n        top: zero,\n        height: R.always(nextHeight),\n        borderTopWidth: zero,\n      },\n    },\n    node,\n  );\n\n  return [current, next];\n};\n\nexport default splitText;\n","import * as R from 'ramda';\n\nconst zero = R.always(0);\n\nconst getTop = R.pathOr(0, ['box', 'top']);\n\nconst hasFixedHeight = R.hasPath(['style', 'height']);\n\nconst subtractHeight = value =>\n  R.o(R.subtract(R.__, value), R.path(['box', 'height']));\n\nconst splitNode = (node, height) => {\n  if (!node) return [null, null];\n\n  const nodeTop = getTop(node);\n\n  // TODO: We should keep style untouched\n  const current = R.evolve({\n    style: R.evolve({\n      marginBottom: zero,\n      paddingBottom: zero,\n      borderBottomWidth: zero,\n      borderBottomLeftRadius: zero,\n      borderBottomRightRadius: zero,\n    }),\n    box: {\n      height: R.always(height - nodeTop),\n      borderBottomWidth: zero,\n    },\n  })(node);\n\n  const nextHeight = R.ifElse(\n    hasFixedHeight,\n    subtractHeight(height - nodeTop),\n    R.always(null),\n  )(node);\n\n  // TODO: We should keep style untouched\n  const next = R.evolve({\n    style: R.evolve({\n      marginTop: zero,\n      paddingTop: zero,\n      borderTopWidth: zero,\n      borderTopLeftRadius: zero,\n      borderTopRightRadius: zero,\n    }),\n    box: {\n      top: zero,\n      height: R.always(nextHeight),\n      borderTopWidth: zero,\n    },\n  })(node);\n\n  return [current, next];\n};\n\nexport default splitNode;\n","import * as R from 'ramda';\n\nimport castArray from '../utils/castArray';\nimport { TEXT_INSTANCE } from '../constants';\n\nconst isString = R.is(String);\n\nconst isNumber = R.is(Number);\n\nconst isNotString = R.complement(isString);\n\n/**\n * Transforms a react element instance to internal element format\n *\n * @param {Object} React element\n * @returns {Object} parsed react element\n */\nconst createInstance = element => {\n  if (isString(element) || isNumber(element))\n    return { type: TEXT_INSTANCE, value: `${element}` };\n\n  if (isNotString(element.type))\n    return createInstance(element.type(element.props));\n\n  const {\n    type,\n    props: { style = {}, children = [], ...props },\n  } = element;\n\n  const nextChildren = R.compose(\n    R.map(createInstance),\n    castArray,\n  )(children);\n\n  return {\n    type,\n    style,\n    props,\n    box: {},\n    children: nextChildren,\n  };\n};\n\nexport default createInstance;\n","import * as R from 'ramda';\n\n/**\n * Get many nodes height\n *\n * @param {Array} nodes\n * @return {number} nodes height\n */\nconst getNodesHeight = nodes => {\n  let max = 0;\n  let min = Infinity;\n\n  if (R.isEmpty(nodes)) return 0;\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    min = Math.min(min, node.box.top);\n    max = Math.max(max, node.box.top + node.box.height);\n  }\n\n  return max - min;\n};\n\nexport default getNodesHeight;\n","import * as R from 'ramda';\n\nimport isSvg from './isSvg';\nimport isNote from './isNote';\nimport isImage from './isImage';\nimport isCanvas from './isCanvas';\nimport getNodesHeight from './getNodesHeight';\n\nconst getWrap = R.ifElse(\n  R.anyPass([isSvg, isNote, isImage, isCanvas]),\n  R.always(false),\n  R.pathOr(true, ['props', 'wrap']),\n);\n\nconst getBreak = R.pathOr(false, ['props', 'break']);\n\nconst getMinPresenceAhead = R.path(['props', 'minPresenceAhead']);\n\nconst defaultPresenceAhead = element => height =>\n  Math.min(element.box.height, height);\n\nconst getPresenceAhead = (elements, height) => {\n  let result = 0;\n\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n\n    if (!element.box) continue;\n\n    const isElementInside = height > element.box.top;\n    const presenceAhead =\n      element.props.presenceAhead || defaultPresenceAhead(element);\n\n    if (element && isElementInside) {\n      result += presenceAhead(height - element.box.top);\n    }\n  }\n\n  return result;\n};\n\nconst shouldBreak = (child, futureElements, height) => {\n  const minPresenceAhead = getMinPresenceAhead(child);\n  const presenceAhead = getPresenceAhead(futureElements, height);\n  const futureHeight = getNodesHeight(futureElements);\n  const shouldSplit = height < child.box.top + child.box.height;\n  const shouldWrap = getWrap(child);\n\n  return (\n    getBreak(child) ||\n    (!shouldWrap && shouldSplit) ||\n    (minPresenceAhead < futureHeight && presenceAhead < minPresenceAhead)\n  );\n};\n\nexport default shouldBreak;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport firstPass from '../utils/firstPass';\n\nconst getComputedPadding = edge => node => {\n  const yogaNode = node._yogaNode;\n  return yogaNode ? yogaNode.getComputedPadding(edge) : null;\n};\n\n/**\n * Get Yoga computed paddings. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} paddings\n */\nconst getPadding = R.applySpec({\n  paddingTop: firstPass(\n    getComputedPadding(Yoga.EDGE_TOP),\n    R.path(['box', 'paddingTop']),\n    R.path(['style', 'paddingTop']),\n    R.path(['style', 'paddingVertical']),\n    R.path(['style', 'padding']),\n    R.always(0),\n  ),\n  paddingRight: firstPass(\n    getComputedPadding(Yoga.EDGE_RIGHT),\n    R.path(['box', 'paddingRight']),\n    R.path(['style', 'paddingRight']),\n    R.path(['style', 'paddingHorizontal']),\n    R.path(['style', 'padding']),\n    R.always(0),\n  ),\n  paddingBottom: firstPass(\n    getComputedPadding(Yoga.EDGE_BOTTOM),\n    R.path(['box', 'paddingBottom']),\n    R.path(['style', 'paddingBottom']),\n    R.path(['style', 'paddingVertical']),\n    R.path(['style', 'padding']),\n    R.always(0),\n  ),\n  paddingLeft: firstPass(\n    getComputedPadding(Yoga.EDGE_LEFT),\n    R.path(['box', 'paddingLeft']),\n    R.path(['style', 'paddingLeft']),\n    R.path(['style', 'paddingHorizontal']),\n    R.path(['style', 'padding']),\n    R.always(0),\n  ),\n});\n\nexport default getPadding;\n","import * as R from 'ramda';\n\nimport getPadding from '../node/getPadding';\n\nconst getContentArea = page => {\n  const { paddingTop } = getPadding(page);\n  const height = R.path(['style', 'height'], page);\n  return height - paddingTop;\n};\n\nexport default getContentArea;\n","const IGNORABLE_CODEPOINTS = [\n  8232, // LINE_SEPARATOR\n  8233, // PARAGRAPH_SEPARATOR\n];\n\nconst buildSubsetForFont = font =>\n  IGNORABLE_CODEPOINTS.reduce((acc, codePoint) => {\n    if (font.hasGlyphForCodePoint && font.hasGlyphForCodePoint(codePoint)) {\n      return acc;\n    }\n    return [...acc, String.fromCharCode(codePoint)];\n  }, []);\n\nexport const ignoreChars = fragments =>\n  fragments.map(fragment => {\n    const charSubset = buildSubsetForFont(fragment.attributes.font);\n    const subsetRegex = new RegExp(charSubset.join('|'));\n\n    return {\n      string: fragment.string.replace(subsetRegex, ''),\n      attributes: fragment.attributes,\n    };\n  });\n","import AttributedString from '@react-pdf/textkit/attributedString';\n\nimport Font from '../font';\nimport isImage from '../node/isImage';\nimport { embedEmojis } from './emoji';\nimport transformText from './transformText';\nimport { ignoreChars } from './ignorableChars';\nimport isTextInstance from '../node/isTextInstance';\n\nconst PREPROCESSORS = [ignoreChars, embedEmojis];\n\n/**\n * Get textkit framgents of given node object\n *\n * @param {Object} instance node\n * @returns {Array} text fragments\n */\nconst getFragments = instance => {\n  if (!instance) return [{ string: '' }];\n\n  let fragments = [];\n  const {\n    color = 'black',\n    backgroundColor,\n    fontFamily = 'Helvetica',\n    fontWeight,\n    fontStyle,\n    fontSize = 18,\n    textAlign = 'left',\n    lineHeight,\n    textDecoration,\n    textDecorationColor,\n    textDecorationStyle,\n    textTransform,\n    letterSpacing,\n    textIndent,\n    opacity,\n  } = instance.style;\n\n  const obj = Font.getFont({ fontFamily, fontWeight, fontStyle });\n  const font = obj ? obj.data : fontFamily;\n\n  const attributes = {\n    font,\n    color,\n    opacity,\n    fontSize,\n    backgroundColor,\n    align: textAlign,\n    indent: textIndent,\n    link: instance.src,\n    characterSpacing: letterSpacing,\n    underlineStyle: textDecorationStyle,\n    underline: textDecoration === 'underline',\n    underlineColor: textDecorationColor || color,\n    strike: textDecoration === 'line-through',\n    strikeStyle: textDecorationStyle,\n    strikeColor: textDecorationColor || color,\n    lineHeight: lineHeight ? lineHeight * fontSize : null,\n  };\n\n  instance.children.forEach(child => {\n    if (isImage(child)) {\n      fragments.push({\n        string: String.fromCharCode(0xfffc),\n        attributes: {\n          ...attributes,\n          attachment: {\n            width: child.style.width || fontSize,\n            height: child.style.height || fontSize,\n            image: child.image.data,\n          },\n        },\n      });\n    } else if (isTextInstance(child)) {\n      fragments.push({\n        string: transformText(child.value, textTransform),\n        attributes,\n      });\n    } else {\n      if (child) {\n        fragments.push(...getFragments(child));\n      }\n    }\n  });\n\n  for (const preprocessor of PREPROCESSORS) {\n    fragments = preprocessor(fragments);\n  }\n\n  return fragments;\n};\n\n/**\n * Get textkit attributed string from text node\n *\n * @param {Object} instance node\n * @returns {Object} attributed string\n */\nconst getAttributedString = instance =>\n  AttributedString.fromFragments(getFragments(instance));\n\nexport default getAttributedString;\n","import * as R from 'ramda';\nimport layoutEngine from '@react-pdf/textkit/layout';\nimport linebreaker from '@react-pdf/textkit/engines/linebreaker';\nimport justification from '@react-pdf/textkit/engines/justification';\nimport textDecoration from '@react-pdf/textkit/engines/textDecoration';\nimport scriptItemizer from '@react-pdf/textkit/engines/scriptItemizer';\nimport wordHyphenation from '@react-pdf/textkit/engines/wordHyphenation';\n\nimport Font from '../font';\nimport fontSubstitution from './fontSubstitution';\nimport getAttributedString from './getAttributedString';\n\nconst engines = {\n  linebreaker,\n  justification,\n  textDecoration,\n  scriptItemizer,\n  wordHyphenation,\n  fontSubstitution,\n};\n\nconst engine = layoutEngine(engines);\n\n/**\n * Get layout container for specific text node\n *\n * @param {Object} node\n * @param {Number} width\n * @param {Number} height\n * @returns {Object} layout container\n */\nconst getContainer = (node, width, height) => {\n  const maxLines = R.path(['style', 'maxLines'], node);\n  const textOverflow = R.path(['style', 'textOverflow'], node);\n\n  return {\n    x: 0,\n    y: 0,\n    width,\n    maxLines,\n    height: height || Infinity,\n    truncateMode: textOverflow,\n  };\n};\n\n/**\n * Get text layout options for specific text node\n *\n * @param {Object} node instance\n * @returns {Object} layout options\n */\nconst getLayoutOptions = node => ({\n  hyphenationPenalty: node.props.hyphenationPenalty,\n  hyphenationCallback: Font.getHyphenationCallback(),\n  shrinkWhitespaceFactor: { before: -0.5, after: -0.5 },\n});\n\n/**\n * Get text lines for given node\n *\n * @param {Object} node\n * @param {Number} container width\n * @param {Number} container height\n * @returns {Array} layout lines\n */\nconst layoutText = R.compose(\n  R.reduce(R.concat, []),\n  R.converge(engine, [getAttributedString, getContainer, getLayoutOptions]),\n);\n\nexport default layoutText;\n","import * as R from 'ramda';\n\nimport isSvg from '../node/isSvg';\nimport isText from '../node/isText';\nimport layoutText from '../text/layoutText';\n\nconst isNotSvg = R.complement(isSvg);\n\nconst hasLines = node =>\n  node.props.fixed ? !R.isEmpty(node.lines) : !!node.lines;\n\nconst shouldLayoutText = node => isText(node) && !hasLines(node);\n\n/**\n * Performs text layout on text node if wasn't calculated before.\n * Text layout is usually performed on Yoga's layout process (via setMeasureFunc),\n * but we need to layout those nodes with fixed width and height.\n *\n * @param {Object} node\n * @returns {Object} layouted node\n */\nconst resolveTextLayout = node =>\n  R.compose(\n    R.evolve({\n      children: R.map(R.when(isNotSvg, resolveTextLayout)),\n    }),\n    R.when(\n      shouldLayoutText,\n      R.compose(\n        R.converge(R.assoc('lines'), [\n          R.converge(layoutText, [\n            R.identity,\n            R.path(['box', 'width']),\n            R.path(['box', 'height']),\n          ]),\n          R.identity,\n        ]),\n      ),\n    ),\n  )(node);\n\nexport default resolveTextLayout;\n","import * as R from 'ramda';\n\nimport isSvg from '../node/isSvg';\nimport { INHERITED_PROPERTIES } from '../constants';\n\n/**\n * Get styles sub group of inherited properties\n *\n * @param {Object} style object\n * @returns {Object} style object only with inherited properties\n */\nconst getInheritStyles = R.compose(\n  R.pick(INHERITED_PROPERTIES),\n  R.propOr({}, 'style'),\n);\n\n/**\n * Merges styles with node\n *\n * @param {Object} style object\n * @param {Object} node\n * @returns {Object} node with styles merged\n */\nconst mergeStyles = styles =>\n  R.evolve({\n    style: R.merge(styles),\n  });\n\n/**\n * Inherit style values from the root to the leafs\n *\n * @param {Object} document root\n * @returns {Object} document root with inheritance\n *\n */\nconst resolveInheritance = node => {\n  if (isSvg(node)) return node;\n\n  const inheritStyles = getInheritStyles(node);\n\n  return R.evolve({\n    children: R.map(\n      R.compose(\n        resolveInheritance,\n        mergeStyles(inheritStyles),\n      ),\n    ),\n  })(node);\n};\n\nexport default resolveInheritance;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport firstPass from '../utils/firstPass';\n\nconst getComputedMargin = edge => node => {\n  const yogaNode = node._yogaNode;\n  return yogaNode ? yogaNode.getComputedMargin(edge) : null;\n};\n\n/**\n * Get Yoga computed magins. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} margins\n */\nconst getMargin = R.applySpec({\n  marginTop: firstPass(\n    getComputedMargin(Yoga.EDGE_TOP),\n    R.path(['box', 'marginTop']),\n    R.path(['style', 'marginTop']),\n    R.path(['style', 'marginVertical']),\n    R.path(['style', 'margin']),\n    R.always(0),\n  ),\n  marginRight: firstPass(\n    getComputedMargin(Yoga.EDGE_RIGHT),\n    R.path(['box', 'marginRight']),\n    R.path(['style', 'marginRight']),\n    R.path(['style', 'marginHorizontal']),\n    R.path(['style', 'margin']),\n    R.always(0),\n  ),\n  marginBottom: firstPass(\n    getComputedMargin(Yoga.EDGE_BOTTOM),\n    R.path(['box', 'marginBottom']),\n    R.path(['style', 'marginBottom']),\n    R.path(['style', 'marginVertical']),\n    R.path(['style', 'margin']),\n    R.always(0),\n  ),\n  marginLeft: firstPass(\n    getComputedMargin(Yoga.EDGE_LEFT),\n    R.path(['box', 'marginLeft']),\n    R.path(['style', 'marginLeft']),\n    R.path(['style', 'marginHorizontal']),\n    R.path(['style', 'margin']),\n    R.always(0),\n  ),\n});\n\nexport default getMargin;\n","import * as R from 'ramda';\n\nconst getTop = yogaNode => (yogaNode ? yogaNode.getComputedTop() : 0);\nconst getRight = yogaNode => (yogaNode ? yogaNode.getComputedRight() : 0);\nconst getBottom = yogaNode => (yogaNode ? yogaNode.getComputedBottom() : 0);\nconst getLeft = yogaNode => (yogaNode ? yogaNode.getComputedLeft() : 0);\n\n/**\n * Get Yoga computed position. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} position\n */\nconst getPosition = node => {\n  const yogaNode = node._yogaNode;\n\n  return R.applySpec({\n    top: getTop,\n    right: getRight,\n    bottom: getBottom,\n    left: getLeft,\n  })(yogaNode);\n};\n\nexport default getPosition;\n","const DEFAULT_DIMENSION = {\n  width: 0,\n  height: 0,\n};\n\n/**\n * Get Yoga computed dimensions. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} dimensions\n */\nconst getDimension = node => {\n  const yogaNode = node._yogaNode;\n\n  if (!yogaNode) return DEFAULT_DIMENSION;\n\n  return {\n    width: yogaNode.getComputedWidth(),\n    height: yogaNode.getComputedHeight(),\n  };\n};\n\nexport default getDimension;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nconst getComputedBorder = edge => yogaNode =>\n  yogaNode ? yogaNode.getComputedBorder(edge) : 0;\n\n/**\n * Get Yoga computed border width. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} border widths\n */\nconst getBorderWidth = node => {\n  const yogaNode = node._yogaNode;\n\n  return R.applySpec({\n    borderTopWidth: getComputedBorder(Yoga.EDGE_TOP),\n    borderRightWidth: getComputedBorder(Yoga.EDGE_RIGHT),\n    borderBottomWidth: getComputedBorder(Yoga.EDGE_BOTTOM),\n    borderLeftWidth: getComputedBorder(Yoga.EDGE_LEFT),\n  })(yogaNode);\n};\n\nexport default getBorderWidth;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\n/**\n * Set display attribute to node's Yoga instance\n *\n * @param {String} display\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setDisplay = value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (yogaNode) {\n      yogaNode.setDisplay(\n        value === 'none' ? Yoga.DISPLAY_NONE : Yoga.DISPLAY_FLEX,\n      );\n    }\n  });\n\nexport default setDisplay;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\n/**\n * Set overflow attribute to node's Yoga instance\n *\n * @param {String} overflow value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setOverflow = value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (!R.isNil(value) && yogaNode) {\n      const yogaValue = R.cond([\n        [R.equals('hidden'), R.always(Yoga.OVERFLOW_HIDDEN)],\n        [R.equals('scroll'), R.always(Yoga.OVERFLOW_SCROLL)],\n        [R.T, R.always(Yoga.OVERFLOW_VISIBLE)],\n      ])(value);\n\n      yogaNode.setOverflow(yogaValue);\n    }\n  });\n\nexport default setOverflow;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\n/**\n * Set flex wrap attribute to node's Yoga instance\n *\n * @param {String} flex wrap value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setFlexWrap = value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (yogaNode) {\n      const yogaValue = R.cond([\n        [R.equals('wrap'), R.always(Yoga.WRAP_WRAP)],\n        [R.equals('wrap-reverse'), R.always(Yoga.WRAP_WRAP_REVERSE)],\n        [R.T, R.always(Yoga.WRAP_NO_WRAP)],\n      ])(value);\n\n      yogaNode.setFlexWrap(yogaValue);\n    }\n  });\n\nexport default setFlexWrap;\n","import * as R from 'ramda';\n\nimport upperFirst from '../utils/upperFirst';\nimport matchPercent from '../utils/matchPercent';\n\nconst isNotNil = R.complement(R.isNil);\n\n/**\n * Set generic yoga attribute to node's Yoga instance, handing `auto`, edges and percentage cases\n *\n * @param {String} property\n * @param {Number} edge\n * @param {any} value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setYogaValue = (attr, edge) => value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (!R.isNil(value) && yogaNode) {\n      const hasEdge = isNotNil(edge);\n      const fixedMethod = `set${upperFirst(attr)}`;\n      const autoMethod = `${fixedMethod}Auto`;\n      const percentMethod = `${fixedMethod}Percent`;\n      const percent = matchPercent(value);\n\n      if (percent && !yogaNode[percentMethod]) {\n        throw new Error(`You can't pass percentage values to ${attr} property`);\n      }\n\n      if (percent) {\n        hasEdge\n          ? yogaNode[percentMethod](edge, percent.value)\n          : yogaNode[percentMethod](percent.value);\n      } else if (value === 'auto') {\n        hasEdge ? yogaNode[autoMethod](edge) : yogaNode[autoMethod]();\n      } else {\n        hasEdge\n          ? yogaNode[fixedMethod](edge, value)\n          : yogaNode[fixedMethod](value);\n      }\n    }\n  });\n\nexport default setYogaValue;\n","import * as R from 'ramda';\n\nimport setYogaValue from './setYogaValue';\n\n/**\n * Set flex grow attribute to node's Yoga instance\n *\n * @param {Number} flex grow value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setFlexGrow = R.compose(\n  setYogaValue('flexGrow'),\n  R.defaultTo(0),\n);\n\nexport default setFlexGrow;\n","import setYogaValue from './setYogaValue';\n\n/**\n * Set flex basis attribute to node's Yoga instance\n *\n * @param {Number} flex basis value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setFlexBasis = setYogaValue('flexBasis');\n\nexport default setFlexBasis;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport upperFirst from '../utils/upperFirst';\n\n/**\n * Set generic align attribute to node's Yoga instance\n *\n * @param {String} specific align property\n * @param {String} align value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setAlign = attr => value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (yogaNode) {\n      const yogaValue = R.cond([\n        [R.equals('flex-start'), R.always(Yoga.ALIGN_FLEX_START)],\n        [R.equals('center'), R.always(Yoga.ALIGN_CENTER)],\n        [R.equals('flex-end'), R.always(Yoga.ALIGN_FLEX_END)],\n        [R.equals('stretch'), R.always(Yoga.ALIGN_STRETCH)],\n        [R.equals('baseline'), R.always(Yoga.ALIGN_BASELINE)],\n        [R.equals('space-between'), R.always(Yoga.ALIGN_SPACE_BETWEEN)],\n        [R.equals('space-around'), R.always(Yoga.ALIGN_SPACE_AROUND)],\n        [\n          R.T,\n          R.always(attr === 'items' ? Yoga.ALIGN_STRETCH : Yoga.ALIGN_AUTO),\n        ],\n      ])(value);\n\n      yogaNode[`setAlign${upperFirst(attr)}`](yogaValue);\n    }\n  });\n\nexport default setAlign;\n","import setAlign from './setAlign';\n\n/**\n * Set align self attribute to node's Yoga instance\n *\n * @param {String} align value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setAlignSelf = setAlign('self');\n\nexport default setAlignSelf;\n","import setAlign from './setAlign';\n\n/**\n * Set align items attribute to node's Yoga instance\n *\n * @param {String} align value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setAlignItems = setAlign('items');\n\nexport default setAlignItems;\n","import * as R from 'ramda';\n\nimport setYogaValue from './setYogaValue';\n\n/**\n * Set flex shrink attribute to node's Yoga instance\n *\n * @param {Number} flex shrink value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setFlexShrink = R.compose(\n  setYogaValue('flexShrink'),\n  R.defaultTo(1),\n);\n\nexport default setFlexShrink;\n","import * as R from 'ramda';\n\n/**\n * Set aspect ratio attribute to node's Yoga instance\n *\n * @param {Number} ratio\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setAspectRatio = value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (!R.isNil(value) && yogaNode) {\n      yogaNode.setAspectRatio(value);\n    }\n  });\n\nexport default setAspectRatio;\n","import setAlign from './setAlign';\n\n/**\n * Set align content attribute to node's Yoga instance\n *\n * @param {String} align value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setAlignContent = setAlign('content');\n\nexport default setAlignContent;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\n/**\n * Set position type attribute to node's Yoga instance\n *\n * @param {String} position type\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setPositionType = value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (!R.isNil(value) && yogaNode) {\n      yogaNode.setPositionType(\n        value === 'absolute'\n          ? Yoga.POSITION_TYPE_ABSOLUTE\n          : Yoga.POSITION_TYPE_RELATIVE,\n      );\n    }\n  });\n\nexport default setPositionType;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nconst isRow = R.equals('row');\nconst isRowReverse = R.equals('row-reverse');\nconst isColumnReverse = R.equals('column-reverse');\n\n/**\n * Set flex direction attribute to node's Yoga instance\n *\n * @param {String} flex direction value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setFlexDirection = value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (yogaNode) {\n      const yogaValue = R.cond([\n        [isRow, R.always(Yoga.FLEX_DIRECTION_ROW)],\n        [isRowReverse, R.always(Yoga.FLEX_DIRECTION_ROW_REVERSE)],\n        [isColumnReverse, R.always(Yoga.FLEX_DIRECTION_COLUMN_REVERSE)],\n        [R.T, R.always(Yoga.FLEX_DIRECTION_COLUMN)],\n      ])(value);\n\n      yogaNode.setFlexDirection(yogaValue);\n    }\n  });\n\nexport default setFlexDirection;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\n/**\n * Set justify content attribute to node's Yoga instance\n *\n * @param {String} justify content value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setJustifyContent = value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (!R.isNil(value) && yogaNode) {\n      const yogaValue = R.cond([\n        [R.equals('center'), R.always(Yoga.JUSTIFY_CENTER)],\n        [R.equals('flex-end'), R.always(Yoga.JUSTIFY_FLEX_END)],\n        [R.equals('space-between'), R.always(Yoga.JUSTIFY_SPACE_BETWEEN)],\n        [R.equals('space-around'), R.always(Yoga.JUSTIFY_SPACE_AROUND)],\n        [R.equals('space-evenly'), R.always(Yoga.JUSTIFY_SPACE_EVENLY)],\n        [R.T, R.always(Yoga.JUSTIFY_FLEX_START)],\n      ])(value);\n\n      yogaNode.setJustifyContent(yogaValue);\n    }\n  });\n\nexport default setJustifyContent;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport setYogaValue from './setYogaValue';\n\n/**\n * Set margin top attribute to node's Yoga instance\n *\n * @param {Number} margin top\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMarginTop = setYogaValue('margin', Yoga.EDGE_TOP);\n\n/**\n * Set margin right attribute to node's Yoga instance\n *\n * @param {Number} margin right\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMarginRight = setYogaValue('margin', Yoga.EDGE_RIGHT);\n\n/**\n * Set margin bottom attribute to node's Yoga instance\n *\n * @param {Number} margin bottom\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMarginBottom = setYogaValue('margin', Yoga.EDGE_BOTTOM);\n\n/**\n * Set margin left attribute to node's Yoga instance\n *\n * @param {Number} margin left\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMarginLeft = setYogaValue('margin', Yoga.EDGE_LEFT);\n\n/**\n * Set all margins at once\n *\n * @param {Number} margin\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMargin = margin =>\n  R.tap(node => {\n    setMarginTop(margin)(node);\n    setMarginRight(margin)(node);\n    setMarginBottom(margin)(node);\n    setMarginLeft(margin)(node);\n  });\n\nexport default setMargin;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport setYogaValue from './setYogaValue';\n\n/**\n * Set padding top attribute to node's Yoga instance\n *\n * @param {Number} padding top\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPaddingTop = setYogaValue('padding', Yoga.EDGE_TOP);\n\n/**\n * Set padding right attribute to node's Yoga instance\n *\n * @param {Number} padding right\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPaddingRight = setYogaValue('padding', Yoga.EDGE_RIGHT);\n\n/**\n * Set padding bottom attribute to node's Yoga instance\n *\n * @param {Number} padding bottom\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPaddingBottom = setYogaValue('padding', Yoga.EDGE_BOTTOM);\n\n/**\n * Set padding left attribute to node's Yoga instance\n *\n * @param {Number} padding left\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPaddingLeft = setYogaValue('padding', Yoga.EDGE_LEFT);\n\n/**\n * Set all paddings at once\n *\n * @param {Number} margin\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPadding = padding =>\n  R.tap(node => {\n    setPaddingTop(padding)(node);\n    setPaddingRight(padding)(node);\n    setPaddingBottom(padding)(node);\n    setPaddingLeft(padding)(node);\n  });\n\nexport default setPadding;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport setYogaValue from './setYogaValue';\n\n/**\n * Set border top attribute to node's Yoga instance\n *\n * @param {Number} border top width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setBorderTop = setYogaValue('border', Yoga.EDGE_TOP);\n\n/**\n * Set border right attribute to node's Yoga instance\n *\n * @param {Number} border right width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setBorderRight = setYogaValue('border', Yoga.EDGE_RIGHT);\n\n/**\n * Set border bottom attribute to node's Yoga instance\n *\n * @param {Number} border bottom width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setBorderBottom = setYogaValue('border', Yoga.EDGE_BOTTOM);\n\n/**\n * Set border left attribute to node's Yoga instance\n *\n * @param {Number} border left width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setBorderLeft = setYogaValue('border', Yoga.EDGE_LEFT);\n\n/**\n * Set all border widths at once\n *\n * @param {Number} border width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setBorder = width =>\n  R.tap(node => {\n    setBorderTop(width)(node);\n    setBorderRight(width)(node);\n    setBorderBottom(width)(node);\n    setBorderLeft(width)(node);\n  });\n\nexport default setBorder;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport setYogaValue from './setYogaValue';\n\n/**\n * Set position top attribute to node's Yoga instance\n *\n * @param {Number} position top\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPositionTop = setYogaValue('position', Yoga.EDGE_TOP);\n\n/**\n * Set position right attribute to node's Yoga instance\n *\n * @param {Number} position right\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPositionRight = setYogaValue('position', Yoga.EDGE_RIGHT);\n\n/**\n * Set position bottom attribute to node's Yoga instance\n *\n * @param {Number} position bottom\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPositionBottom = setYogaValue('position', Yoga.EDGE_BOTTOM);\n\n/**\n * Set position left attribute to node's Yoga instance\n *\n * @param {Number} position left\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPositionLeft = setYogaValue('position', Yoga.EDGE_LEFT);\n\n/**\n * Set all positions at once\n *\n * @param {Number} position\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPosition = position =>\n  R.tap(node => {\n    setPositionTop(position)(node);\n    setPositionRight(position)(node);\n    setPositionBottom(position)(node);\n    setPositionLeft(position)(node);\n  });\n\nexport default setPosition;\n","import setYogaValue from './setYogaValue';\n\n/**\n * Set width to node's Yoga instance\n *\n * @param {Number} width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setWidth = setYogaValue('width');\n\n/**\n * Set min width to node's Yoga instance\n *\n * @param {Number} min width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMinWidth = setYogaValue('minWidth');\n\n/**\n * Set max width to node's Yoga instance\n *\n * @param {Number} max width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMaxWidth = setYogaValue('maxWidth');\n\n/**\n * Set height to node's Yoga instance\n *\n * @param {Number} height\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setHeight = setYogaValue('height');\n\n/**\n * Set min height to node's Yoga instance\n *\n * @param {Number} min height\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMinHeight = setYogaValue('minHeight');\n\n/**\n * Set max height to node's Yoga instance\n *\n * @param {Number} max height\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMaxHeight = setYogaValue('maxHeight');\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nconst getAspectRatio = viewbox => {\n  if (!viewbox) return null;\n  return (viewbox.maxX - viewbox.minX) / (viewbox.maxY - viewbox.minY);\n};\n\n/**\n * Yoga svg measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @param {Number} width\n * @param {Number} widthMode\n * @param {Number} height\n * @param {Number} heightMode\n * @returns {Object} canvas width and height\n */\nconst measureCanvas = (page, node, width, widthMode, height, heightMode) => {\n  const aspectRatio = getAspectRatio(node.props.viewBox) || 1;\n\n  if (\n    widthMode === Yoga.MEASURE_MODE_EXACTLY ||\n    widthMode === Yoga.MEASURE_MODE_AT_MOST\n  ) {\n    return { width, height: width / aspectRatio };\n  }\n\n  if (heightMode === Yoga.MEASURE_MODE_EXACTLY) {\n    return { width: height * aspectRatio };\n  }\n\n  return {};\n};\n\nexport default R.curryN(6, measureCanvas);\n","import AttributedString from '@react-pdf/textkit/attributedString';\n\n/**\n * Get lines width (if any)\n *\n * @param {Object} node\n * @returns {Number} lines width\n */\nconst linesWidth = node => {\n  if (!node.lines) return -1;\n  return Math.max(\n    ...node.lines.map(line => AttributedString.advanceWidth(line)),\n  );\n};\n\nexport default linesWidth;\n","/**\n * Get lines height (if any)\n *\n * @param {Object} node\n * @returns {Number} lines height\n */\nconst linesHeight = node => {\n  if (!node.lines) return -1;\n  return node.lines.reduce((acc, line) => acc + line.box.height, 0);\n};\n\nexport default linesHeight;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport layoutText from './layoutText';\nimport linesWidth from './linesWidth';\nimport linesHeight from './linesHeight';\n\n/**\n * Yoga text measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @param {Number} width\n * @param {Number} widthMode\n * @param {Number} height\n * @param {Number} heightMode\n * @returns {Object} text width and height\n */\nconst measureText = (page, node, width, widthMode, height, heightMode) => {\n  if (widthMode === Yoga.MEASURE_MODE_EXACTLY) {\n    if (!node.lines) node.lines = layoutText(node, width, height);\n\n    return { height: linesHeight(node) };\n  }\n\n  if (widthMode === Yoga.MEASURE_MODE_AT_MOST) {\n    if (!node.lines) node.lines = layoutText(node, width, height);\n\n    return {\n      height: linesHeight(node),\n      width: Math.min(width, linesWidth(node)),\n    };\n  }\n\n  return {};\n};\n\nexport default R.curryN(6, measureText);\n","import * as R from 'ramda';\n\n/**\n * Get image ratio\n *\n * @param {Object} image node\n * @returns {Number} image ratio\n */\nconst getRatio = R.ifElse(\n  R.hasPath(['image', 'data']),\n  node => node.image.width / node.image.height,\n  R.always(1),\n);\n\nexport default getRatio;\n","import * as R from 'ramda';\n\n/**\n * Checks if page has auto height\n *\n * @param {Object} page\n * @returns {Boolean} is page height auto\n */\nconst isHeightAuto = R.pathSatisfies(R.isNil, ['box', 'height']);\n\nexport default isHeightAuto;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport getRatio from '../image/getRatio';\nimport getMargin from '../node/getMargin';\nimport getPadding from '../node/getPadding';\nimport isHeightAuto from '../page/isHeightAuto';\n\nconst SAFETY_HEIGHT = 10;\n\n/**\n * Yoga image measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @param {Number} width\n * @param {Number} widthMode\n * @param {Number} height\n * @param {Number} heightMode\n * @returns {Object} image width and height\n */\nconst measureImage = (page, node, width, widthMode, height, heightMode) => {\n  const imageRatio = getRatio(node);\n  const imageMargin = getMargin(node);\n  const pagePadding = getPadding(page);\n  const pageArea = isHeightAuto(page)\n    ? Infinity\n    : page.box.height -\n      pagePadding.paddingTop -\n      pagePadding.paddingBottom -\n      imageMargin.marginTop -\n      imageMargin.marginBottom -\n      SAFETY_HEIGHT;\n\n  // Skip measure if image data not present yet\n  if (!node.image) return { width: 0, height: 0 };\n\n  if (\n    widthMode === Yoga.MEASURE_MODE_EXACTLY &&\n    heightMode === Yoga.MEASURE_MODE_UNDEFINED\n  ) {\n    const scaledHeight = width / imageRatio;\n    return { height: Math.min(pageArea, scaledHeight) };\n  }\n\n  if (\n    heightMode === Yoga.MEASURE_MODE_EXACTLY &&\n    (widthMode === Yoga.MEASURE_MODE_AT_MOST ||\n      widthMode === Yoga.MEASURE_MODE_UNDEFINED)\n  ) {\n    return { width: Math.min(height * imageRatio, width) };\n  }\n\n  if (\n    widthMode === Yoga.MEASURE_MODE_EXACTLY &&\n    heightMode === Yoga.MEASURE_MODE_AT_MOST\n  ) {\n    const scaledHeight = width / imageRatio;\n    return { height: Math.min(height, pageArea, scaledHeight) };\n  }\n\n  if (\n    widthMode === Yoga.MEASURE_MODE_AT_MOST &&\n    heightMode === Yoga.MEASURE_MODE_AT_MOST\n  ) {\n    if (imageRatio > 1) {\n      return {\n        width: width,\n        height: Math.min(width / imageRatio, height),\n      };\n    } else {\n      return {\n        width: Math.min(height * imageRatio, width),\n        height: height,\n      };\n    }\n  }\n\n  return { height, width };\n};\n\nexport default R.curryN(6, measureImage);\n","import * as R from 'ramda';\n\nimport getMargin from '../node/getMargin';\nimport getPadding from '../node/getPadding';\nimport isHeightAuto from '../page/isHeightAuto';\n\nconst SAFETY_HEIGHT = 10;\n\nconst getMax = R.reduce(R.max, -Infinity);\n\n/**\n * Helper object to predict canvas size\n * TODO: Implement remaining functions (as close as possible);\n */\nconst measureCtx = () => {\n  const ctx = {};\n  const points = [];\n\n  const nil = () => ctx;\n  const addPoint = (x, y) => points.push([x, y]);\n\n  const moveTo = R.compose(\n    nil,\n    addPoint,\n  );\n\n  const rect = (x, y, w, h) => {\n    addPoint(x, y);\n    addPoint(x + w, y);\n    addPoint(x, y + h);\n    addPoint(x + w, y + h);\n    return ctx;\n  };\n\n  const ellipse = (x, y, rx, ry) => {\n    ry = ry || rx;\n\n    addPoint(x - rx, y - ry);\n    addPoint(x + rx, y - ry);\n    addPoint(x + rx, y + ry);\n    addPoint(x - rx, y + ry);\n\n    return ctx;\n  };\n\n  const polygon = (...pts) => {\n    points.push(...pts);\n    return nil();\n  };\n\n  // Change dimensions\n  ctx.rect = rect;\n  ctx.moveTo = moveTo;\n  ctx.lineTo = moveTo;\n  ctx.circle = ellipse;\n  ctx.polygon = polygon;\n  ctx.ellipse = ellipse;\n  ctx.roundedRect = rect;\n\n  // To be implemented\n  ctx.text = nil;\n  ctx.path = nil;\n  ctx.lineWidth = nil;\n  ctx.bezierCurveTo = nil;\n  ctx.quadraticCurveTo = nil;\n\n  ctx.scale = nil;\n  ctx.rotate = nil;\n  ctx.translate = nil;\n\n  // These don't change dimensions\n  ctx.dash = nil;\n  ctx.clip = nil;\n  ctx.save = nil;\n  ctx.fill = nil;\n  ctx.font = nil;\n  ctx.stroke = nil;\n  ctx.lineCap = nil;\n  ctx.opacity = nil;\n  ctx.restore = nil;\n  ctx.lineJoin = nil;\n  ctx.fontSize = nil;\n  ctx.fillColor = nil;\n  ctx.miterLimit = nil;\n  ctx.strokeColor = nil;\n  ctx.fillOpacity = nil;\n  ctx.strokeOpacity = nil;\n  ctx.linearGradient = nil;\n  ctx.radialGradient = nil;\n\n  ctx.getWidth = () =>\n    R.compose(\n      getMax,\n      R.pluck(0),\n    )(points);\n\n  ctx.getHeight = () =>\n    R.compose(\n      getMax,\n      R.pluck(1),\n    )(points);\n\n  return ctx;\n};\n\n/**\n * Yoga canvas measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @param {Number} width\n * @param {Number} widthMode\n * @param {Number} height\n * @param {Number} heightMode\n * @returns {Object} canvas width and height\n */\nconst measureCanvas = (page, node) => {\n  const imageMargin = getMargin(node);\n  const pagePadding = getPadding(page);\n  const pageArea = isHeightAuto(page)\n    ? Infinity\n    : page.box.height -\n      pagePadding.paddingTop -\n      pagePadding.paddingBottom -\n      imageMargin.marginTop -\n      imageMargin.marginBottom -\n      SAFETY_HEIGHT;\n\n  const ctx = measureCtx();\n\n  node.props.paint(ctx);\n\n  const width = ctx.getWidth();\n  const height = Math.min(pageArea, ctx.getHeight());\n\n  return { height, width };\n};\n\nexport default R.curryN(6, measureCanvas);\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport getMargin from '../node/getMargin';\nimport getPadding from '../node/getPadding';\nimport getPosition from '../node/getPosition';\nimport getDimension from '../node/getDimension';\nimport getBorderWidth from '../node/getBorderWidth';\nimport setDisplay from '../node/setDisplay';\nimport setOverflow from '../node/setOverflow';\nimport setFlexWrap from '../node/setFlexWrap';\nimport setFlexGrow from '../node/setFlexGrow';\nimport setFlexBasis from '../node/setFlexBasis';\nimport setAlignSelf from '../node/setAlignSelf';\nimport setAlignItems from '../node/setAlignItems';\nimport setFlexShrink from '../node/setFlexShrink';\nimport setAspectRatio from '../node/setAspectRatio';\nimport setAlignContent from '../node/setAlignContent';\nimport setPositionType from '../node/setPositionType';\nimport setFlexDirection from '../node/setFlexDirection';\nimport setJustifyContent from '../node/setJustifyContent';\nimport {\n  setMarginTop,\n  setMarginRight,\n  setMarginBottom,\n  setMarginLeft,\n} from '../node/setMargin';\nimport {\n  setPaddingTop,\n  setPaddingRight,\n  setPaddingBottom,\n  setPaddingLeft,\n} from '../node/setPadding';\nimport {\n  setBorderTop,\n  setBorderRight,\n  setBorderBottom,\n  setBorderLeft,\n} from '../node/setBorderWidth';\nimport {\n  setPositionTop,\n  setPositionRight,\n  setPositionBottom,\n  setPositionLeft,\n} from '../node/setPosition';\nimport {\n  setWidth,\n  setHeight,\n  setMinWidth,\n  setMaxWidth,\n  setMinHeight,\n  setMaxHeight,\n} from '../node/setDimension';\nimport isSvg from '../node/isSvg';\nimport isText from '../node/isText';\nimport isNote from '../node/isNote';\nimport isPage from '../node/isPage';\nimport isImage from '../node/isImage';\nimport isCanvas from '../node/isCanvas';\nimport measureSvg from '../svg/measureSvg';\nimport measureText from '../text/measureText';\nimport measureImage from '../image/measureImage';\nimport measureCanvas from '../canvas/measureCanvas';\nimport isTextInstance from '../node/isTextInstance';\n\nconst YOGA_NODE = '_yogaNode';\nconst YOGA_CONFIG = Yoga.Config.create();\n\nYOGA_CONFIG.setPointScaleFactor(0);\n\nconst setNodeHeight = node =>\n  R.ifElse(\n    isPage,\n    setHeight(node.box.height),\n    setHeight(node.box.height || node.style.height),\n  );\n\n/**\n * Set styles valeus into yoga node before layout calculation\n *\n * @param {Object} node\n * @returns {Object} node\n */\nconst setYogaValues = R.tap(node => {\n  R.compose(\n    setNodeHeight(node),\n    setWidth(node.style.width),\n    setMinWidth(node.style.minWidth),\n    setMaxWidth(node.style.maxWidth),\n    setMinHeight(node.style.minHeight),\n    setMaxHeight(node.style.maxHeight),\n    setMarginTop(node.style.marginTop),\n    setMarginRight(node.style.marginRight),\n    setMarginBottom(node.style.marginBottom),\n    setMarginLeft(node.style.marginLeft),\n    setPaddingTop(node.style.paddingTop),\n    setPaddingRight(node.style.paddingRight),\n    setPaddingBottom(node.style.paddingBottom),\n    setPaddingLeft(node.style.paddingLeft),\n    setPositionType(node.style.position),\n    setPositionTop(node.style.top),\n    setPositionRight(node.style.right),\n    setPositionBottom(node.style.bottom),\n    setPositionLeft(node.style.left),\n    setBorderTop(node.style.borderTopWidth),\n    setBorderRight(node.style.borderRightWidth),\n    setBorderBottom(node.style.borderBottomWidth),\n    setBorderLeft(node.style.borderLeftWidth),\n    setDisplay(node.style.display),\n    setFlexDirection(node.style.flexDirection),\n    setAlignSelf(node.style.alignSelf),\n    setAlignContent(node.style.alignContent),\n    setAlignItems(node.style.alignItems),\n    setJustifyContent(node.style.justifyContent),\n    setFlexWrap(node.style.flexWrap),\n    setOverflow(node.style.overflow),\n    setAspectRatio(node.style.aspectRatio),\n    setFlexBasis(node.style.flexBasis),\n    setFlexGrow(node.style.flexGrow),\n    setFlexShrink(node.style.flexShrink),\n  )(node);\n});\n\n/**\n * Inserts child into parent' yoga node\n *\n * @param {Object} parent\n * @param {Object} node\n * @param {Object} node\n */\nconst insertYogaNodes = parent =>\n  R.tap(child => parent.insertChild(child[YOGA_NODE], parent.getChildCount()));\n\nconst setMeasureFunc = page => node => {\n  const yogaNode = node[YOGA_NODE];\n\n  if (isText(node)) {\n    yogaNode.setMeasureFunc(measureText(page, node));\n  }\n\n  if (isImage(node)) {\n    yogaNode.setMeasureFunc(measureImage(page, node));\n  }\n\n  if (isCanvas(node)) {\n    yogaNode.setMeasureFunc(measureCanvas(page, node));\n  }\n\n  if (isSvg(node)) {\n    yogaNode.setMeasureFunc(measureSvg(page, node));\n  }\n\n  return node;\n};\n\nconst isNotText = R.complement(isText);\nconst isNotNote = R.complement(isNote);\nconst isNotSvg = R.complement(isSvg);\nconst isNotTextInstance = R.complement(isTextInstance);\nconst isLayoutElement = R.allPass([isNotText, isNotNote, isNotSvg]);\n\n/**\n * Creates and add yoga node to document tree\n * Handles measure function for text and image nodes\n *\n * @param {Object} node\n * @returns {Object} node with appended yoga node\n */\nconst createYogaNodes = page => node => {\n  const yogaNode = Yoga.Node.createWithConfig(YOGA_CONFIG);\n\n  return R.compose(\n    setMeasureFunc(page),\n    R.when(\n      isLayoutElement,\n      R.evolve({\n        children: R.map(\n          R.compose(\n            insertYogaNodes(yogaNode),\n            createYogaNodes(page),\n          ),\n        ),\n      }),\n    ),\n    setYogaValues,\n    R.assoc(YOGA_NODE, yogaNode),\n  )(node);\n};\n\n/**\n * Performs yoga calculation\n *\n * @param {Object} node\n * @returns {Object} node\n */\nconst calculateLayout = R.tap(page => page[YOGA_NODE].calculateLayout());\n\n/**\n * Saves Yoga layout result into 'box' attribute of node\n *\n * @param {Object} node\n * @returns {Object} node with box data\n */\nconst persistDimensions = node => {\n  return R.evolve({\n    children: R.map(R.when(isNotTextInstance, persistDimensions)),\n    box: R.always(\n      R.mergeAll([\n        getPadding(node),\n        getMargin(node),\n        getBorderWidth(node),\n        getPosition(node),\n        getDimension(node),\n      ]),\n    ),\n  })(node);\n};\n\n/**\n * Removes and destroys yoga node frm document tree\n *\n * @param {Object} node\n * @returns {Object} node without yoga node\n */\nconst destroyYogaNodes = node => {\n  return R.compose(\n    R.dissoc(YOGA_NODE),\n    R.tap(n => Yoga.Node.destroy(n[YOGA_NODE])),\n    R.evolve({ children: R.map(R.when(isLayoutElement, destroyYogaNodes)) }),\n  )(node);\n};\n\n/**\n * Calculates page object layout using Yoga.\n * Takes node values from 'box' and 'style' attributes, and persist them back into 'box'\n * Destroy yoga values at the end.\n *\n * @param {Object} page object\n * @returns {Object} page object with correct 'box' layout attributes\n */\nexport const resolvePageDimensions = page =>\n  R.ifElse(\n    R.isNil,\n    R.always(null),\n    R.compose(\n      destroyYogaNodes,\n      persistDimensions,\n      calculateLayout,\n      createYogaNodes(page),\n    ),\n  )(page);\n\n/**\n * Calculates root object layout using Yoga.\n *\n * @param {Object} root object\n * @returns {Object} root object with correct 'box' layout attributes\n */\nconst resolveDimensions = node =>\n  R.evolve({\n    children: R.map(resolvePageDimensions),\n  })(node);\n\nexport default resolveDimensions;\n","import * as R from 'ramda';\n\nimport isText from '../node/isText';\nimport splitText from '../text/splitText';\nimport splitNode from '../node/splitNode';\nimport createInstance from '../node/createInstance';\nimport shouldNodeBreak from '../node/shouldBreak';\nimport getContentArea from '../page/getContentArea';\nimport resolveTextLayout from './resolveTextLayout';\nimport resolveInheritance from './resolveInheritance';\nimport { resolvePageDimensions } from './resolveDimensions';\n\n// Prevent splitting elements by low decimal numbers\nconst SAFTY_THRESHOLD = 0.001;\n\nconst assingChildren = R.assoc('children');\n\nconst getTop = R.pathOr(0, ['box', 'top']);\n\nconst getHeight = R.path(['box', 'height']);\n\nconst getChildren = R.propOr([], 'children');\n\nconst isElementOutside = R.useWith(R.lte, [R.identity, getTop]);\n\nconst isFixed = R.pathEq(['props', 'fixed'], true);\n\nconst allFixed = R.all(isFixed);\n\nconst isDynamic = R.hasPath(['props', 'render']);\n\nconst relayoutPage = R.compose(\n  resolveTextLayout,\n  resolveInheritance,\n  resolvePageDimensions,\n);\n\nconst splitView = (node, height) => {\n  const [currentNode, nextNode] = splitNode(node, height);\n  const [currentChilds, nextChildren] = splitChildren(height, node);\n\n  return [\n    assingChildren(currentChilds)(currentNode),\n    assingChildren(nextChildren)(nextNode),\n  ];\n};\n\nconst split = R.ifElse(isText, splitText, splitView);\n\nconst splitNodes = (height, nodes) => {\n  const currentChildren = [];\n  const nextChildren = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const child = nodes[i];\n    const futureNodes = nodes.slice(i + 1);\n    const futureFixedNodes = R.filter(isFixed, futureNodes);\n\n    const nodeTop = getTop(child);\n    const nodeHeight = getHeight(child);\n    const isOutside = isElementOutside(height, child);\n    const shouldBreak = shouldNodeBreak(child, futureNodes, height);\n    const shouldSplit = height + SAFTY_THRESHOLD < nodeTop + nodeHeight;\n\n    if (isFixed(child)) {\n      nextChildren.push(child);\n      currentChildren.push(child);\n      continue;\n    }\n\n    if (isOutside) {\n      const next = R.evolve({ box: { top: R.subtract(R.__, height) } })(child);\n      nextChildren.push(next);\n      continue;\n    }\n\n    if (shouldBreak) {\n      const next = R.evolve({\n        box: { top: R.subtract(R.__, height) },\n        props: R.evolve({ break: R.always(false) }),\n      })(child);\n\n      currentChildren.push(...futureFixedNodes);\n      nextChildren.push(next, ...futureNodes);\n      break;\n    }\n\n    if (shouldSplit) {\n      const [currentChild, nextChild] = split(child, height);\n\n      if (currentChild) currentChildren.push(currentChild);\n      if (nextChild) nextChildren.push(nextChild);\n\n      continue;\n    }\n\n    currentChildren.push(child);\n  }\n\n  return [currentChildren, nextChildren];\n};\n\nconst splitChildren = (height, node) => {\n  const children = getChildren(node);\n  const availableHeight = height - getTop(node);\n  return splitNodes(availableHeight, children);\n};\n\nconst splitPage = (page, pageNumber) => {\n  const contentArea = getContentArea(page);\n  const height = R.path(['style', 'height'], page);\n  const dynamicPage = resolveDynamicPage({ pageNumber }, page);\n\n  const [currentChilds, nextChilds] = splitNodes(\n    contentArea,\n    dynamicPage.children,\n  );\n\n  const currentPage = R.compose(\n    relayoutPage,\n    assingChildren(currentChilds),\n    R.assocPath(['box', 'height'], height),\n  )(page);\n\n  if (R.isEmpty(nextChilds) || allFixed(nextChilds)) return [currentPage, null];\n\n  const nextPage = R.compose(\n    relayoutPage,\n    assingChildren(nextChilds),\n    R.dissocPath(['box', 'height']),\n  )(page);\n\n  return [currentPage, nextPage];\n};\n\nconst shouldResolveDynamicNodes = node =>\n  R.either(\n    isDynamic,\n    R.compose(\n      R.any(shouldResolveDynamicNodes),\n      R.propOr([], 'children'),\n    ),\n  )(node);\n\nconst resolveDynamicPage = (props, page) =>\n  R.when(\n    shouldResolveDynamicNodes,\n    R.compose(\n      relayoutPage,\n      resolveDynamicNodes(props),\n    ),\n  )(page);\n\nconst resolveDynamicNodes = props => node => {\n  const isNodeDynamic = R.always(isDynamic(node));\n\n  const resolveRender = () => {\n    const res = node.props.render(props);\n    return [createInstance(res)];\n  };\n\n  return R.evolve(\n    {\n      children: R.ifElse(\n        isNodeDynamic,\n        resolveRender,\n        R.map(resolveDynamicNodes(props)),\n      ),\n      lines: R.when(isNodeDynamic, R.always([])),\n    },\n    node,\n  );\n};\n\nconst paginate = (page, pageNumber) => {\n  if (!page) return [];\n\n  let splittedPage = splitPage(page, pageNumber);\n\n  const pages = [splittedPage[0]];\n  let nextPage = splittedPage[1];\n\n  while (nextPage !== null) {\n    splittedPage = splitPage(nextPage, pageNumber + pages.length);\n\n    pages.push(splittedPage[0]);\n    nextPage = splittedPage[1];\n  }\n\n  return pages;\n};\n\nconst resolvePageIndices = (page, pageNumber, pages) => {\n  const totalPages = pages.length;\n  return resolveDynamicPage({ pageNumber: pageNumber + 1, totalPages }, page);\n};\n\nconst resolvePagination = doc => {\n  let pages = [];\n  let pageNumber = 1;\n\n  for (let i = 0; i < doc.children.length; i++) {\n    const page = doc.children[i];\n    const subpages = paginate(page, pageNumber);\n\n    pageNumber += subpages.length;\n    pages = pages.concat(subpages);\n  }\n\n  pages = pages.map(resolvePageIndices);\n\n  return assingChildren(pages, doc);\n};\n\nexport default resolvePagination;\n","import * as R from 'ramda';\n\n/**\n * Removes margins on node\n *\n * @param {Object} node\n * @returns {Object} node without margins\n */\nconst removeMargins = R.compose(\n  R.dissocPath(['style', 'margin']),\n  R.dissocPath(['style', 'marginTop']),\n  R.dissocPath(['style', 'marginRight']),\n  R.dissocPath(['style', 'marginBottom']),\n  R.dissocPath(['style', 'marginLeft']),\n  R.dissocPath(['style', 'marginHorizontal']),\n  R.dissocPath(['style', 'marginVertical']),\n);\n\nexport default removeMargins;\n","import * as R from 'ramda';\n\nimport removeMargins from '../node/removeMargins';\n\n/**\n * Remove page margins\n *\n * @param {Object} document root\n * @returns {Object} document root without margins on pages\n */\nconst resolvePageMargins = R.evolve({\n  children: R.map(removeMargins),\n});\n\nexport default resolvePageMargins;\n","import * as R from 'ramda';\n\nimport isNote from '../node/isNote';\nimport isTextInstance from '../node/isTextInstance';\n\n/**\n * Get node underlying text value\n *\n * @param {Object} node\n * @returns {String} node text content\n */\nconst getNodeText = node =>\n  R.cond([\n    [R.is(String), R.identity],\n    [isTextInstance, R.prop('value')],\n    [\n      R.T,\n      R.compose(\n        getNodesText,\n        R.propOr([], 'children'),\n      ),\n    ],\n  ])(node);\n\n/**\n * Get underlying text value of several nodes\n *\n * @param {Array} nodes\n * @returns {String} nodes text content\n */\nconst getNodesText = R.compose(\n  R.join(''),\n  R.map(getNodeText),\n);\n\n/**\n * Transforms string to text instance\n *\n * @param {String} value\n * @returns {Array} text intance\n */\nconst wrapTextInstance = value => [{ type: 'TEXT_INSTANCE', value }];\n\n/**\n * Cast Note children as a text instance\n *\n * @param {Object} node\n * @returns {Object} node with resolved note children\n */\nconst resolveNoteChildren = node =>\n  R.ifElse(\n    isNote,\n    R.evolve({\n      children: R.compose(\n        wrapTextInstance,\n        getNodesText,\n      ),\n    }),\n    R.evolve({ children: R.map(resolveNoteChildren) }),\n  )(node);\n\nexport default resolveNoteChildren;\n","import * as R from 'ramda';\n\nimport matchPercent from '../utils/matchPercent';\n\n/*\n * Translates page percentage horizontal paddings in fixed ones\n *\n * @param {Object} page container\n * @param {String} padding value\n * @returns {Object} translated padding value\n */\nconst resolvePageHorizontalPadding = container => value => {\n  const match = matchPercent(value);\n  return match ? match.percent * container.width : value;\n};\n\n/**\n * Translates page percentage vertical paddings in fixed ones\n *\n * @param {Object} page container\n * @param {String} padding value\n * @returns {Object} translated padding value\n */\nconst resolvePageVerticalPadding = container => value => {\n  const match = matchPercent(value);\n  return match ? match.percent * container.height : value;\n};\n\n/**\n * Translates page percentage paddings in fixed ones\n *\n * @param {Object} page\n * @returns {Object} page with fixed paddings\n */\nconst resolvePagePaddings = page => {\n  const container = R.pathOr({}, ['props', 'size'], page);\n\n  return R.evolve({\n    style: R.evolve({\n      paddingLeft: resolvePageHorizontalPadding(container),\n      paddingRight: resolvePageHorizontalPadding(container),\n      paddingTop: resolvePageVerticalPadding(container),\n      paddingBottom: resolvePageVerticalPadding(container),\n    }),\n  })(page);\n};\n\n/**\n * Translates all pages percentage paddings in fixed ones\n * This has to be computed from pages calculated size and not by Yoga\n * because at this point we didn't performed pagination yet.\n *\n * @param {Object} document root\n * @returns {Object} document root with translated page paddings\n */\nexport default R.evolve({\n  children: R.map(resolvePagePaddings),\n});\n","import * as R from 'ramda';\n\nimport matchPercent from '../utils/matchPercent';\n\n/**\n *\n * @param {Object} container width and height\n * @param {String | Number} value border radius value\n * @returns {Number} fixed border radius value\n */\nconst resolveRadius = container => value => {\n  const match = matchPercent(value);\n  return match\n    ? match.percent * Math.min(container.width, container.height)\n    : value;\n};\n\n/**\n * Transforms percent border radius into fixed values\n *\n * @param {Object} node\n * @returns {Object} node\n */\nconst resolvePercentRadius = node =>\n  R.evolve({\n    children: R.map(resolvePercentRadius),\n    style: R.evolve({\n      borderTopLeftRadius: resolveRadius(node.box),\n      borderTopRightRadius: resolveRadius(node.box),\n      borderBottomRightRadius: resolveRadius(node.box),\n      borderBottomLeftRadius: resolveRadius(node.box),\n    }),\n  })(node);\n\nexport default resolvePercentRadius;\n","import * as R from 'ramda';\n\nimport matchPercent from '../utils/matchPercent';\n\n/**\n * Transform percent height into fixed\n *\n * @param {String | number} height\n * @return {number} height\n */\nconst transformHeight = pageArea => height => {\n  const match = matchPercent(height);\n  return match ? match.percent * pageArea : height;\n};\n\n/**\n * Get page area (height minus paddings)\n *\n * @param {Object} page\n * @return {number} page area\n */\nconst getPageArea = page => {\n  const pageHeight = R.path(['style', 'height'], page);\n  const pagePaddingTop = R.pathOr(0, ['style', 'paddingTop'], page);\n  const pagePaddingBottom = R.pathOr(0, ['style', 'paddingBottom'], page);\n  return pageHeight - pagePaddingTop - pagePaddingBottom;\n};\n\n/**\n * Checks if page has height\n *\n * @param {Object} page\n * @return {boolean} page has height\n */\nconst hasHeight = R.hasPath(['style', 'height']);\n\n/**\n * Transform node percent height to fixed\n *\n * @param {Object} page\n * @param {Object} node\n * @return {Object} transformed node\n */\nconst resolveNodePercentHeight = page => node => {\n  if (hasHeight(page)) {\n    const pageArea = getPageArea(page);\n    return R.evolve({ style: { height: transformHeight(pageArea) } })(node);\n  }\n\n  return node;\n};\n\n/**\n * Transform page immediate children with percent height to fixed\n *\n * @param {Object} page\n * @return {Object} transformed page\n */\nconst resolvePagePercentHeight = page =>\n  R.evolve({\n    children: R.map(resolveNodePercentHeight(page)),\n  })(page);\n\n/**\n * Transform all page immediate children with percent height to fixed\n *\n * @param {Object} document root\n * @return {Object} transformed document root\n */\nconst resolvePercentHeight = R.evolve({\n  children: R.map(resolvePagePercentHeight),\n});\n\nexport default resolvePercentHeight;\n","import * as R from 'ramda';\n\nimport { TEXT } from '../constants';\nimport isLink from '../node/isLink';\nimport isTextInstance from '../node/isTextInstance';\n\n/**\n * Checks if node has render prop\n *\n * @param {Object} node\n * @returns {Boolean} has render prop?\n */\nconst hasRenderProp = R.hasPath(['props', 'render']);\n\n/**\n * Checks if all children of node are text instances\n *\n * @param {Object} node\n * @returns {Boolean} are all children text instances?\n */\nconst hasTextInstanceChilds = R.compose(\n  R.all(isTextInstance),\n  R.propOr([], 'children'),\n);\n\n/**\n * If the Link has a string child or render prop, substitute the instance by a Text,\n * that will ultimately render the inline Link via the textkit PDF renderer.\n *\n * @param {Object} node\n * @returns {Object} node with link substitution\n */\nconst resolveLinkSubstitution = node =>\n  R.evolve({\n    children: R.map(\n      R.ifElse(\n        R.both(isLink, R.either(hasRenderProp, hasTextInstanceChilds)),\n        R.assoc('type', TEXT),\n        resolveLinkSubstitution,\n      ),\n    ),\n  })(node);\n\nexport default resolveLinkSubstitution;\n","import * as R from 'ramda';\n\n/**\n * Performs right-to-left function composition with async functions support\n *\n * @param  {...any} functions\n */\nconst asyncCompose = (...fns) => async value => {\n  for (const fn of R.reverse(fns)) value = await fn(value);\n  return value;\n};\n\nexport default asyncCompose;\n","// import * as R from 'ramda';\n\nimport resolveSvg from './resolveSvg';\nimport resolveZIndex from './resolveZIndex';\nimport resolveRulers from './resolveRulers';\nimport resolveAssets from './resolveAssets';\nimport resolveStyles from './resolveStyles';\nimport resolveOrigins from './resolveOrigins';\nimport resolvePageSizes from './resolvePageSizes';\nimport resolvePagination from './resolvePagination';\nimport resolveDimensions from './resolveDimensions';\nimport resolveTextLayout from './resolveTextLayout';\nimport resolveInheritance from './resolveInheritance';\nimport resolvePageMargins from './resolvePageMargins';\nimport resolveNoteChildren from './resolveNoteChildren';\nimport resolvePagePaddings from './resolvePagePaddings';\nimport resolvePercentRadius from './resolvePercentRadius';\nimport resolvePercentHeight from './resolvePercentHeight';\nimport resolveLinkSubstitution from './resolveLinkSubstitution';\nimport asyncCompose from '../utils/asyncCompose';\n\n// const startTimer = name => R.tap(() => console.time(name));\n// const endTimer = name => R.tap(() => console.timeEnd(name));\n\nconst layout = asyncCompose(\n  resolveZIndex,\n  resolveRulers,\n  resolveOrigins,\n  resolvePagination,\n  resolveTextLayout,\n  resolvePercentRadius,\n  resolveDimensions,\n  resolveSvg,\n  resolveAssets,\n  resolveInheritance,\n  resolvePercentHeight,\n  resolvePagePaddings,\n  resolveStyles,\n  resolveNoteChildren,\n  resolveLinkSubstitution,\n  resolvePageMargins,\n  resolvePageSizes,\n);\n\nexport default layout;\n","/**\n * Checks if two sets of props are equal (recursively)\n *\n * @param {Object} props A\n * @param {Object} props B\n * @returns {Boolean} props equals?\n *\n */\nconst propsEqual = (a, b) => {\n  const oldPropsKeys = Object.keys(a);\n  const newPropsKeys = Object.keys(b);\n\n  if (oldPropsKeys.length !== newPropsKeys.length) {\n    return false;\n  }\n\n  for (let i = 0; i < oldPropsKeys.length; i++) {\n    const propName = oldPropsKeys[i];\n\n    if (propName === 'render') {\n      if (!a[propName] !== !b[propName]) {\n        return false;\n      }\n      continue;\n    }\n\n    if (propName !== 'children' && a[propName] !== b[propName]) {\n      if (\n        typeof a[propName] === 'object' &&\n        typeof b[propName] === 'object' &&\n        propsEqual(a[propName], b[propName])\n      ) {\n        continue;\n      }\n\n      return false;\n    }\n\n    if (\n      propName === 'children' &&\n      (typeof a[propName] === 'string' || typeof b[propName] === 'string')\n    ) {\n      return a[propName] === b[propName];\n    }\n  }\n\n  return true;\n};\n\nexport default propsEqual;\n","'use strict';\n\nimport ReactFiberReconciler from 'react-reconciler';\nimport {\n  unstable_scheduleCallback as schedulePassiveEffects,\n  unstable_cancelCallback as cancelPassiveEffects,\n} from 'scheduler';\n\nimport propsEqual from './utils/propsEqual';\n\nconst emptyObject = {};\n\nconst createRenderer = ({ onChange = () => {} }) => {\n  return ReactFiberReconciler({\n    schedulePassiveEffects,\n\n    cancelPassiveEffects,\n\n    supportsMutation: true,\n\n    isPrimaryRenderer: false,\n\n    warnsIfNotActing: false,\n\n    appendInitialChild(parentInstance, child) {\n      parentInstance.children.push(child);\n    },\n\n    createInstance(type, { style, children, ...props }) {\n      return {\n        type,\n        box: {},\n        style: style || {},\n        props: props || {},\n        children: [],\n      };\n    },\n\n    createTextInstance(text, rootContainerInstance) {\n      return { type: 'TEXT_INSTANCE', value: text };\n    },\n\n    finalizeInitialChildren(element, type, props) {\n      return false;\n    },\n\n    getPublicInstance(instance) {\n      return instance;\n    },\n\n    prepareForCommit() {\n      // Noop\n    },\n\n    prepareUpdate(element, type, oldProps, newProps) {\n      return !propsEqual(oldProps, newProps);\n    },\n\n    resetAfterCommit: onChange,\n\n    resetTextContent(element) {\n      // Noop\n    },\n\n    getRootHostContext() {\n      return emptyObject;\n    },\n\n    getChildHostContext() {\n      return emptyObject;\n    },\n\n    shouldSetTextContent(type, props) {\n      return false;\n    },\n\n    now: Date.now,\n\n    useSyncScheduling: true,\n\n    appendChild(parentInstance, child) {\n      parentInstance.children.push(child);\n    },\n\n    appendChildToContainer(parentInstance, child) {\n      if (parentInstance.type === 'ROOT') {\n        parentInstance.document = child;\n      } else {\n        parentInstance.children.push(child);\n      }\n    },\n\n    insertBefore(parentInstance, child, beforeChild) {\n      const index = parentInstance.children.indexOf(beforeChild);\n      if (index !== -1 && child)\n        parentInstance.children.splice(index, 0, child);\n    },\n\n    removeChild(parentInstance, child) {\n      const index = parentInstance.children.indexOf(child);\n      if (index !== -1) parentInstance.children.splice(index, 1);\n    },\n\n    removeChildFromContainer(parentInstance, child) {\n      const index = parentInstance.children.indexOf(child);\n      if (index !== -1) parentInstance.children.splice(index, 1);\n    },\n\n    commitTextUpdate(textInstance, oldText, newText) {\n      textInstance.value = newText;\n    },\n\n    commitUpdate(instance, updatePayload, type, oldProps, newProps) {\n      const { style, ...props } = newProps;\n      instance.props = props;\n      instance.style = style;\n    },\n  });\n};\n\nexport default createRenderer;\n","import flatten from './flatten';\n\nconst create = styles => styles;\n\nconst absoluteFillObject = {\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  bottom: 0,\n  right: 0,\n};\n\nexport default {\n  hairlineWidth: 1,\n  create,\n  flatten,\n  absoluteFillObject,\n};\n","import BlobStream from 'blob-stream';\nimport PDFDocument from '@react-pdf/pdfkit';\n\nimport Font from './font';\nimport renderPDF from './render';\nimport layoutDocument from './layout';\nimport createRenderer from './renderer';\nimport StyleSheet from './stylesheet';\nimport { version } from '../package.json';\nimport {\n  VIEW,\n  TEXT,\n  LINK,\n  PAGE,\n  NOTE,\n  IMAGE,\n  DOCUMENT,\n  CANVAS,\n  SVG,\n  GROUP,\n  PATH,\n  RECT,\n  LINE,\n  CIRCLE,\n  ELLIPSE,\n  POLYGON,\n  POLYLINE,\n  DEFS,\n  TSPAN,\n  CLIP_PATH,\n  STOP,\n  LINEAR_GRADIENT,\n  RADIAL_GRADIENT,\n} from './constants';\n\nconst View = VIEW;\nconst Text = TEXT;\nconst Link = LINK;\nconst Page = PAGE;\nconst Note = NOTE;\nconst Image = IMAGE;\nconst Document = DOCUMENT;\nconst Canvas = CANVAS;\nconst Svg = SVG;\nconst G = GROUP;\nconst Path = PATH;\nconst Rect = RECT;\nconst Line = LINE;\nconst Circle = CIRCLE;\nconst Ellipse = ELLIPSE;\nconst Polygon = POLYGON;\nconst Polyline = POLYLINE;\nconst Defs = DEFS;\nconst Tspan = TSPAN;\nconst ClipPath = CLIP_PATH;\nconst Stop = STOP;\nconst LinearGradient = LINEAR_GRADIENT;\nconst RadialGradient = RADIAL_GRADIENT;\n\nconst pdf = ({ initialValue, onChange }) => {\n  const container = { type: 'ROOT', document: null };\n  const PDFRenderer = createRenderer({ onChange });\n  const mountNode = PDFRenderer.createContainer(container);\n\n  if (initialValue) updateContainer(initialValue);\n\n  const render = async () => {\n    const ctx = new PDFDocument({ autoFirstPage: false });\n\n    console.time('layout');\n    const layout = await layoutDocument(container.document);\n    console.timeEnd('layout');\n\n    return renderPDF(ctx, layout);\n  };\n\n  const layout = async () => {\n    return layoutDocument(container);\n  };\n\n  function updateContainer(doc) {\n    PDFRenderer.updateContainer(doc, mountNode, null);\n  }\n\n  function callOnRender(params = {}) {\n    if (container.document.props.onRender) {\n      container.document.props.onRender(params);\n    }\n  }\n\n  async function toBlob() {\n    const instance = await render();\n    const stream = instance.pipe(BlobStream());\n\n    return new Promise((resolve, reject) => {\n      stream.on('finish', () => {\n        try {\n          const blob = stream.toBlob('application/pdf');\n          callOnRender({ blob });\n          resolve(blob);\n        } catch (error) {\n          reject(error);\n        }\n      });\n\n      stream.on('error', reject);\n    });\n  }\n\n  async function toBuffer() {\n    callOnRender();\n    return render();\n  }\n\n  function toString() {\n    let result = '';\n    const instance = render();\n\n    return new Promise((resolve, reject) => {\n      try {\n        instance.on('data', function(buffer) {\n          result += buffer;\n        });\n\n        instance.on('end', function() {\n          resolve(result);\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  return {\n    layout,\n    container,\n    updateContainer,\n    toBuffer,\n    toBlob,\n    toString,\n  };\n};\n\nexport {\n  version,\n  View,\n  Text,\n  Link,\n  Page,\n  Font,\n  Note,\n  Image,\n  Document,\n  Canvas,\n  Svg,\n  G,\n  Path,\n  Rect,\n  Line,\n  Circle,\n  Ellipse,\n  Polygon,\n  Defs,\n  Tspan,\n  ClipPath,\n  Polyline,\n  Stop,\n  LinearGradient,\n  RadialGradient,\n  StyleSheet,\n  pdf,\n};\n","import React from 'react';\n\nconst svgpath = require('svgpath');\n\nimport { pdf } from './index';\n\nconst queue = require('queue');\n\nconst canvasInstance = canvas => {\n  const instance = {};\n  const images = {};\n  const ctx = canvas.getContext('2d');\n\n  let fillColor = 'white';\n\n  const nil = () => {\n    return instance;\n  };\n\n  instance.info = {};\n  instance.end = nil;\n  instance.font = nil;\n\n  instance.translate = (x, y) => {\n    ctx.translate(x, y);\n    return instance;\n  };\n\n  instance.addPage = ({ size }) => {\n    canvas.width = size[0];\n    canvas.height = size[1];\n\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n  };\n\n  instance.save = () => {\n    ctx.save();\n    return instance;\n  };\n\n  instance.restore = () => {\n    ctx.restore();\n    return instance;\n  };\n\n  instance.moveTo = (x, y) => {\n    ctx.moveTo(x, y);\n    return instance;\n  };\n\n  instance.lineTo = (x, y) => {\n    ctx.lineTo(x, y);\n    return instance;\n  };\n\n  instance.bezierCurveTo = (a, b, c, d, e, f) => {\n    ctx.bezierCurveTo(a, b, c, d, e, f);\n    return instance;\n  };\n\n  instance.closePath = () => {\n    ctx.closePath();\n    return instance;\n  };\n\n  instance.clip = () => {\n    ctx.clip();\n    return instance;\n  };\n\n  instance.fillColor = color => {\n    fillColor = color;\n    return instance;\n  };\n\n  instance.rect = (a, b, c, d) => {\n    ctx.rect(a, b, c, d);\n    return instance;\n  };\n\n  instance.fill = () => {\n    ctx.fillStyle = fillColor;\n    ctx.fill();\n    return instance;\n  };\n\n  instance.fillOpacity = opacity => {\n    ctx.globalAlpha = opacity;\n    return instance;\n  };\n\n  instance._addGlyphs = (glyphs, positions) => {\n    let xAdvance = 0;\n    const fontSize = 20;\n    const unitsPerEm = 2048;\n\n    for (let i = 0; i < glyphs.length; i++) {\n      const glyph = glyphs[i];\n      const position = positions[i];\n\n      const path = svgpath(glyph.path.toSVG())\n        .scale(1, -1)\n        .scale(fontSize / unitsPerEm)\n        .translate(xAdvance, 0)\n        .toString();\n\n      xAdvance += position.xAdvance;\n\n      ctx.fillStyle = '#000';\n\n      const p = new Path2D(path);\n\n      ctx.stroke(p);\n      ctx.fill(p);\n    }\n\n    return instance;\n  };\n\n  instance.image = (data, x, y, { width, height }) => {\n    const base64Data = btoa(String.fromCharCode.apply(null, data));\n\n    if (images[base64Data]) {\n      ctx.drawImage(images[base64Data], x, y, width, height);\n    } else {\n      const img = document.createElement('img');\n      img.src = 'data:image/png;base64,' + base64Data;\n\n      images[base64Data] = img;\n\n      img.onload = () => {\n        ctx.drawImage(img, x, y, width, height);\n      };\n    }\n\n    return instance;\n  };\n\n  instance.clear = () => {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n  };\n\n  return instance;\n};\n\nexport class CanvasViewer extends React.Component {\n  ctx = null;\n  instance = pdf();\n  renderQueue = queue({ autostart: true, concurrency: 1 });\n  state = { layout: null, error: null };\n\n  componentDidMount() {\n    this.ctx = canvasInstance(this.canvas);\n    this.queueDocumentRender(this.props.children);\n\n    this.renderQueue.on('error', this.onRenderFailed);\n    this.renderQueue.on('success', this.onRenderSuccessful);\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.children !== this.props.children) {\n      this.queueDocumentRender(this.props.children);\n    }\n  }\n\n  componentWillUnmount() {\n    this.renderQueue.end();\n  }\n\n  queueDocumentRender(doc) {\n    this.renderQueue.splice(0, this.renderQueue.length, () => {\n      this.instance.updateContainer(doc);\n\n      if (this.instance.isDirty() && !this.state.error) {\n        return this.instance.renderWithContext(this.ctx);\n      }\n\n      return Promise.resolve();\n    });\n  }\n\n  onRenderFailed = error => {\n    this.setState({ error });\n    console.error(error);\n  };\n\n  onRenderSuccessful = layout => {\n    this.setState({ layout });\n  };\n\n  render() {\n    return (\n      <canvas\n        height={900}\n        id=\"myCanvas\"\n        ref={ref => (this.canvas = ref)}\n        style={{ border: '1px solid black' }}\n        width={900}\n      />\n    );\n  }\n}\n","/* eslint-disable no-unused-vars */\nimport React from 'react';\nimport { CanvasViewer } from './canvas';\n\nimport warning from '../src/utils/warning';\n\nconst queue = require('queue');\n\nimport {\n  pdf,\n  View,\n  Text,\n  Link,\n  Page,\n  Font,\n  Note,\n  Image,\n  Canvas,\n  Svg,\n  G,\n  Path,\n  Rect,\n  Line,\n  Circle,\n  Ellipse,\n  Polygon,\n  Polyline,\n  Defs,\n  Tspan,\n  ClipPath,\n  Stop,\n  LinearGradient,\n  RadialGradient,\n  version,\n  StyleSheet,\n  // createInstance,\n  Document as PDFDocument,\n} from './index';\n\nconst flatStyles = stylesArray =>\n  stylesArray.reduce((acc, style) => ({ ...acc, ...style }), {});\n\nexport const Document = ({ children, ...props }) => {\n  return <PDFDocument {...props}>{children}</PDFDocument>;\n};\n\nclass InternalBlobProvider extends React.PureComponent {\n  renderQueue = queue({ autostart: true, concurrency: 1 });\n  state = { blob: null, url: null, loading: true, error: null };\n\n  componentDidMount() {\n    this.instance = pdf({ onChange: this.queueDocumentRender });\n    this.instance.updateContainer(this.props.document);\n\n    this.renderQueue.on('error', this.onRenderFailed);\n    this.renderQueue.on('success', this.onRenderSuccessful);\n  }\n\n  componentDidUpdate() {\n    this.instance.updateContainer(this.props.document);\n  }\n\n  componentWillUnmount() {\n    this.renderQueue.end();\n  }\n\n  queueDocumentRender = () => {\n    this.renderQueue.splice(0, this.renderQueue.length, () =>\n      this.state.error ? Promise.resolve() : this.instance.toBlob(),\n    );\n  };\n\n  onRenderFailed = error => {\n    this.setState({ error });\n    console.error(error);\n  };\n\n  onRenderSuccessful = blob => {\n    const oldBlobUrl = this.state.url;\n\n    this.setState(\n      { blob, url: URL.createObjectURL(blob), loading: false },\n      () => URL.revokeObjectURL(oldBlobUrl),\n    );\n  };\n\n  render() {\n    return this.props.children(this.state);\n  }\n}\n\nexport const BlobProvider = ({ document: doc, children }) => {\n  if (!doc) {\n    warning(false, 'You should pass a valid document to BlobProvider');\n    return null;\n  }\n\n  return <InternalBlobProvider document={doc}>{children}</InternalBlobProvider>;\n};\n\nexport const PDFViewer = ({\n  className,\n  style,\n  children,\n  innerRef,\n  ...props\n}) => {\n  return (\n    <InternalBlobProvider document={children}>\n      {({ url }) => (\n        <iframe\n          className={className}\n          ref={innerRef}\n          src={url}\n          style={Array.isArray(style) ? flatStyles(style) : style}\n          {...props}\n        />\n      )}\n    </InternalBlobProvider>\n  );\n};\n\nexport const PDFDownloadLink = ({\n  document: doc,\n  className,\n  style,\n  children,\n  fileName = 'document.pdf',\n}) => {\n  if (!doc) {\n    warning(false, 'You should pass a valid document to PDFDownloadLink');\n    return null;\n  }\n\n  const downloadOnIE = blob => () => {\n    if (window.navigator.msSaveBlob) {\n      window.navigator.msSaveBlob(blob, fileName);\n    }\n  };\n\n  return (\n    <InternalBlobProvider document={doc}>\n      {params => (\n        <a\n          className={className}\n          download={fileName}\n          href={params.url}\n          onClick={downloadOnIE(params.blob)}\n          style={Array.isArray(style) ? flatStyles(style) : style}\n        >\n          {typeof children === 'function' ? children(params) : children}\n        </a>\n      )}\n    </InternalBlobProvider>\n  );\n};\n\nexport {\n  pdf,\n  View,\n  Text,\n  Link,\n  Page,\n  Font,\n  Note,\n  Image,\n  Canvas,\n  Svg,\n  G,\n  Path,\n  Rect,\n  Line,\n  Circle,\n  Ellipse,\n  Polygon,\n  Polyline,\n  Defs,\n  Tspan,\n  ClipPath,\n  Stop,\n  LinearGradient,\n  RadialGradient,\n  version,\n  StyleSheet,\n} from './index';\n\nexport { CanvasViewer } from './canvas';\n\nexport default {\n  pdf,\n  View,\n  Text,\n  Link,\n  Page,\n  Font,\n  Note,\n  Image,\n  Canvas,\n  Svg,\n  G,\n  Path,\n  Rect,\n  Line,\n  Circle,\n  Ellipse,\n  Polygon,\n  Polyline,\n  Defs,\n  Tspan,\n  ClipPath,\n  Stop,\n  LinearGradient,\n  RadialGradient,\n  version,\n  Document,\n  PDFViewer,\n  StyleSheet,\n  CanvasViewer,\n  BlobProvider,\n  PDFDownloadLink,\n};\n"],"names":["emojiSource","hyphenationCallback","VIEW","TEXT","LINK","PAGE","NOTE","IMAGE","DOCUMENT","CANVAS","TEXT_INSTANCE","SVG","GROUP","PATH","RECT","LINE","CIRCLE","ELLIPSE","POLYGON","POLYLINE","DEFS","TSPAN","CLIP_PATH","STOP","LINEAR_GRADIENT","RADIAL_GRADIENT","DPI","FONT_WEIGHTS","thin","hairline","ultralight","extralight","light","normal","medium","semibold","demibold","bold","ultrabold","extrabold","heavy","black","PAGE_SIZES","A0","A1","A2","A3","A4","A5","A6","A7","A8","A9","A10","B0","B1","B2","B3","B4","B5","B6","B7","B8","B9","B10","C0","C1","C2","C3","C4","C5","C6","C7","C8","C9","C10","RA0","RA1","RA2","RA3","RA4","SRA0","SRA1","SRA2","SRA3","SRA4","EXECUTIVE","FOLIO","LEGAL","LETTER","TABLOID","PORTRAIT","LANDSCAPE","INHERITED_PROPERTIES","SVG_INHERITED_PROPS","RULER_WIDTH","RULER_COLOR","RULER_FONT_SIZE","DEFAULT_RULER_STEPS","LINE_WIDTH","LINE_COLOR","GRID_COLOR","BOX_MODEL_REGEX","OBJECT_POSITION_REGEX","BORDER_SHORTHAND_REGEX","TRANSFORM_ORIGIN_REGEX","matchBoxModel","R","matchObjectPosition","matchBorderShorthand","matchTransformOrigin","isNumber","Number","isFontWeightStyle","key","match","isBorderStyle","value","isBoxModelStyle","isObjectPositionStyle","isTransformOriginStyle","isFlexGrow","isFlexShrink","isFlexBasis","processBorders","Error","processBoxModel","processFontWeight","toLowerCase","processObjectPosition","transformOffsetKeywords","processTransformOrigin","result","processFlexGrow","split","processFlexShrink","processFlexBasis","keepSame","matchNumber","String","castFloat","v","parseFloat","transformStyle","transformStyles","fetchFont","src","options","fetch","response","buffer","arrayBuffer","constructor","name","Buffer","from","FontSource","fontFamily","fontStyle","fontWeight","data","loading","load","this","headers","body","method","fontkit","create","Promise","resolve","reject","open","_this","err","Font","family","sources","register","push","descriptor","res","styleSources","filter","s","exactFit","find","leftOffset","rightOffset","length","lt","gt","registerEmojiSource","url","format","getEmojiSource","registerHyphenationCallback","callback","getHyphenationCallback","fonts","font","i","getRegisteredFonts","getRegisteredFontFamilies","Object","keys","getFont","standardFonts","includes","reset","hasOwnProperty","clear","emoji","hyphenation","save","ctx","node","PROTOCOL_REGEXP","DEST_REGEXP","getURL","isSrcId","getSource","setLink","box","top","left","width","height","instanceMethod","slice","restore","isSvg","isText","isPage","hasSource","isLink","isNote","isImage","isCanvas","KAPPA","Math","sqrt","clipNode","style","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","rtr","min","ctr","moveTo","lineTo","bezierCurveTo","rbr","cbr","rbl","cbl","rtl","ctl","closePath","clip","renderPath","path","props","d","getProp","p","renderRect","x","y","rx","ry","krx","kry","renderLine","x1","y1","x2","y2","drawEllipse","cx","cy","ox","oy","xe","ye","xm","ym","renderEllipse","renderCircle","r","renderRun","run","runAdvanceWidth","runWidth","attributes","fontSize","color","opacity","fillColor","fillOpacity","sbix","COLR","CPAL","translate","ascent","glyphs","position","positions","glyph","xOffset","yOffset","render","xAdvance","yAdvance","_addGlyphs","error","console","log","renderSpan","line","textAnchor","lineWidth","runs","renderSvgText","children","span","lines","isOdd","lengthIsOdd","parsePoints","drawPolyline","points","forEach","renderPolyline","renderPolygon","printWarning","args","argIndex","message","replace","__DEV__","process","env","NODE_ENV","warning","condition","undefined","drawImage","paddingTop","paddingLeft","image","href","renderImage","getRotation","transform","exec","PI","getTranslateX","matchX","matchGeneric","getTranslateY","matchY","getScaleX","getScaleY","getMatrix","applySingleTransformation","origin","test","rotate","scale","applyTransformations","re","isPath","isRect","isLine","isTspan","isGroup","isCircle","isTextInstance","renderGroup","isEllipse","isPolygon","isPolyline","normalizePath","prev","bezierX","bezierY","startX","startY","quadX","quadY","len","seg","command","curves","arcToCurve","px","py","xAxisRotation","largeArcFlag","sweepFlag","c","j","quadratic","getPathBoundingBox","absPath","parsePath","bounds","Infinity","l","getCircleBoundingBox","getEllipseBoundingBox","getLineBoundingBox","getRectBoundingBox","max","getPolylineBoundingBox","xValues","yValues","getBoundingBox","warnUnsupportedNode","warn","type","setStrokeWidth","setStrokeColor","strokeColor","setOpacity","setFillOpacity","setStrokeOpacity","strokeOpacity","setLineJoin","lineJoin","setLineCap","lineCap","setLineDash","dashArray","dash","space","hasLinearGradientFill","hasRadialGradientFill","setLinearGradientFill","bbox","gradient","m0","m3","m4","m5","gx1","gy1","gx2","gy2","grad","linearGradient","stop","offset","stopColor","stopOpacity","fill","setRadialGradientFill","fx","fy","gr","gcx","gcy","gfx","gfy","radialGradient","setFillColor","setFill","draw","stroke","fillAndStroke","fillRule","renderNode","renderSvgImage","drawNode","clipPath","drawChildren","defaultsZero","preserveAspectRatio","viewBox","meetOrSlice","align","minX","minY","logicalWidth","maxX","logicalHeight","maxY","logicalRatio","physicalRatio","scaleX","scaleY","moveToOrigin","renderSvg","renderText","initialY","PDFRenderer","renderPage","addPage","size","margin","renderNote","note","isPercent","matchPercent","percent","absValue","abs","absPercent","isNumeric","n","isNaN","isFinite","applyContainObjectFit","cw","ch","iw","ih","cr","ir","pxp","pyp","pxv","pyv","applyNoneObjectFit","applyCoverObjectFit","applyScaleDownObjectFit","containDimension","noneDimension","applyFillObjectFit","resolveObjectFit","objectPositionX","objectPositionY","paddingRight","paddingBottom","objectFit","availableMethods","painter","reduce","acc","prop","renderCanvas","availableWidth","availableHeight","paint","hasVerticalRuler","hasHorizontalRuler","range","steps","Array","ceil","_","matchPercentage","getVerticalSteps","page","horizontalRulerSteps","rulerSteps","percentage","getHorizontalSteps","verticalRulerSteps","renderVerticalRuler","hRange","rect","map","step","text","round","renderHorizontalRuler","renderRulers","getDocumentProp","target","or","setPDFMetadata","info","addMetadata","doc","setProp","title","author","subject","keywords","creator","producer","CONTENT_COLOR","PADDING_COLOR","MARGIN_COLOR","shouldDebug","debugContent","borderLeftWidth","borderTopWidth","borderRightWidth","borderBottomWidth","debugPadding","debugMargin","marginLeft","marginTop","marginRight","marginBottom","debugText","roundedWidth","roundedHeight","debugOrigin","circle","renderDebug","clipBorderTop","layout","c0","topRightYCoord","innerTopRightRadiusX","innerTopRightRadiusY","c1","c2","innerTopLeftRadiusX","innerTopLeftRadiusY","c3","c4","topLeftYCoord","c5","trSlope","fillBorderTop","borderTopColor","borderTopStyle","undash","clipBorderRight","topBottomXCoord","innerBottomRightRadiusX","innerBottomRightRadiusY","topRightXCoord","brSlope","fillBorderRight","borderRightColor","borderRightStyle","clipBorderBottom","bottomLeftYCoord","innerBottomLeftRadiusX","innerBottomLeftRadiusY","bottomRightYCoord","fillBorderBottom","borderBottomColor","borderBottomStyle","clipBorderLeft","topLeftCoordX","bottomLeftXCoord","fillBorderLeft","borderLeftColor","borderLeftStyle","shouldRenderBorders","renderBorders","setDestination","id","addNamedDestination","drawBackground","backgroundColor","shouldRenderBackground","renderBackground","shouldRenderChildren","renderChildren","renderDocument","end","capitalize","toUpperCase","upperFirst","transformText","transformation","StandardFont","PDFFont","str","encode","encoded","stringIndices","g","getGlyph","parseInt","advanceWidth","glyphForCodePoint","codePoint","_font","codePoints","isLigature","characterToGlyph","hasGlyphForCodePoint","fontCache","IGNORED_CODE_POINTS","getFontSize","getOrCreateFont","getFallbackFont","shouldFallbackToFont","fontSubstitution","string","lastFont","lastIndex","index","defaultFont","start","char","codePointAt","unitsPerEm","engines","linebreaker","justification","textDecoration","scriptItemizer","wordHyphenation","engine","layoutEngine","layoutOptions","shrinkWhitespaceFactor","before","after","getFragments","instance","fragments","textDecorationColor","textDecorationStyle","textTransform","obj","underlineStyle","underline","underlineColor","strike","strikeStyle","strikeColor","child","getAttributedString","AttributedString","fromFragments","AlmostInfinity","layoutTspan","attributedString","container","layoutText","isDefs","getChildren","getId","getDefs","isNotDefs","detachDefs","URL_REGEX","replaceDef","defs","parseNodeDefs","parseDefs","root","replaceDefs","parseViewbox","values","getContainer","viewbox","parseViewBox","getInheritProps","inheritProps","parseAspectRatio","isRgb","isRgba","isHsl","isHsla","parseRgb","colorString","to","hex","get","rgb","parseHsl","hlsToHex","hsl","transformColor","transformColors","styles","STYLE_PROPS","VERTICAL_PROPS","HORIZONTAL_PROPS","transformPercent","parsePercent","parseProps","mergeStyles","removeNoneValues","pickStyleProps","styleProps","parseSvgProps","wrapBetweenTspan","addMissingTspan","resolveSvgNode","resolveChildren","parseText","resolveSvgRoot","resolveSvg","getZIndex","isType","shouldNotSort","sortZIndex","a","b","za","zb","resolveZIndex","adjustPageSize","resolveRulers","PNG","isValid","e","MARKERS","JPEG","readUInt16BE","marker","pos","isBuffer","createCache","limit","cache","set","shift","IMAGE_CACHE","getAbsoluteLocalPath","fetchLocalFile","fetchRemoteFile","uri","isValidFormat","lower","guessFormat","isCompatibleBase64","getImage","extension","resolveBase64Image","resolveImageFromData","JSON","stringify","resolveBufferImage","getImageFormat","isPng","isJpg","resolveImageFromUrl","resolveImage","cacheKey","toString","isNotNil","firstPass","fns","fn","resolveSrc","fetchImage","source","_context2","emojis","regex","emojiRegex","reflect","promise","then","makeFetchEmojiImage","_removeNoColor","getCodePoints","join","buildEmojiUrl","fetchEmojis","promises","emojiUrl","fetchEmojiImage","embedEmojis","fragment","emojiSize","chunk","fromCharCode","attachment","floor","fetchAssets","listToExplore","childNode","resolveAssets","all","isNotArray","castArray","compact","Boolean","isArray","flatten","prototype","styleShorthands","marginHorizontal","marginVertical","padding","paddingHorizontal","paddingVertical","border","borderTop","borderRight","borderBottom","borderLeft","borderColor","borderRadius","borderStyle","borderWidth","objectPosition","transformOrigin","transformOriginX","transformOriginY","flex","flexGrow","flexShrink","flexBasis","expandStyles","propsArray","resolvedStyle","expandedProps","propName","call","MM_FACTOR","CM_FACTOR","parseValue","unit","transformUnit","scalar","transformUnits","resolveMediaQueries","matchMedia","LINK_STYLES","filterNoneValues","resolveStyles","flattenStyles","resolveNodeStyles","resolvePageStyles","getTransformStyle","getOrigin","percentX","percentY","resolveNodeOrigin","resolveOrigin","VALID_ORIENTATIONS","getOrientation","isLandscape","toSizeObject","flipSizeObject","getStringSize","getNumberSize","throwInvalidError","getSize","assocIfNil","resolvePageSize","getPageSize","resolvePageSizes","lineIndexAtHeight","heightAtLineIndex","counter","zero","getTop","getWidows","getOrphans","getLineBreak","widows","orphans","linesQuantity","slicedLine","splitText","slicedLineIndex","currentHeight","nextHeight","hasFixedHeight","subtractHeight","splitNode","nodeTop","current","isString","isNotString","createInstance","element","getNodesHeight","nodes","getWrap","getBreak","getMinPresenceAhead","defaultPresenceAhead","getPresenceAhead","elements","isElementInside","presenceAhead","shouldBreak","futureElements","minPresenceAhead","futureHeight","shouldSplit","shouldWrap","getComputedPadding","edge","yogaNode","_yogaNode","getPadding","Yoga","EDGE_TOP","EDGE_RIGHT","EDGE_BOTTOM","EDGE_LEFT","getContentArea","IGNORABLE_CODEPOINTS","buildSubsetForFont","ignoreChars","charSubset","subsetRegex","RegExp","PREPROCESSORS","textAlign","lineHeight","letterSpacing","textIndent","indent","link","characterSpacing","preprocessor","maxLines","truncateMode","getLayoutOptions","hyphenationPenalty","isNotSvg","hasLines","fixed","shouldLayoutText","resolveTextLayout","getInheritStyles","resolveInheritance","inheritStyles","getComputedMargin","getMargin","getComputedTop","getRight","getComputedRight","getBottom","getComputedBottom","getLeft","getComputedLeft","getPosition","right","bottom","DEFAULT_DIMENSION","getDimension","getComputedWidth","getComputedHeight","getComputedBorder","getBorderWidth","setDisplay","DISPLAY_NONE","DISPLAY_FLEX","setOverflow","yogaValue","OVERFLOW_HIDDEN","OVERFLOW_SCROLL","OVERFLOW_VISIBLE","setFlexWrap","WRAP_WRAP","WRAP_WRAP_REVERSE","WRAP_NO_WRAP","setYogaValue","attr","hasEdge","fixedMethod","autoMethod","percentMethod","setFlexGrow","setFlexBasis","setAlign","ALIGN_FLEX_START","ALIGN_CENTER","ALIGN_FLEX_END","ALIGN_STRETCH","ALIGN_BASELINE","ALIGN_SPACE_BETWEEN","ALIGN_SPACE_AROUND","ALIGN_AUTO","setAlignSelf","setAlignItems","setFlexShrink","setAspectRatio","setAlignContent","setPositionType","POSITION_TYPE_ABSOLUTE","POSITION_TYPE_RELATIVE","isRow","isRowReverse","isColumnReverse","setFlexDirection","FLEX_DIRECTION_ROW","FLEX_DIRECTION_ROW_REVERSE","FLEX_DIRECTION_COLUMN_REVERSE","FLEX_DIRECTION_COLUMN","setJustifyContent","JUSTIFY_CENTER","JUSTIFY_FLEX_END","JUSTIFY_SPACE_BETWEEN","JUSTIFY_SPACE_AROUND","JUSTIFY_SPACE_EVENLY","JUSTIFY_FLEX_START","setMarginTop","setMarginRight","setMarginBottom","setMarginLeft","setPaddingTop","setPaddingRight","setPaddingBottom","setPaddingLeft","setBorderTop","setBorderRight","setBorderBottom","setBorderLeft","setPositionTop","setPositionRight","setPositionBottom","setPositionLeft","setWidth","setMinWidth","setMaxWidth","setHeight","setMinHeight","setMaxHeight","getAspectRatio","measureCanvas","widthMode","heightMode","aspectRatio","MEASURE_MODE_EXACTLY","MEASURE_MODE_AT_MOST","linesWidth","linesHeight","measureText","getRatio","isHeightAuto","SAFETY_HEIGHT","measureImage","imageRatio","imageMargin","pagePadding","pageArea","MEASURE_MODE_UNDEFINED","scaledHeight","getMax","measureCtx","nil","addPoint","w","h","ellipse","polygon","roundedRect","quadraticCurveTo","miterLimit","getWidth","getHeight","YOGA_NODE","YOGA_CONFIG","Config","setPointScaleFactor","setNodeHeight","setYogaValues","minWidth","maxWidth","minHeight","maxHeight","display","flexDirection","alignSelf","alignContent","alignItems","justifyContent","flexWrap","overflow","insertYogaNodes","parent","insertChild","getChildCount","setMeasureFunc","measureSvg","isNotText","isNotNote","isNotTextInstance","isLayoutElement","createYogaNodes","Node","createWithConfig","calculateLayout","persistDimensions","destroyYogaNodes","destroy","resolvePageDimensions","resolveDimensions","SAFTY_THRESHOLD","assingChildren","isElementOutside","isFixed","allFixed","isDynamic","relayoutPage","splitView","currentNode","nextNode","splitChildren","currentChilds","nextChildren","splitNodes","currentChildren","futureNodes","futureFixedNodes","nodeHeight","isOutside","shouldNodeBreak","next","break","currentChild","nextChild","splitPage","pageNumber","contentArea","dynamicPage","resolveDynamicPage","nextChilds","currentPage","shouldResolveDynamicNodes","resolveDynamicNodes","isNodeDynamic","paginate","splittedPage","pages","nextPage","resolvePageIndices","totalPages","resolvePagination","subpages","concat","removeMargins","resolvePageMargins","getNodeText","getNodesText","wrapTextInstance","resolveNoteChildren","resolvePageHorizontalPadding","resolvePageVerticalPadding","resolvePagePaddings","resolveRadius","resolvePercentRadius","transformHeight","getPageArea","hasHeight","resolveNodePercentHeight","resolvePagePercentHeight","resolvePercentHeight","hasRenderProp","hasTextInstanceChilds","resolveLinkSubstitution","asyncCompose","resolveOrigins","propsEqual","oldPropsKeys","newPropsKeys","emptyObject","createRenderer","onChange","ReactFiberReconciler","schedulePassiveEffects","cancelPassiveEffects","supportsMutation","isPrimaryRenderer","warnsIfNotActing","appendInitialChild","parentInstance","createTextInstance","rootContainerInstance","finalizeInitialChildren","getPublicInstance","prepareForCommit","prepareUpdate","oldProps","newProps","resetAfterCommit","resetTextContent","getRootHostContext","getChildHostContext","shouldSetTextContent","now","Date","useSyncScheduling","appendChild","appendChildToContainer","document","insertBefore","beforeChild","indexOf","splice","removeChild","removeChildFromContainer","commitTextUpdate","textInstance","oldText","newText","commitUpdate","updatePayload","absoluteFillObject","hairlineWidth","View","Text","Link","Page","Note","Image","Document","Canvas","Svg","G","Path","Rect","Line","Circle","Ellipse","Polygon","Polyline","Defs","Tspan","ClipPath","Stop","LinearGradient","RadialGradient","pdf","initialValue","mountNode","createContainer","updateContainer","PDFDocument","autoFirstPage","time","layoutDocument","timeEnd","renderPDF","callOnRender","params","onRender","stream","pipe","BlobStream","on","blob","toBlob","toBuffer","svgpath","require","queue","canvasInstance","canvas","images","getContext","clearRect","f","fillStyle","globalAlpha","toSVG","Path2D","base64Data","btoa","apply","img","createElement","onload","CanvasViewer","renderQueue","autostart","concurrency","state","onRenderFailed","setState","onRenderSuccessful","componentDidMount","queueDocumentRender","componentDidUpdate","prevProps","componentWillUnmount","_this2","isDirty","renderWithContext","React","ref","_this3","Component","flatStyles","stylesArray","InternalBlobProvider","oldBlobUrl","URL","createObjectURL","revokeObjectURL","PureComponent","BlobProvider","PDFViewer","className","innerRef","PDFDownloadLink","fileName","download","onClick","window","navigator","msSaveBlob","version","StyleSheet"],"mappings":"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"}