"use strict";function _interopDefault(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports,"__esModule",{value:!0});var fs=_interopDefault(require("fs")),BlobStream=_interopDefault(require("blob-stream")),PDFDocument=require("@react-pdf/pdfkit"),PDFDocument__default=_interopDefault(PDFDocument),isUrl=_interopDefault(require("is-url")),fontkit=_interopDefault(require("@react-pdf/fontkit")),fetch=_interopDefault(require("cross-fetch")),R=require("ramda"),runWidth=_interopDefault(require("@react-pdf/textkit/run/advanceWidth")),lineWidth=_interopDefault(require("@react-pdf/textkit/attributedString/advanceWidth")),absPath=_interopDefault(require("abs-svg-path")),parsePath=_interopDefault(require("parse-svg-path")),arcToCurve=_interopDefault(require("svg-arc-to-cubic-bezier")),PDFRenderer=_interopDefault(require("@react-pdf/textkit/renderers/pdf")),layoutEngine=_interopDefault(require("@react-pdf/textkit/layout")),linebreaker=_interopDefault(require("@react-pdf/textkit/engines/linebreaker")),justification=_interopDefault(require("@react-pdf/textkit/engines/justification")),textDecoration=_interopDefault(require("@react-pdf/textkit/engines/textDecoration")),scriptItemizer=_interopDefault(require("@react-pdf/textkit/engines/scriptItemizer")),wordHyphenation=_interopDefault(require("@react-pdf/textkit/engines/wordHyphenation")),AttributedString=_interopDefault(require("@react-pdf/textkit/attributedString")),colorString=_interopDefault(require("color-string")),hlsToHex=_interopDefault(require("hsl-to-hex")),url=_interopDefault(require("url")),path=_interopDefault(require("path")),PNG=_interopDefault(require("@react-pdf/png-js")),emojiRegex=_interopDefault(require("emoji-regex")),matchMedia=_interopDefault(require("media-engine")),Yoga=_interopDefault(require("yoga-layout-prebuilt")),ReactFiberReconciler=_interopDefault(require("react-reconciler")),scheduler=require("scheduler");const VIEW="VIEW",TEXT="TEXT",LINK="LINK",PAGE="PAGE",NOTE="NOTE",IMAGE="IMAGE",DOCUMENT="DOCUMENT",CANVAS="CANVAS",TEXT_INSTANCE="TEXT_INSTANCE",SVG="SVG",GROUP="G",PATH="PATH",RECT="RECT",LINE="LINE",CIRCLE="CIRCLE",ELLIPSE="ELLIPSE",POLYGON="POLYGON",POLYLINE="POLYLINE",DEFS="DEFS",TSPAN="TSPAN",CLIP_PATH="CLIP_PATH",STOP="STOP",LINEAR_GRADIENT="LINEAR_GRADIENT",RADIAL_GRADIENT="RADIAL_GRADIENT",DPI=72,FONT_WEIGHTS={thin:100,hairline:100,ultralight:200,extralight:200,light:300,normal:400,medium:500,semibold:600,demibold:600,bold:700,ultrabold:800,extrabold:800,heavy:900,black:900},PAGE_SIZES={"4A0":[4767.87,6740.79],"2A0":[3370.39,4767.87],A0:[2383.94,3370.39],A1:[1683.78,2383.94],A2:[1190.55,1683.78],A3:[841.89,1190.55],A4:[595.28,841.89],A5:[419.53,595.28],A6:[297.64,419.53],A7:[209.76,297.64],A8:[147.4,209.76],A9:[104.88,147.4],A10:[73.7,104.88],B0:[2834.65,4008.19],B1:[2004.09,2834.65],B2:[1417.32,2004.09],B3:[1000.63,1417.32],B4:[708.66,1000.63],B5:[498.9,708.66],B6:[354.33,498.9],B7:[249.45,354.33],B8:[175.75,249.45],B9:[124.72,175.75],B10:[87.87,124.72],C0:[2599.37,3676.54],C1:[1836.85,2599.37],C2:[1298.27,1836.85],C3:[918.43,1298.27],C4:[649.13,918.43],C5:[459.21,649.13],C6:[323.15,459.21],C7:[229.61,323.15],C8:[161.57,229.61],C9:[113.39,161.57],C10:[79.37,113.39],RA0:[2437.8,3458.27],RA1:[1729.13,2437.8],RA2:[1218.9,1729.13],RA3:[864.57,1218.9],RA4:[609.45,864.57],SRA0:[2551.18,3628.35],SRA1:[1814.17,2551.18],SRA2:[1275.59,1814.17],SRA3:[907.09,1275.59],SRA4:[637.8,907.09],EXECUTIVE:[521.86,756],FOLIO:[612,936],LEGAL:[612,1008],LETTER:[612,792],TABLOID:[792,1224]},PORTRAIT="portrait",LANDSCAPE="landscape",INHERITED_PROPERTIES=["color","fontFamily","fontSize","fontStyle","fontWeight","letterSpacing","opacity","textDecoration","lineHeight","textAlign","visibility","wordSpacing"],SVG_INHERITED_PROPS=["x","y","clipPath","clipRule","opacity","fill","fillOpacity","fillRule","stroke","strokeLinecap","strokeLinejoin","strokeOpacity","strokeWidth","textAnchor",...INHERITED_PROPERTIES],RULER_WIDTH=13,RULER_COLOR="white",RULER_FONT_SIZE=6,DEFAULT_RULER_STEPS=50,LINE_WIDTH=.5,LINE_COLOR="gray",GRID_COLOR="#ababab",BOX_MODEL_REGEX=/\d+(px|in|mm|cm|pt|%|vw|vh|px)?/g,OBJECT_POSITION_REGEX=/\d+(px|in|mm|cm|pt|%|vw|vh|px)?/g,BORDER_SHORTHAND_REGEX=/(\d+(px|in|mm|cm|pt|vw|vh|px)?)\s(\S+)\s(\S+)/,TRANSFORM_ORIGIN_REGEX=/(-?\d+(px|in|mm|cm|pt|%|vw|vh|px)?)|top|right|bottom|left|center/g,matchBoxModel=R.match(BOX_MODEL_REGEX),matchObjectPosition=R.match(OBJECT_POSITION_REGEX),matchBorderShorthand=R.match(BORDER_SHORTHAND_REGEX),matchTransformOrigin=R.match(TRANSFORM_ORIGIN_REGEX),isNumber=R.is(Number),isFontWeightStyle=e=>e.match(/^fontWeight/),isBorderStyle=(e,t)=>e.match(/^border(Top|Right|Bottom|Left)(Color|Width|Style)/)&&"string"==typeof t,isBoxModelStyle=(e,t)=>e.match(/^(margin)|(padding)/)&&"string"==typeof t,isObjectPositionStyle=(e,t)=>e.match(/^objectPosition/)&&"string"==typeof t,isTransformOriginStyle=(e,t)=>e.match(/^transformOrigin/)&&"string"==typeof t,isFlexGrow=e=>"flexGrow"===e,isFlexShrink=e=>"flexShrink"===e,isFlexBasis=e=>"flexBasis"===e,processBorders=(e,t)=>{const r=matchBorderShorthand(t);if(r){if(e.match(/Color$/))return r[4]||t;if(e.match(/Style$/))return r[3]||t;if(e.match(/Width$/))return r[1]||t;throw new Error(`StyleSheet: Invalid '${t}' for '${e}'`)}return t},processBoxModel=(e,t)=>{const r=matchBoxModel(t);if(r){if(e.match(/Top$/))return r[0];if(e.match(/Right$/))return r[1]||r[0];if(e.match(/Bottom$/))return r[2]||r[0];if(e.match(/Left$/))return r[3]||r[1]||r[0];throw new Error(`StyleSheet: Invalid '${t}' for '${e}'`)}return t},processFontWeight=(e,t)=>t?"number"==typeof t?t:FONT_WEIGHTS[t.toLowerCase()]:FONT_WEIGHTS.normal,processObjectPosition=(e,t)=>{const r=matchObjectPosition(t);if(r){if(e.match(/X$/))return r[0]||t;if(e.match(/Y$/))return r[1]||t;throw new Error(`StyleSheet: Invalid '${t}' for '${e}'`)}return t},transformOffsetKeywords=e=>{switch(e){case"top":case"left":return"0%";case"right":case"bottom":return"100%";case"center":return"50%";default:return e}},processTransformOrigin=(e,t)=>{const r=matchTransformOrigin(t);if(r){let o;if(e.match(/X$/))o=r[0]||t;else{if(!e.match(/Y$/))throw new Error(`StyleSheet: Invalid '${t}' for '${e}'`);o=r[1]||r[0]||t}return transformOffsetKeywords(o)}return t},processFlexGrow=(e,t)=>{if(isNumber(t))return t;return t.split(" ")[0]},processFlexShrink=(e,t)=>{if(isNumber(t))return t;return t.split(" ")[1]},processFlexBasis=(e,t)=>{if(isNumber(t))return t;return t.split(" ")[2]},keepSame=(e,t)=>t,matchNumber=R.when(R.is(String),R.test(/^-?\d*\.?\d*$/)),castFloat=R.when(matchNumber,e=>parseFloat(e,10)),transformStyle=R.compose(castFloat,R.cond([[isBorderStyle,processBorders],[isBoxModelStyle,processBoxModel],[isObjectPositionStyle,processObjectPosition],[isTransformOriginStyle,processTransformOrigin],[isFontWeightStyle,processFontWeight],[isFlexGrow,processFlexGrow],[isFlexShrink,processFlexShrink],[isFlexBasis,processFlexBasis],[R.T,keepSame]])),transformStyles=R.mapObjIndexed(R.flip(transformStyle)),fetchFont=async(e,t)=>{const r=await fetch(e,t),o=await(r.buffer?r.buffer():r.arrayBuffer());return"Buffer"===o.constructor.name?o:Buffer.from(o)};class FontSource{constructor(e,t,r,o,i){this.src=e,this.fontFamily=t,this.fontStyle=r||"normal",this.fontWeight=processFontWeight(o)||400,this.data=null,this.loading=!1,this.options=i}async load(){if(this.loading=!0,isUrl(this.src)){const{headers:e,body:t,method:r="GET"}=this.options,o=await fetchFont(this.src,{method:r,body:t,headers:e});this.data=fontkit.create(o)}else this.data=await new Promise((e,t)=>fontkit.open(this.src,(r,o)=>r?t(r):e(o)));this.loading=!1}}class Font{static create(e){return new Font(e)}constructor(e){this.family=e,this.sources=[]}register({src:e,fontWeight:t,fontStyle:r,...o}){this.sources.push(new FontSource(e,this.fontFamily,r,t,o))}resolve(e){const{fontWeight:t=400,fontStyle:r="normal"}=e,o=this.sources.filter(e=>e.fontStyle===r),i=o.find(e=>e.fontWeight===t);if(i)return i;let a;if(t>=400&&t<=500){const e=o.filter(e=>e.fontWeight<=t),r=o.filter(e=>e.fontWeight>500);a=o.filter(e=>e.fontWeight>=t&&e.fontWeight<500)[0]||e[e.length-1]||r[0]}const s=o.filter(e=>e.fontWeight<t),n=o.filter(e=>e.fontWeight>t);if(t<400&&(a=s[s.length-1]||n[0]),t>500&&(a=n[0]||s[s.length-1]),!a)throw new Error(`Could not resolve font for ${this.fontFamily}, fontWeight ${t}`);return a}}let emojiSource;const registerEmojiSource=({url:e,format:t="png"})=>{emojiSource={url:e,format:t}},getEmojiSource=()=>emojiSource;var emoji={registerEmojiSource:registerEmojiSource,getEmojiSource:getEmojiSource},standardFonts=["Courier","Courier-Bold","Courier-Oblique","Helvetica","Helvetica-Bold","Helvetica-Oblique","Times-Roman","Times-Bold","Times-Italic"];let hyphenationCallback;const registerHyphenationCallback=e=>{hyphenationCallback=e},getHyphenationCallback=()=>hyphenationCallback;var hyphenation={registerHyphenationCallback:registerHyphenationCallback,getHyphenationCallback:getHyphenationCallback};let fonts={};const register=e=>{const{family:t}=e;if(fonts[t]||(fonts[t]=Font.create(t)),e.fonts)for(let r=0;r<e.fonts.length;r++)fonts[t].register({family:t,...e.fonts[r]});else fonts[t].register(e)},getRegisteredFonts=()=>fonts,getRegisteredFontFamilies=()=>Object.keys(fonts),getFont=e=>{const{fontFamily:t}=e;if(standardFonts.includes(t))return null;if(!fonts[t])throw new Error(`Font family not registered: ${t}. Please register it calling Font.register() method.`);return fonts[t].resolve(e)},load=async function(e){const{fontFamily:t}=e;if(standardFonts.includes(t))return;const r=getFont(e);r.data||r.loading||await r.load()},reset=function(){for(const e in fonts)fonts.hasOwnProperty(e)&&(fonts[e].data=null)},clear=function(){fonts={}};var Font$1={register:register,getRegisteredFonts:getRegisteredFonts,getRegisteredFontFamilies:getRegisteredFontFamilies,getFont:getFont,load:load,clear:clear,reset:reset,...emoji,...hyphenation};const save=(e,t)=>(e.save(),t);var save$1=R.curryN(2,save);const PROTOCOL_REGEXP=/^([a-z]+\:(\/\/)?)/i,DEST_REGEXP=/^#.+/,getURL=e=>e?isSrcId(e)?e:"string"!=typeof e||e.match(PROTOCOL_REGEXP)?e:`http://${e}`:"",isSrcId=e=>e.match(DEST_REGEXP),DEST_REGEXP$1=/^#.+/,isSrcId$1=R.test(DEST_REGEXP$1),getSource=R.compose(R.either(R.path(["props","src"]),R.path(["props","href"]))),setLink=(e,t)=>{const{top:r,left:o,width:i,height:a}=t.box,s=getSource(t),n=isSrcId$1(s)?"goTo":"link",l=isSrcId$1(s)?s.slice(1):getURL(s);return l&&e[n](o,r,i,a,l),t};var setLink$1=R.curryN(2,setLink);const restore=(e,t)=>(e.restore(),t);var restore$1=R.curryN(2,restore);const isSvg=R.propEq("type",SVG),isText=R.propEq("type",TEXT),isPage=R.propEq("type",PAGE),hasSource=R.either(R.hasPath(["props","src"]),R.hasPath(["props","href"])),isLink=R.either(R.propEq("type",LINK),R.both(R.propEq("type",TEXT),hasSource)),isNote=R.propEq("type",NOTE),isImage=R.propEq("type",IMAGE),isCanvas=R.propEq("type",CANVAS),KAPPA=(Math.sqrt(2)-1)/3*4,clipNode=(e,t)=>{const{top:r,left:o,width:i,height:a}=t.box,{borderTopLeftRadius:s=0,borderTopRightRadius:n=0,borderBottomRightRadius:l=0,borderBottomLeftRadius:p=0}=t.style,d=Math.min(n,.5*i,.5*a),c=d*(1-KAPPA);e.moveTo(o+d,r),e.lineTo(o+i-d,r),e.bezierCurveTo(o+i-c,r,o+i,r+c,o+i,r+d);const h=Math.min(l,.5*i,.5*a),g=h*(1-KAPPA);e.lineTo(o+i,r+a-h),e.bezierCurveTo(o+i,r+a-g,o+i-g,r+a,o+i-h,r+a);const R=Math.min(p,.5*i,.5*a),u=R*(1-KAPPA);e.lineTo(o+R,r+a),e.bezierCurveTo(o+u,r+a,o,r+a-u,o,r+a-R);const m=Math.min(s,.5*i,.5*a),f=m*(1-KAPPA);return e.lineTo(o,r+m),e.bezierCurveTo(o,r+f,o+f,r,o+m,r),e.closePath(),e.clip(),t};var clipNode$1=R.curryN(2,clipNode);const renderPath=e=>R.tap(t=>{R.path(["props","d"],t)&&e.path(t.props.d)}),KAPPA$1=(Math.sqrt(2)-1)/3*4,getProp=(e,t,r)=>R.pathOr(e,["props",t],r),renderRect=e=>t=>{const r=getProp(0,"x",t),o=getProp(0,"y",t),i=getProp(0,"rx",t),a=getProp(0,"ry",t),s=getProp(0,"width",t),n=getProp(0,"height",t);if(!s||!n)return t;if(i&&a){const t=i*KAPPA$1,l=a*KAPPA$1;e.moveTo(r+i,o),e.lineTo(r-i+s,o),e.bezierCurveTo(r-i+s+t,o,r+s,o+a-l,r+s,o+a),e.lineTo(r+s,o+n-a),e.bezierCurveTo(r+s,o+n-a+l,r-i+s+t,o+n,r-i+s,o+n),e.lineTo(r+i,o+n),e.bezierCurveTo(r+i-t,o+n,r,o+n-a+l,r,o+n-a),e.lineTo(r,o+a),e.bezierCurveTo(r,o+a-l,r+i-t,o,r+i,o)}else e.moveTo(r,o),e.lineTo(r+s,o),e.lineTo(r+s,o+n),e.lineTo(r,o+n);return e.closePath(),t},getProp$1=(e,t)=>R.path(["props",e],t),renderLine=e=>t=>{const r=getProp$1("x1",t),o=getProp$1("y1",t),i=getProp$1("x2",t),a=getProp$1("y2",t);return e.moveTo(r,o),e.lineTo(i,a),t},KAPPA$2=(Math.sqrt(2)-1)/3*4,getProp$2=(e,t)=>R.path(["props",e],t),drawEllipse=(e,t,r,o,i)=>{const a=t-o,s=r-i,n=o*KAPPA$2,l=i*KAPPA$2,p=a+2*o,d=s+2*i,c=a+o,h=s+i;e.moveTo(a,h),e.bezierCurveTo(a,h-l,c-n,s,c,s),e.bezierCurveTo(c+n,s,p,h-l,p,h),e.bezierCurveTo(p,h+l,c+n,d,c,d),e.bezierCurveTo(c-n,d,a,h+l,a,h),e.closePath()},renderEllipse=e=>R.tap(t=>{const r=getProp$2("cx",t),o=getProp$2("cy",t),i=getProp$2("rx",t),a=getProp$2("ry",t);drawEllipse(e,r,o,i,a)}),getProp$3=(e,t)=>R.path(["props",e],t),renderCircle=e=>R.tap(t=>{const r=getProp$3("cx",t),o=getProp$3("cy",t),i=getProp$3("r",t);drawEllipse(e,r,o,i,i)}),renderRun=(e,t)=>{const r=runWidth(t),{font:o,fontSize:i,color:a,opacity:s}=t.attributes;if(e.fillColor(a),e.fillOpacity(s),o.sbix||o.COLR&&o.CPAL){e.save(),e.translate(0,-t.ascent);for(let r=0;r<t.glyphs.length;r++){const o=t.positions[r],a=t.glyphs[r];e.save(),e.translate(o.xOffset,o.yOffset),a.render(e,i),e.restore(),e.translate(o.xAdvance,o.yAdvance)}e.restore()}else{e.font("string"==typeof o.name?o.name:o,i);try{e._addGlyphs(t.glyphs,t.positions,0,0)}catch(e){console.log(e)}}e.translate(r,0)},renderSpan=(e,t,r)=>{e.save();const o=R.pathOr(0,["box","x"],t),i=R.pathOr(0,["box","y"],t),a=lineWidth(t);switch(r){case"middle":e.translate(o-a/2,i);break;case"end":e.translate(o-a,i);break;default:e.translate(o,i)}for(const r of t.runs)renderRun(e,r);e.restore()},renderSvgText=e=>t=>{for(const r of t.children)renderSpan(e,r.lines[0],r.props.textAnchor);return t},isOdd=e=>e%2!=0,lengthIsOdd=R.o(isOdd,R.prop("length")),parsePoints=R.compose(R.splitEvery(2),R.map(parseFloat),R.when(lengthIsOdd,R.slice(0,-1)),R.split(/\s+/),R.replace(/(\d)-(\d)/g,"$1 -$2"),R.replace(/,/g," "),R.trim),drawPolyline=e=>t=>{t.length>0&&(e.moveTo(t[0][0],t[0][1]),t.slice(1).forEach(t=>e.lineTo(t[0],t[1])))},renderPolyline=e=>R.tap(R.compose(drawPolyline(e),parsePoints,R.pathOr("",["props","points"]))),closePath=e=>R.tap(()=>e.closePath()),renderPolygon=e=>R.compose(closePath(e),renderPolyline(e));function printWarning(e,...t){let r=0;const o="Warning: "+e.replace(/%s/g,()=>t[r++]);"undefined"!=typeof console&&console.error(o);try{throw new Error(o)}catch(e){}}const __DEV__="production"!==process.env.NODE_ENV,warning=__DEV__?(e,t,...r)=>{if(void 0===t)throw new Error("`warning(condition, format, ...args)` requires a warning message argument");e||printWarning(t,...r)}:()=>{},drawImage=e=>t=>{const{x:r,y:o}=t.props,{width:i,height:a,opacity:s}=t.style,n=t.box.paddingLeft||0,l=t.box.paddingLeft||0;return t.image.data&&(0!==i&&0!==a?e.fillOpacity(s||1).image(t.image.data,r+l,o+n,{width:i,height:a}):warning(!1,`Image with src '${t.props.href}' skipped due to invalid dimensions`)),t},renderImage=(e,t)=>(R.compose(restore$1(e),drawImage(e),save$1(e))(t),t);var renderSvgImage=R.curryN(2,renderImage);const getRotation=e=>{const t=/rotate\((-?\d+.?\d+)(.+)\)/g.exec(e);if(t&&t[1]&&t[2]){const e=t[1];return"rad"===t[2]?180*e/Math.PI:e}return 0},getTranslateX=e=>{const t=/translateX\((-?\d+\.?d*)\)/g.exec(e),r=/translate\((-?\d+\.?d*).*(,|\s)\s*(-?\d+\.?d*).*\)/g.exec(e);return t&&t[1]?t[1]:r&&r[1]?r[1]:0},getTranslateY=e=>{const t=/translateY\((-?\d+\.?\d*)\)/g.exec(e),r=/translate\((-?\d+\.?\d*).*(,|\s)\s*(-?\d+\.?\d*).*\)/g.exec(e);return t&&t[1]?t[1]:r&&r[3]?r[3]:0},getScaleX=e=>{const t=/scaleX\((-?\d+\.?\d*)\)/g.exec(e),r=/scale\((-?\d+\.?\d*).*,?\s*(-?\d+\.?\d*).*\)/g.exec(e);return t&&t[1]?t[1]:r&&r[1]?r[1]:1},getScaleY=e=>{const t=/scaleY\((-?\d+\.?\d*)\)/g.exec(e),r=/scale\((-?\d+\.?\d*).*,?\s*(-?\d+\.?\d*).*\)/g.exec(e);return t&&t[1]?t[1]:r&&r[2]?r[2]:1},getMatrix=e=>{const t=/matrix\(([^,]+),([^,]+),([^,]+),([^,]+),([^,]+),([^,]+)\)/g.exec(e);return t?t.slice(1,7):null},applySingleTransformation=(e,t,r)=>{/rotate/g.test(t)?e.rotate(getRotation(t),{origin:r}):/scaleX/g.test(t)?e.scale(getScaleX(t),1,{origin:r}):/scaleY/g.test(t)?e.scale(1,getScaleY(t),{origin:r}):/scale/g.test(t)?e.scale(getScaleX(t),getScaleY(t),{origin:r}):/translateX/g.test(t)?e.translate(getTranslateX(t),1,{origin:r}):/translateY/g.test(t)?e.translate(1,getTranslateY(t),{origin:r}):/translate/g.test(t)?e.translate(getTranslateX(t),getTranslateY(t),{origin:r}):/matrix/g.test(t)&&e.transform(...getMatrix(t))},applyTransformations=(e,t)=>{if(!t.origin)return t;let r;const o=/[a-zA-Z]+\([^)]+\)/g,i=[t.origin.left,t.origin.top],a=t.style&&t.style.transform||t.props&&t.props.transform||"";for(;null!=(r=o.exec(a));)applySingleTransformation(e,r[0],i);return t};var applyTransformations$1=R.curryN(2,applyTransformations);const isPath=R.propEq("type",PATH),isRect=R.propEq("type",RECT),isLine=R.propEq("type",LINE),isTspan=R.propEq("type",TSPAN),isGroup=R.propEq("type","G"),isCircle=R.propEq("type",CIRCLE),isTextInstance=R.propEq("type",TEXT_INSTANCE),renderGroup=()=>R.identity,isEllipse=R.propEq("type",ELLIPSE),isPolygon=R.propEq("type",POLYGON),isPolyline=R.propEq("type",POLYLINE),normalizePath=e=>{const t=[];let r,o=0,i=0,a=0,s=0,n=null,l=null,p=0,d=0;for(let c=0,h=e.length;c<h;c++){let h=e[c];const g=h[0];switch(g){case"M":a=h[1],s=h[2];break;case"A":const e=arcToCurve({px:p,py:d,cx:h[6],cy:h[7],rx:h[1],ry:h[2],xAxisRotation:h[3],largeArcFlag:h[4],sweepFlag:h[5]});if(!e.length)continue;for(let r,o=0;o<e.length;o++)h=["C",(r=e[o]).x1,r.y1,r.x2,r.y2,r.x,r.y],o<e.length-1&&t.push(h);break;case"S":let c=p,R=d;"C"!==r&&"S"!==r||(c+=c-o,R+=R-i),h=["C",c,R,h[1],h[2],h[3],h[4]];break;case"T":"Q"===r||"T"===r?(n=2*p-n,l=2*d-l):(n=p,l=d),h=quadratic(p,d,n,l,h[1],h[2]);break;case"Q":n=h[1],l=h[2],h=quadratic(p,d,h[1],h[2],h[3],h[4]);break;case"L":h=line(p,d,h[1],h[2]);break;case"H":h=line(p,d,h[1],d);break;case"V":h=line(p,d,p,h[1]);break;case"Z":h=line(p,d,a,s)}r=g,p=h[h.length-2],d=h[h.length-1],h.length>4?(o=h[h.length-4],i=h[h.length-3]):(o=p,i=d),t.push(h)}return t},line=(e,t,r,o)=>["C",e,t,r,o,r,o],quadratic=(e,t,r,o,i,a)=>["C",e/3+2/3*r,t/3+2/3*o,i/3+2/3*r,a/3+2/3*o,i,a],getPathBoundingBox=e=>{const t=R.compose(normalizePath,absPath,parsePath,R.pathOr("",["props","d"]))(e);if(!t.length)return[0,0,0,0];const r=[1/0,1/0,-1/0,-1/0];for(let e=0,o=t.length;e<o;e++){const o=t[e].slice(1);for(let e=0;e<o.length;e+=2)o[e+0]<r[0]&&(r[0]=o[e+0]),o[e+1]<r[1]&&(r[1]=o[e+1]),o[e+0]>r[2]&&(r[2]=o[e+0]),o[e+1]>r[3]&&(r[3]=o[e+1])}return r},getCircleBoundingBox=e=>{const t=R.pathOr(0,["props","r"],e),r=R.pathOr(0,["props","cx"],e),o=R.pathOr(0,["props","cy"],e);return[r-t,o-t,r+t,o+t]},getEllipseBoundingBox=e=>{const t=R.pathOr(0,["props","cx"],e),r=R.pathOr(0,["props","cy"],e),o=R.pathOr(0,["props","rx"],e),i=R.pathOr(0,["props","ry"],e);return[t-o,r-i,t+o,r+i]},getLineBoundingBox=e=>{const t=R.pathOr(0,["props","x1"],e),r=R.pathOr(0,["props","y1"],e),o=R.pathOr(0,["props","x2"],e),i=R.pathOr(0,["props","y2"],e);return[R.min(t,o),R.min(r,i),R.max(t,o),R.max(r,i)]},getRectBoundingBox=e=>{const t=R.pathOr(0,["props","x"],e),r=R.pathOr(0,["props","y"],e);return[t,r,t+R.pathOr(0,["props","width"],e),r+R.pathOr(0,["props","height"],e)]},max=R.reduce(R.max,-1/0),min=R.reduce(R.min,1/0),getPolylineBoundingBox=e=>{const t=R.compose(parsePoints,R.pathOr([],["props","points"]))(e),r=R.pluck(0,t),o=R.pluck(1,t);return[min(r),min(o),max(r),max(o)]},getBoundingBox=R.cond([[isRect,getRectBoundingBox],[isLine,getLineBoundingBox],[isPath,getPathBoundingBox],[isCircle,getCircleBoundingBox],[isEllipse,getEllipseBoundingBox],[isPolygon,getPolylineBoundingBox],[isPolyline,getPolylineBoundingBox],[R.T,R.always([0,0,0,0])]]),warnUnsupportedNode=R.tap(e=>{console.warn(`SVG node of type ${e.type} is not currenty supported`)}),getProp$4=(e,t,r)=>R.pathOr(e,["props",t],r),setStrokeWidth=e=>t=>{const r=getProp$4(0,"strokeWidth",t);return r&&e.lineWidth(r),t},setStrokeColor=e=>t=>{const r=getProp$4(null,"stroke",t);return r&&e.strokeColor(r),t},setOpacity=e=>t=>{const r=getProp$4(null,"opacity",t);return r&&e.opacity(r),t},setFillOpacity=e=>t=>{const r=getProp$4(null,"fillOpacity",t);return r&&e.fillOpacity(r),t},setStrokeOpacity=e=>t=>{const r=getProp$4(null,"strokeOpacity",t);return r&&e.strokeOpacity(r),t},setLineJoin=e=>t=>{const r=getProp$4(null,"strokeLinejoin",t);return r&&e.lineJoin(r),t},setLineCap=e=>t=>{const r=getProp$4(null,"strokeLinecap",t);return r&&e.lineCap(r),t},setLineDash=e=>t=>{const r=getProp$4(null,"strokeDasharray",t);if(r){const t=R.compose(R.map(R.o(parseFloat,R.trim)),R.split(","))(r);e.dash(t[0],{space:t[1]})}return t},hasLinearGradientFill=R.pathEq(["props","fill","type"],LINEAR_GRADIENT),hasRadialGradientFill=R.pathEq(["props","fill","type"],RADIAL_GRADIENT),setLinearGradientFill=e=>R.tap(t=>{const r=getBoundingBox(t),o=getProp$4(null,"fill",t),i=R.pathOr(0,["props","x1"],o),a=R.pathOr(0,["props","y1"],o),s=R.pathOr(1,["props","x2"],o),n=R.pathOr(0,["props","y2"],o),l=r[2]-r[0],p=r[3]-r[1],d=r[0],c=r[1],h=l*i+d,g=p*a+c,u=l*s+d,m=p*n+c,f=e.linearGradient(h,g,u,m);o.children.forEach(e=>{f.stop(e.props.offset,e.props.stopColor,e.props.stopOpacity)}),e.fill(f)}),setRadialGradientFill=e=>R.tap(t=>{const r=getBoundingBox(t),o=getProp$4(null,"fill",t),i=R.pathOr(.5,["props","cx"],o),a=R.pathOr(.5,["props","cy"],o),s=R.pathOr(i,["props","fx"],o),n=R.pathOr(a,["props","fy"],o),l=R.pathOr(.5,["props","r"],o),p=r[2]-r[0],d=r[3]-r[1],c=r[0],h=r[1],g=l*p,u=p*i+c,m=d*a+h,f=p*s+c,y=d*n+h,T=e.radialGradient(f,y,0,u,m,g);o.children.forEach(e=>{T.stop(e.props.offset,e.props.stopColor,e.props.stopOpacity)}),e.fill(T)}),setFillColor=e=>R.tap(t=>{const r=getProp$4(null,"fill",t);r&&e.fillColor(r)}),setFill=e=>R.cond([[hasLinearGradientFill,setLinearGradientFill(e)],[hasRadialGradientFill,setRadialGradientFill(e)],[R.T,setFillColor(e)]]),draw=e=>t=>{const r=R.propOr({},"props",t);return r.fill&&r.stroke?e.fillAndStroke(r.fillRule):r.fill?e.fill(r.fillRule):r.stroke?e.stroke():(e.save(),e.opacity(0),e.fill(null),e.restore()),t},renderNode=e=>R.cond([[isTspan,R.identity],[isTextInstance,R.identity],[isPath,renderPath(e)],[isRect,renderRect(e)],[isLine,renderLine(e)],[isGroup,renderGroup()],[isText,renderSvgText(e)],[isCircle,renderCircle(e)],[isImage,renderSvgImage(e)],[isEllipse,renderEllipse(e)],[isPolygon,renderPolygon(e)],[isPolyline,renderPolyline(e)],[R.T,warnUnsupportedNode]]),drawNode=e=>R.compose(draw(e),renderNode(e),applyTransformations$1(e),setOpacity(e),setFillOpacity(e),setStrokeOpacity(e),setFill(e),setStrokeColor(e),setStrokeWidth(e),setLineJoin(e),setLineDash(e),setLineCap(e)),clipPath=e=>t=>{const r=R.path(["props","clipPath"],t);return r&&R.compose(()=>e.clip(),R.forEach(renderNode(e)),R.propOr([],"children"))(r),t},drawChildren=e=>t=>R.compose(R.map(R.compose(restore$1(e),drawChildren(e),drawNode(e),clipPath(e),save$1(e))),R.propOr([],"children"))(t),defaultsZero=R.pathOr(0),preserveAspectRatio=e=>t=>{const{width:r,height:o}=t.box,{viewBox:i,preserveAspectRatio:a={}}=t.props,{meetOrSlice:s="meet",align:n="xMidYMid"}=a;if(null==i||null==r||null==o)return t;const l=i?i.minX:0,p=i?i.minY:0,d=i?i.maxX:r,c=i?i.maxY:o,h=d/c,g=r/o,R=r/d,u=o/c;if("none"===n)return e.scale(R,u),e.translate(-l,-p),t;if(h<g&&"meet"===s||h>=g&&"slice"===s)switch(e.scale(u,u),n){case"xMinYMin":case"xMinYMid":case"xMinYMax":e.translate(-l,-p);break;case"xMidYMin":case"xMidYMid":case"xMidYMax":e.translate(-l-(d-r*c/o)/2,-p);break;default:e.translate(-l-(d-r*c/o),-p)}else switch(e.scale(R,R),n){case"xMinYMin":case"xMidYMin":case"xMaxYMin":e.translate(-l,-p);break;case"xMinYMid":case"xMidYMid":case"xMaxYMid":e.translate(-l,-p-(c-o*d/r)/2);break;default:e.translate(-l,-p-(c-o*d/r))}return t},moveToOrigin=e=>t=>{const{top:r,left:o}=t.box,i=defaultsZero("paddingLeft",t.box),a=defaultsZero("paddingTop",t.box);return e.translate(o+i,r+a),t},renderSvg=(e,t)=>(R.compose(restore$1(e),drawChildren(e),preserveAspectRatio(e),moveToOrigin(e),clipNode$1(e),save$1(e))(t),t);var renderSvg$1=R.curryN(2,renderSvg);const renderText=(e,t)=>{const{top:r,left:o}=t.box,i=R.pathOr(0,["box","paddingTop"],t),a=R.pathOr(0,["box","paddingLeft"],t),s=t.lines[0]?t.lines[0].box.y:0;return e.save(),e.translate(o+a,r+i-s),PDFRenderer.render(e,[t.lines]),e.restore(),t};var renderText$1=R.curryN(2,renderText);const renderPage=(e,t)=>{const{width:r,height:o}=t.box;return e.addPage({size:[r,o],margin:0}),t};var renderPage$1=R.curryN(2,renderPage);const renderNote=(e,t)=>{const{top:r,left:o}=t.box,i=t.children[0]?t.children[0].value:"";return e.note(o,r,0,0,i),t};var renderNote$1=R.curryN(2,renderNote);const isPercent=e=>/((-)?\d+\.?\d*)%/g.exec(e),matchPercent=e=>{const t=isPercent(e);if(t){const e=parseFloat(t[1],10),r=e/100;return{value:e,percent:r,absValue:Math.abs(e),absPercent:Math.abs(r)}}return null},isNumeric=e=>!isNaN(parseFloat(e))&&isFinite(e),applyContainObjectFit=(e,t,r,o,i,a)=>{const s=e/t,n=r/o,l=matchPercent(i),p=matchPercent(a),d=l?l.percent:.5,c=p?p.percent:.5;if(s>n){const r=t,o=r*n,s=isNumeric(a)?a:0;return{width:o,height:r,xOffset:isNumeric(i)?i:(e-o)*d,yOffset:s}}{const r=e,o=r/n,s=isNumeric(i)?i:0;return{width:r,height:o,yOffset:isNumeric(a)?a:(t-o)*c,xOffset:s}}},applyNoneObjectFit=(e,t,r,o,i,a)=>{const s=r,n=o,l=matchPercent(i),p=matchPercent(a),d=l?l.percent:.5,c=p?p.percent:.5;return{width:s,height:n,xOffset:isNumeric(i)?i:(e-s)*d,yOffset:isNumeric(a)?a:(t-n)*c}},applyCoverObjectFit=(e,t,r,o,i,a)=>{const s=r/o,n=e/t,l=matchPercent(i),p=matchPercent(a),d=l?l.percent:.5,c=p?p.percent:.5;if(n>s){const r=e,o=r/s,n=isNumeric(i)?i:0;return{width:r,height:o,yOffset:isNumeric(a)?a:(t-o)*c,xOffset:n}}{const r=t*s;return{width:r,height:t,xOffset:isNumeric(i)?i:(e-r)*d,yOffset:isNumeric(a)?a:0}}},applyScaleDownObjectFit=(e,t,r,o,i,a)=>{const s=applyContainObjectFit(e,t,r,o,i,a),n=applyNoneObjectFit(e,t,r,o,i,a);return s.width<n.width?s:n},applyFillObjectFit=(e,t,r,o)=>({width:e,height:t,xOffset:matchPercent(r)?0:r||0,yOffset:matchPercent(o)?0:o||0}),resolveObjectFit=(e="fill",t,r,o,i,a,s)=>{switch(e){case"contain":return applyContainObjectFit(t,r,o,i,a,s);case"cover":return applyCoverObjectFit(t,r,o,i,a,s);case"none":return applyNoneObjectFit(t,r,o,i,a,s);case"scale-down":return applyScaleDownObjectFit(t,r,o,i,a,s);default:return applyFillObjectFit(t,r,a,s)}},drawImage$1=e=>t=>{const{left:r,top:o}=t.box,{opacity:i,objectPositionX:a,objectPositionY:s}=t.style,n=t.box.paddingLeft||0,l=t.box.paddingRight||0,p=t.box.paddingBottom||0,d=t.box.paddingLeft||0,{width:c,height:h,xOffset:g,yOffset:R}=resolveObjectFit(t.style.objectFit,t.box.width-d-l,t.box.height-n-p,t.image.width,t.image.height,a,s);return t.image.data&&(0!==c&&0!==h?e.fillOpacity(i||1).image(t.image.data,r+d+g,o+n+R,{width:c,height:h}):warning(!1,`Image with src '${t.props.src}' skipped due to invalid dimensions`)),t},renderImage$1=(e,t)=>(R.compose(restore$1(e),drawImage$1(e),clipNode$1(e),save$1(e))(t),t);var renderImage$2=R.curryN(2,renderImage$1);const availableMethods=["dash","clip","save","path","fill","font","text","rect","scale","moveTo","lineTo","stroke","rotate","circle","lineCap","opacity","ellipse","polygon","restore","lineJoin","fontSize","fillColor","lineWidth","translate","miterLimit","strokeColor","fillOpacity","roundedRect","strokeOpacity","bezierCurveTo","quadraticCurveTo","linearGradient","radialGradient"],painter=function(e){const t=availableMethods.reduce((r,o)=>({...r,[o]:(...r)=>(e[o](...r),t)}),{});return t},defaultsZero$1=R.pathOr(0),renderCanvas=(e,t)=>{const{top:r,left:o,width:i,height:a}=t.box,s=defaultsZero$1("paddingLeft",t.box),n=defaultsZero$1("paddingRight",t.box),l=defaultsZero$1("paddingTop",t.box),p=i-s-n,d=a-l-defaultsZero$1("paddingBottom",t.box);return warning(p&&d,"Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it."),e.save().translate(o+s,r+l),t.props.paint&&t.props.paint(painter(e),p,d),e.restore(),t};var renderCanvas$1=R.curryN(2,renderCanvas);const hasVerticalRuler=R.either(R.hasPath(["props","ruler"]),R.hasPath(["props","verticalRuler"])),hasHorizontalRuler=R.either(R.hasPath(["props","ruler"]),R.hasPath(["props","horizontalRuler"])),range=(e,t)=>Array.from({length:Math.ceil(e/t)},(e,r)=>r*t),matchPercentage=e=>{const t=matchPercent(e);return t?100/t.value:null},getVerticalSteps=e=>{const t=e.props.horizontalRulerSteps||e.props.rulerSteps||50;if("string"==typeof t){const r=matchPercentage(t);if(r){return(e.box.width-(hasVerticalRuler(e)?13:0))/r}throw new Error("Page: Invalid horizontal steps value")}return t},getHorizontalSteps=e=>{const t=e.props.verticalRulerSteps||e.props.rulerSteps||50;if("string"==typeof t){const r=matchPercentage(t);if(r){return(e.box.height-(hasVerticalRuler(e)?13:0))/r}throw new Error("Page: Invalid horizontal steps value")}return t},renderVerticalRuler=e=>t=>{const r=t.box.width,o=t.box.height,i=hasHorizontalRuler(t)?13:0,a=range(r,getVerticalSteps(t));return e.rect(i,0,r,13).fill("white").moveTo(i,13).lineTo(r,13).stroke("gray"),a.map(t=>{e.moveTo(i+t,0).lineTo(i+t,13).stroke("gray").fillColor("black").text(`${Math.round(t)}`,i+t+1,1),0!==t&&e.moveTo(i+t,13).lineTo(i+t,o).stroke("#ababab")}),t},renderHorizontalRuler=e=>t=>{const r=t.box.width,o=t.box.height,i=hasVerticalRuler(t)?13:0,a=range(o,getHorizontalSteps(t));return e.rect(0,i,13,o).fill("white").moveTo(13,hasHorizontalRuler(t)?13:0).lineTo(13,o).stroke("gray"),a.map(t=>{e.moveTo(0,i+t).lineTo(13,i+t).stroke("gray").fillColor("black").text(`${Math.round(t)}`,1,i+t+1),0!==t&&e.moveTo(13,i+t).lineTo(r,i+t).stroke("#ababab")}),t},renderRulers=(e,t)=>(e.save().lineWidth(.5).fontSize(6).opacity(1),R.compose(R.when(hasVerticalRuler,renderVerticalRuler(e)),R.when(hasHorizontalRuler,renderHorizontalRuler(e)))(t),e.restore(),t);var renderRulers$1=R.curryN(2,renderRulers);const getDocumentProp=e=>(t,r)=>R.pathOr(t,["props",r],e),setPDFMetadata=e=>(t,r)=>{r&&(e.info[t]=r)},addMetadata=(e,t)=>{const r=getDocumentProp(t),o=setPDFMetadata(e),i=r(null,"title"),a=r(null,"author"),s=r(null,"subject"),n=r(null,"keywords"),l=r("react-pdf","creator"),p=r("react-pdf","producer");return o("Title",i),o("Author",a),o("Subject",s),o("Keywords",n),o("Creator",l),o("Producer",p),t};var addMetadata$1=R.curryN(2,addMetadata);const CONTENT_COLOR="#a1c6e7",PADDING_COLOR="#c4deb9",MARGIN_COLOR="#f8cca1",shouldDebug=R.pathEq(["props","debug"],!0),debugContent=e=>R.tap(t=>{const{left:r,top:o,width:i,height:a,paddingLeft:s,paddingTop:n,paddingRight:l,paddingBottom:p,borderLeftWidth:d,borderTopWidth:c,borderRightWidth:h,borderBottomWidth:g}=t.box;e.fillColor("#a1c6e7").opacity(.5).rect(r+s+d,o+n+c,i-s-l-h-d,a-n-p-c-g).fill()}),debugPadding=e=>R.tap(t=>{const{left:r,top:o,width:i,height:a,paddingLeft:s,paddingTop:n,paddingRight:l,paddingBottom:p,borderLeftWidth:d,borderTopWidth:c,borderRightWidth:h,borderBottomWidth:g}=t.box;e.fillColor("#c4deb9").opacity(.5),e.rect(r+s+d,o+c,i-l-s-d-h,n).fill(),e.rect(r+d,o+c,s,a-c-g).fill(),e.rect(r+i-l-h,o+c,l,a-c-g).fill(),e.rect(r+s+d,o+a-p-g,i-l-s-d-h,p).fill()}),debugMargin=e=>R.tap(t=>{const{left:r,top:o,width:i,height:a,marginLeft:s,marginTop:n,marginRight:l,marginBottom:p}=t.box;e.fillColor("#f8cca1").opacity(.5),e.rect(r,o-n,i,n).fill(),e.rect(r-s,o-n,s,a+n+p).fill(),e.rect(r+i,o-n,l,a+n+p).fill(),e.rect(r,o+a,i,p).fill()}),debugText=e=>R.tap(t=>{const{left:r,top:o,width:i,height:a,marginLeft:s,marginTop:n,marginRight:l,marginBottom:p}=t.box,d=Math.round(i+s+l),c=Math.round(a+n+p);e.fontSize(4).opacity(1).fillColor("black").text(`${d} x ${c}`,r-s,Math.max(o-n-4,1))}),debugOrigin=e=>R.tap(t=>{t.origin&&e.circle(t.origin.left,t.origin.top,3).fill("red").circle(t.origin.left,t.origin.top,5).stroke("red")}),renderDebug=e=>R.tap(R.when(shouldDebug,R.compose(restore$1(e),debugOrigin(e),debugText(e),debugMargin(e),debugPadding(e),debugContent(e),save$1(e)))),KAPPA$3=(Math.sqrt(2)-1)/3*4,clipBorderTop=(e,t,r,o,i)=>{const{top:a,left:s,width:n,height:l}=t,{borderTopWidth:p,borderRightWidth:d,borderLeftWidth:c}=r;e.moveTo(s+i,a),e.lineTo(s+n-o,a);const h=o*(1-KAPPA$3);e.bezierCurveTo(s+n-h,a,s+n,a+h,s+n,a+o);const g=a+Math.max(p,o);e.lineTo(s+n,g),e.lineTo(s+n-d,g);const R=Math.max(o-d,0),u=Math.max(o-p,0),m=R*(1-KAPPA$3),f=u*(1-KAPPA$3);e.bezierCurveTo(s+n-d,a+p+f,s+n-d-m,a+p,s+n-d-R,a+p),e.lineTo(s+Math.max(i,c),a+p);const y=Math.max(i-c,0),T=Math.max(i-p,0),b=y*(1-KAPPA$3),P=T*(1-KAPPA$3),v=a+Math.max(p,i);e.bezierCurveTo(s+c+b,a+p,s+c,a+p+P,s+c,v),e.lineTo(s,v),e.lineTo(s,a+i);const x=i*(1-KAPPA$3);if(e.bezierCurveTo(s,a+x,s+x,a,s+i,a),e.closePath(),e.clip(),d){const t=-p/d;e.moveTo(s+n/2,t*(-n/2)+a),e.lineTo(s+n,a),e.lineTo(s,a),e.lineTo(s,a+l),e.closePath(),e.clip()}if(c){const t=-p/c;e.moveTo(s+n/2,t*(-n/2)+a),e.lineTo(s,a),e.lineTo(s+n,a),e.lineTo(s+n,a+l),e.closePath(),e.clip()}},fillBorderTop=(e,t,r,o,i)=>{const{top:a,left:s,width:n}=t,{borderTopColor:l,borderTopWidth:p,borderTopStyle:d,borderRightWidth:c,borderLeftWidth:h}=r,g=i*(1-KAPPA$3),R=o*(1-KAPPA$3);e.moveTo(s,a+Math.max(i,p)),e.bezierCurveTo(s,a+g,s+g,a,s+i,a),e.lineTo(s+n-o,a),e.bezierCurveTo(s+n-R,a,s+n,a+R,s+n,a+o),e.strokeColor(l),e.lineWidth(2*Math.max(c,p,h)),"dashed"===d?e.dash(2*p,{space:1.2*p}):"dotted"===d&&e.dash(p,{space:1.2*p}),e.stroke(),e.undash()},clipBorderRight=(e,t,r,o,i)=>{const{top:a,left:s,width:n,height:l}=t,{borderTopWidth:p,borderRightWidth:d,borderBottomWidth:c}=r;e.moveTo(s+n,a+o),e.lineTo(s+n,a+l-i);const h=i*(1-KAPPA$3);e.bezierCurveTo(s+n,a+l-h,s+n-h,a+l,s+n-i,a+l);const g=s+n-Math.max(d,i);e.lineTo(g,a+l),e.lineTo(g,a+l-c);const R=Math.max(i-d,0),u=Math.max(i-c,0),m=R*(1-KAPPA$3),f=u*(1-KAPPA$3);e.bezierCurveTo(s+n-d-m,a+l-c,s+n-d,a+l-c-f,s+n-d,a+l-Math.max(i,c)),e.lineTo(s+n-d,a+Math.max(o,p));const y=Math.max(o-d,0),T=Math.max(o-p,0),b=y*(1-KAPPA$3),P=T*(1-KAPPA$3),v=s+n-Math.max(o,d);e.bezierCurveTo(s+n-d,a+p+P,s+n-d-b,a+p,v,a+p),e.lineTo(v,a),e.lineTo(s+n-o,a);const x=o*(1-KAPPA$3);if(e.bezierCurveTo(s+n-x,a,s+n,a+x,s+n,a+o),e.closePath(),e.clip(),p){const t=-p/d;e.moveTo(s+n/2,t*(-n/2)+a),e.lineTo(s+n,a),e.lineTo(s+n,a+l),e.lineTo(s,a+l),e.closePath(),e.clip()}if(c){const t=c/d;e.moveTo(s+n/2,t*(-n/2)+a+l),e.lineTo(s+n,a+l),e.lineTo(s+n,a),e.lineTo(s,a),e.closePath(),e.clip()}},fillBorderRight=(e,t,r,o,i)=>{const{top:a,left:s,width:n,height:l}=t,{borderRightColor:p,borderRightStyle:d,borderRightWidth:c,borderTopWidth:h,borderBottomWidth:g}=r,R=i*(1-KAPPA$3),u=o*(1-KAPPA$3);e.moveTo(s+n-o,a),e.bezierCurveTo(s+n-u,a,s+n,a+u,s+n,a+o),e.lineTo(s+n,a+l-i),e.bezierCurveTo(s+n,a+l-R,s+n-R,a+l,s+n-i,a+l),e.strokeColor(p),e.lineWidth(2*Math.max(c,h,g)),"dashed"===d?e.dash(2*c,{space:1.2*c}):"dotted"===d&&e.dash(c,{space:1.2*c}),e.stroke(),e.undash()},clipBorderBottom=(e,t,r,o,i)=>{const{top:a,left:s,width:n,height:l}=t,{borderBottomWidth:p,borderRightWidth:d,borderLeftWidth:c}=r;e.moveTo(s+n-i,a+l),e.lineTo(s+o,a+l);const h=o*(1-KAPPA$3);e.bezierCurveTo(s+h,a+l,s,a+l-h,s,a+l-o);const g=a+l-Math.max(p,o);e.lineTo(s,g),e.lineTo(s+c,g);const R=Math.max(o-c,0),u=Math.max(o-p,0),m=R*(1-KAPPA$3),f=u*(1-KAPPA$3);e.bezierCurveTo(s+c,a+l-p-f,s+c+m,a+l-p,s+c+R,a+l-p),e.lineTo(s+n-Math.max(i,d),a+l-p);const y=Math.max(i-d,0),T=Math.max(i-p,0),b=y*(1-KAPPA$3),P=T*(1-KAPPA$3),v=a+l-Math.max(p,i);e.bezierCurveTo(s+n-d-b,a+l-p,s+n-d,a+l-p-P,s+n-d,v),e.lineTo(s+n,v),e.lineTo(s+n,a+l-i);const x=i*(1-KAPPA$3);if(e.bezierCurveTo(s+n,a+l-x,s+n-x,a+l,s+n-i,a+l),e.closePath(),e.clip(),d){const t=p/d;e.moveTo(s+n/2,t*(-n/2)+a+l),e.lineTo(s+n,a+l),e.lineTo(s,a+l),e.lineTo(s,a),e.closePath(),e.clip()}if(c){const t=-p/c;e.moveTo(s+n/2,t*(n/2)+a+l),e.lineTo(s,a+l),e.lineTo(s+n,a+l),e.lineTo(s+n,a),e.closePath(),e.clip()}},fillBorderBottom=(e,t,r,o,i)=>{const{top:a,left:s,width:n,height:l}=t,{borderBottomColor:p,borderBottomStyle:d,borderBottomWidth:c,borderRightWidth:h,borderLeftWidth:g}=r,R=o*(1-KAPPA$3),u=i*(1-KAPPA$3);e.moveTo(s+n,a+l-i),e.bezierCurveTo(s+n,a+l-u,s+n-u,a+l,s+n-i,a+l),e.lineTo(s+o,a+l),e.bezierCurveTo(s+R,a+l,s,a+l-R,s,a+l-o),e.strokeColor(p),e.lineWidth(2*Math.max(c,h,g)),"dashed"===d?e.dash(2*c,{space:1.2*c}):"dotted"===d&&e.dash(c,{space:1.2*c}),e.stroke(),e.undash()},clipBorderLeft=(e,t,r,o,i)=>{const{top:a,left:s,width:n,height:l}=t,{borderTopWidth:p,borderLeftWidth:d,borderBottomWidth:c}=r;e.moveTo(s,a+l-o),e.lineTo(s,a+i);const h=i*(1-KAPPA$3);e.bezierCurveTo(s,a+h,s+h,a,s+i,a);const g=s+Math.max(d,i);e.lineTo(g,a),e.lineTo(g,a+p);const R=Math.max(i-d,0),u=Math.max(i-p,0),m=R*(1-KAPPA$3),f=u*(1-KAPPA$3);e.bezierCurveTo(s+d+m,a+p,s+d,a+p+f,s+d,a+Math.max(i,p)),e.lineTo(s+d,a+l-Math.max(o,c));const y=Math.max(o-d,0),T=Math.max(o-c,0),b=y*(1-KAPPA$3),P=T*(1-KAPPA$3),v=s+Math.max(o,d);e.bezierCurveTo(s+d,a+l-c-P,s+d+b,a+l-c,v,a+l-c),e.lineTo(v,a+l),e.lineTo(s+o,a+l);const x=o*(1-KAPPA$3);if(e.bezierCurveTo(s+x,a+l,s,a+l-x,s,a+l-o),e.closePath(),e.clip(),c){const t=-c/d;e.moveTo(s+n/2,t*(n/2)+a+l),e.lineTo(s,a+l),e.lineTo(s,a),e.lineTo(s+n,a),e.closePath(),e.clip()}if(c){const t=-p/d;e.moveTo(s+n/2,t*(-n/2)+a),e.lineTo(s,a),e.lineTo(s,a+l),e.lineTo(s+n,a+l),e.closePath(),e.clip()}},fillBorderLeft=(e,t,r,o,i)=>{const{top:a,left:s,height:n}=t,{borderLeftColor:l,borderLeftStyle:p,borderLeftWidth:d,borderTopWidth:c,borderBottomWidth:h}=r,g=o*(1-KAPPA$3),R=i*(1-KAPPA$3);e.moveTo(s+o,a+n),e.bezierCurveTo(s+g,a+n,s,a+n-g,s,a+n-o),e.lineTo(s,a+i),e.bezierCurveTo(s,a+R,s+R,a,s+i,a),e.strokeColor(l),e.lineWidth(2*Math.max(d,c,h)),"dashed"===p?e.dash(2*d,{space:1.2*d}):"dotted"===p&&e.dash(d,{space:1.2*d}),e.stroke(),e.undash()},shouldRenderBorders=e=>e.box&&(e.box.borderTopWidth||e.box.borderRightWidth||e.box.borderBottomWidth||e.box.borderLeftWidth),renderBorders=(e,t)=>{if(!shouldRenderBorders(t))return t;const{width:r,height:o,borderTopWidth:i,borderLeftWidth:a,borderRightWidth:s,borderBottomWidth:n}=t.box,{opacity:l,borderTopLeftRadius:p=0,borderTopRightRadius:d=0,borderBottomLeftRadius:c=0,borderBottomRightRadius:h=0,borderTopColor:g="black",borderTopStyle:R="solid",borderLeftColor:u="black",borderLeftStyle:m="solid",borderRightColor:f="black",borderRightStyle:y="solid",borderBottomColor:T="black",borderBottomStyle:b="solid"}=t.style,P={borderTopColor:g,borderTopWidth:i,borderTopStyle:R,borderLeftColor:u,borderLeftWidth:a,borderLeftStyle:m,borderRightColor:f,borderRightWidth:s,borderRightStyle:y,borderBottomColor:T,borderBottomWidth:n,borderBottomStyle:b,borderTopLeftRadius:p,borderTopRightRadius:d,borderBottomLeftRadius:c,borderBottomRightRadius:h},v=Math.min(d,.5*r,.5*o),x=Math.min(p,.5*r,.5*o),E=Math.min(h,.5*r,.5*o),S=Math.min(c,.5*r,.5*o);return e.save(),e.strokeOpacity(l),i&&(e.save(),clipBorderTop(e,t.box,P,v,x),fillBorderTop(e,t.box,P,v,x),e.restore()),s&&(e.save(),clipBorderRight(e,t.box,P,v,E),fillBorderRight(e,t.box,P,v,E),e.restore()),n&&(e.save(),clipBorderBottom(e,t.box,P,S,E),fillBorderBottom(e,t.box,P,S,E),e.restore()),a&&(e.save(),clipBorderLeft(e,t.box,P,S,x),fillBorderLeft(e,t.box,P,S,x),e.restore()),e.restore(),t};var renderBorders$1=R.curryN(2,renderBorders);const setDestination=e=>R.tap(t=>{t.props.id&&e.addNamedDestination(t.props.id,"XYZ",null,t.box.top,null)}),drawBackground=e=>t=>{if(t.box&&t.style.backgroundColor){const{top:r,left:o,width:i,height:a}=t.box;e.fillOpacity(t.style.opacity||1).fillColor(t.style.backgroundColor).rect(o,r,i,a).fill()}return t},shouldRenderBackground=R.hasPath(["style","backgroundColor"]),renderBackground=(e,t)=>(R.when(shouldRenderBackground,R.compose(restore$1(e),drawBackground(e),clipNode$1(e),save$1(e)))(t),t);var renderBackground$1=R.curryN(2,renderBackground);const shouldRenderChildren=e=>!isText(e)&&!isSvg(e),renderChildren=e=>t=>(save$1(e,t),e.translate(t.box.left,t.box.top),R.compose(R.forEach(renderNode$1(e)),R.pathOr([],["children"]))(t),restore$1(e,t),t),renderNode$1=e=>t=>R.compose(restore$1(e),renderDebug(e),setDestination(e),R.when(shouldRenderChildren,renderChildren(e)),R.when(R.either(isText,isLink),setLink$1(e)),R.cond([[isText,renderText$1(e)],[isNote,renderNote$1(e)],[isImage,renderImage$2(e)],[isCanvas,renderCanvas$1(e)],[isSvg,renderSvg$1(e)],[R.T,R.identity]]),renderBorders$1(e),renderBackground$1(e),applyTransformations$1(e),save$1(e),R.when(isPage,renderPage$1(e)))(t),renderDocument=e=>R.compose(R.forEach(R.compose(renderRulers$1(e),renderNode$1(e))),R.pathOr([],["children"])),render=(e,t)=>(addMetadata$1(e)(t),renderDocument(e)(t),e.end(),Font$1.reset(),e),capitalize=e=>e?e.replace(/(^|\s)\S/g,e=>e.toUpperCase()):e,upperFirst=R.ifElse(R.isNil,R.identity,R.compose(R.join(""),R.juxt([R.compose(R.toUpper,R.head),R.tail])));var upperFirst$1=R.memoizeWith(R.identity,upperFirst);const transformText=(e,t)=>{switch(t){case"uppercase":return e.toUpperCase();case"lowercase":return e.toLowerCase();case"capitalize":return capitalize(e);case"upperfirst":return upperFirst$1(e);default:return e}};class StandardFont{constructor(e){this.name=e,this.src=PDFDocument.PDFFont.open(null,e)}layout(e){const[t,r]=this.src.encode(e);return{positions:r,stringIndices:r.map((e,t)=>t),glyphs:t.map((e,t)=>{const o=this.getGlyph(parseInt(e,16));return o.advanceWidth=r[t].advanceWidth,o})}}glyphForCodePoint(e){const t=this.getGlyph(e);return t.advanceWidth=400,t}getGlyph(e){return{id:e,_font:this.src,codePoints:[e],isLigature:!1,name:this.src.font.characterToGlyph(e)}}hasGlyphForCodePoint(e){return".notdef"!==this.src.font.characterToGlyph(e)}get ascent(){return 900}get descent(){switch(this.name){case"Times-Roman":case"Times-Bold":case"Times-Italic":return-220;case"Courier":case"Courier-Bold":case"Courier-Oblique":return-230;default:return-200}}get lineGap(){return 0}get unitsPerEm(){return 1e3}}const fontCache={},IGNORED_CODE_POINTS=[173],getFontSize=R.pathOr(12,["attributes","fontSize"]),getOrCreateFont=e=>{if(fontCache[e])return fontCache[e];const t=new StandardFont(e);return fontCache[e]=t,t},getFallbackFont=()=>getOrCreateFont("Helvetica"),shouldFallbackToFont=(e,t)=>!IGNORED_CODE_POINTS.includes(e)&&!t.hasGlyphForCodePoint(e)&&getFallbackFont().hasGlyphForCodePoint(e),fontSubstitution=()=>({string:e,runs:t})=>{let r=null,o=0,i=0;const a=[];for(const s of t){const t=getFontSize(s),n="string"==typeof s.attributes.font?getOrCreateFont(s.attributes.font):s.attributes.font;if(0===e.length){a.push({start:0,end:0,attributes:{font:n}});break}for(const l of e.slice(s.start,s.end)){const e=l.codePointAt(),s=shouldFallbackToFont(e,n)?getFallbackFont():n;s!==r&&(r&&a.push({start:o,end:i,attributes:{font:r,scale:r?t/r.unitsPerEm:0}}),r=s,o=i),i+=l.length}}if(o<e.length){const i=getFontSize(R.last(t));a.push({start:o,end:e.length,attributes:{font:r,scale:r?i/r.unitsPerEm:0}})}return{string:e,runs:a}},engines={linebreaker:linebreaker,justification:justification,textDecoration:textDecoration,scriptItemizer:scriptItemizer,wordHyphenation:wordHyphenation,fontSubstitution:fontSubstitution},engine=layoutEngine(engines),layoutOptions={hyphenationCallback:Font$1.getHyphenationCallback(),shrinkWhitespaceFactor:{before:-.5,after:-.5}},getFragments=e=>{if(!e)return[{string:""}];const t=[],{fill:r="black",fontFamily:o="Helvetica",fontWeight:i,fontStyle:a,fontSize:s=18,textDecoration:n,textDecorationColor:l,textDecorationStyle:p,textTransform:d,opacity:c}=e.props,h=Font$1.getFont({fontFamily:o,fontWeight:i,fontStyle:a}),g={font:h?h.data:o,opacity:c,fontSize:s,color:r,underlineStyle:p,underline:"underline"===n,underlineColor:l||r,strike:"line-through"===n,strikeStyle:p,strikeColor:l||r};return e.children.forEach(e=>{isTextInstance(e)?t.push({string:transformText(e.value,d),attributes:g}):e&&t.push(...getFragments(e))}),t},getAttributedString=e=>AttributedString.fromFragments(getFragments(e)),AlmostInfinity=999999999999,layoutTspan=e=>{const t=getAttributedString(e),r={x:R.pathOr(0,["props","x"],e),y:R.pathOr(0,["props","y"],e),width:999999999999,height:999999999999},o=R.compose(R.reduce(R.concat,[]),engine)(t,r,layoutOptions);return R.assoc("lines",o,e)},layoutText=R.evolve({children:R.map(layoutTspan)}),isDefs=R.propEq("type",DEFS),getChildren=R.propOr([],"children"),getId=R.path(["props","id"]),getDefs=R.compose(R.map(R.prop(0)),R.groupBy(getId),getChildren,R.defaultTo({}),R.find(isDefs),getChildren),isNotDefs=R.complement(isDefs),detachDefs=R.evolve({children:R.filter(isNotDefs)}),URL_REGEX=/url\(['"]?#([^'"]+)['"]?\)/,replaceDef=e=>R.compose(R.when(R.test(URL_REGEX),R.compose(R.prop(R.__,e),R.prop(1),R.match(URL_REGEX))),R.defaultTo("")),parseNodeDefs=e=>t=>R.compose(R.evolve({props:R.evolve({fill:replaceDef(e),clipPath:replaceDef(e)})}),R.evolve({children:R.map(parseNodeDefs(e))}))(t),parseDefs=e=>{const t=getDefs(e);return R.evolve({children:R.map(parseNodeDefs(t))},e)},replaceDefs=R.compose(detachDefs,parseDefs),parseViewbox=e=>{if(!e)return null;const t=e.split(/[,\s]+/).map(parseFloat);return 4!==t.length?null:{minX:t[0],minY:t[1],maxX:t[2],maxY:t[3]}},getContainer=e=>{const t=parseViewbox(e.props.viewBox);return t?{width:t.maxX,height:t.maxY}:e.props.width&&e.props.height?{width:parseFloat(e.props.width),height:parseFloat(e.props.height)}:{width:0,height:0}},getInheritProps=R.compose(R.pick(SVG_INHERITED_PROPS),R.propOr({},"props")),inheritProps=e=>{const t=getInheritProps(e);return R.evolve({children:R.map(R.compose(inheritProps,R.evolve({props:R.merge(t)})))})(e)},parseAspectRatio=e=>{const t=e.replace(/[\s\r\t\n]+/gm," ").replace(/^defer\s/,"").split(" ");return{align:t[0]||"xMidYMid",meetOrSlice:t[1]||"meet"}},isRgb=R.test(/rgb/g),isRgba=R.test(/rgba/g),isHsl=R.test(/hsl/g),isHsla=R.test(/hsla/g),parseRgb=R.compose(colorString.to.hex,colorString.get.rgb),parseHsl=R.compose(R.toUpper,R.apply(hlsToHex),R.map(Math.round),colorString.get.hsl),transformColor=e=>R.cond([[isRgba,parseRgb],[isRgb,parseRgb],[isHsla,parseHsl],[isHsl,parseHsl],[R.T,R.always(e)]])(e),transformColors=e=>R.map(transformColor,e),STYLE_PROPS=["width","height","color","stroke","strokeWidth","opacity","fillOpacity","strokeOpacity","fill","fillRule","clipPath","offset","transform","strokeLinejoin","strokeLinecap","strokeDasharray"],VERTICAL_PROPS=["y","y1","y2","height","cy","ry"],HORIZONTAL_PROPS=["x","x1","x2","width","cx","rx"],transformPercent=e=>R.mapObjIndexed((t,r)=>{const o=matchPercent(t);return o&&VERTICAL_PROPS.includes(r)?o.percent*e.height:o&&HORIZONTAL_PROPS.includes(r)?o.percent*e.width:t}),parsePercent=e=>{const t=matchPercent(e);return t?t.percent:parseFloat(e)},parseProps=e=>R.compose(R.evolve({props:R.o(R.evolve({x:parseFloat,x1:parseFloat,x2:parseFloat,y:parseFloat,y1:parseFloat,y2:parseFloat,r:parseFloat,rx:parseFloat,ry:parseFloat,cx:parseFloat,cy:parseFloat,width:parseFloat,height:parseFloat,offset:parsePercent,fill:transformColor,opacity:parsePercent,stroke:transformColor,stopOpacity:parsePercent,stopColor:transformColor}),transformPercent(e))})),mergeStyles=e=>{const t=R.propOr({},"style",e);return R.evolve({props:R.merge(t)},e)},removeNoneValues=R.evolve({props:R.map(R.when(R.equals("none"),R.always(null)))}),pickStyleProps=e=>{const t=R.o(R.pick(STYLE_PROPS),R.propOr({},"props"))(e);return R.evolve({style:R.merge(t)},e)},parseSvgProps=R.evolve({props:R.evolve({width:parseFloat,height:parseFloat,viewBox:parseViewbox,preserveAspectRatio:parseAspectRatio})}),wrapBetweenTspan=e=>({type:"TSPAN",props:{},children:[e]}),addMissingTspan=R.when(isText,R.evolve({children:R.map(R.when(isTextInstance,wrapBetweenTspan))})),resolveSvgNode=e=>R.compose(parseProps(e),addMissingTspan,removeNoneValues,mergeStyles),resolveChildren=e=>t=>R.evolve({children:R.map(R.compose(resolveChildren(e),resolveSvgNode(e)))})(t),parseText=e=>R.ifElse(isText,layoutText,R.evolve({children:R.map(parseText)}))(e),resolveSvgRoot=e=>{const t=getContainer(e);return R.compose(replaceDefs,parseText,parseSvgProps,pickStyleProps,inheritProps,resolveChildren(t))(e)},resolveSvg=e=>R.compose(R.evolve({children:R.map(resolveSvg)}),R.when(isSvg,resolveSvgRoot))(e),getZIndex=R.path(["style","zIndex"]),isType=R.propEq("type"),shouldNotSort=R.anyPass([isType(DOCUMENT),isType(SVG)]),sortZIndex=(e,t)=>{const r=getZIndex(e),o=getZIndex(t);return r||o?r?o?o-r:-1:1:0},resolveZIndex=e=>R.compose(R.evolve({children:R.map(resolveZIndex)}),R.unless(shouldNotSort,R.evolve({children:R.sort(sortZIndex)})))(e),adjustPageSize=R.compose(R.when(hasVerticalRuler,R.evolve({box:{height:R.add(13)},children:R.map(R.evolve({box:{top:R.add(13)}}))})),R.when(hasHorizontalRuler,R.evolve({box:{width:R.add(13)},children:R.map(R.evolve({box:{left:R.add(13)}}))}))),resolveRulers=R.evolve({children:R.map(adjustPageSize)});PNG.isValid=function(e){try{return!!new PNG(e)}catch(e){return!1}};const MARKERS=[65472,65473,65474,65475,65477,65478,65479,65480,65481,65482,65483,65484,65485,65486,65487];class JPEG{constructor(e){if(this.data=null,this.width=null,this.height=null,this.data=e,65496!==e.readUInt16BE(0))throw new Error("SOI not found in JPEG");let t,r=2;for(;r<e.length&&(t=e.readUInt16BE(r),r+=2,!MARKERS.includes(t));)r+=e.readUInt16BE(r);if(!MARKERS.includes(t))throw new Error("Invalid JPEG.");r+=3,this.height=e.readUInt16BE(r),r+=2,this.width=e.readUInt16BE(r)}}JPEG.isValid=function(e){if(!e||!Buffer.isBuffer(e)||65496!==e.readUInt16BE(0))return!1;let t,r=2;for(;r<e.length&&(t=e.readUInt16BE(r),r+=2,!MARKERS.includes(t));)r+=e.readUInt16BE(r);return!!MARKERS.includes(t)};const createCache=({limit:e=100}={})=>{let t={},r=[];return{get:e=>t[e],set:(o,i)=>{r.push(o),r.length>e&&delete t[r.shift()],t[o]=i},reset:()=>{t={},r=[]},length:()=>r.length}},IMAGE_CACHE=createCache({limit:30}),getAbsoluteLocalPath=e=>{const{protocol:t,auth:r,host:o,port:i,hostname:a,path:s}=url.parse(e),n=path.resolve(s);if(!(t&&"file:"!==t||r||o||i||a))return n},fetchLocalFile=e=>new Promise((t,r)=>{try{const o=getAbsoluteLocalPath(e);if(!o)return r(new Error(`Cannot fetch non-local path: ${e}`));fs.readFile(o,(e,o)=>e?r(e):t(o))}catch(e){r(e)}}),fetchRemoteFile=async(e,t)=>{const r=await fetch(e,t),o=await(r.buffer?r.buffer():r.arrayBuffer());return"Buffer"===o.constructor.name?o:Buffer.from(o)},isValidFormat=e=>{const t=e.toLowerCase();return"jpg"===t||"jpeg"===t||"png"===t},guessFormat=e=>{let t;return JPEG.isValid(e)?t="jpg":PNG.isValid(e)&&(t="png"),t},isCompatibleBase64=({uri:e})=>/^data:image\/[a-zA-Z]*;base64,[^"]*/g.test(e);function getImage(e,t){switch(t.toLowerCase()){case"jpg":case"jpeg":return new JPEG(e);case"png":return new PNG(e);default:return null}}const resolveBase64Image=({uri:e})=>{const t=/^data:image\/([a-zA-Z]*);base64,([^"]*)/g.exec(e),r=t[1],o=t[2];if(!isValidFormat(r))throw new Error(`Base64 image invalid format: ${r}`);return new Promise(e=>e(getImage(Buffer.from(o,"base64"),r)))},resolveImageFromData=e=>{if(e.data&&e.format)return new Promise(t=>t(getImage(e.data,e.format)));throw new Error(`Invalid data given for local file: ${JSON.stringify(e)}`)},resolveBufferImage=e=>{const t=guessFormat(e);if(t)return new Promise(r=>r(getImage(e,t)))},getImageFormat=e=>{const t=137===e[0]&&80===e[1]&&78===e[2]&&71===e[3]&&13===e[4]&&10===e[5]&&26===e[6]&&10===e[7],r=255===e[0]&&216===e[1]&&255===e[2];let o="";if(t)o="png";else{if(!r)throw new Error("Not valid image extension");o="jpg"}return o},resolveImageFromUrl=async e=>{const{uri:t,body:r,headers:o,method:i="GET"}=e,a=getAbsoluteLocalPath(t)?await fetchLocalFile(t):await fetchRemoteFile(t,{body:r,headers:o,method:i});return getImage(a,getImageFormat(a))},resolveImage=(e,{cache:t=!0}={})=>{const r=e.data?e.data.toString():e.uri;if(t&&IMAGE_CACHE.get(r))return IMAGE_CACHE.get(r);let o;if(!(o=isCompatibleBase64(e)?resolveBase64Image(e):Buffer.isBuffer(e)?resolveBufferImage(e):"object"==typeof e&&e.data?resolveImageFromData(e):resolveImageFromUrl(e)))throw new Error("Cannot resolve image");return t&&IMAGE_CACHE.set(r,o),o},isNotNil=R.complement(R.isNil),firstPass=(...e)=>t=>{let r;for(const o of e)if(r=o(t),isNotNil(r))return r;return r},getSource$1=R.compose(R.when(R.is(String),e=>({uri:e})),firstPass(R.path(["props","src"]),R.path(["props","source"]),R.path(["props","href"]))),resolveSrc=async e=>"function"==typeof e?{uri:await e()}:e,fetchImage=async e=>{const t=getSource$1(e),{cache:r}=e.props;if(t)try{const o=await resolveSrc(t);e.image=await resolveImage(o,{cache:r})}catch(t){e.image={width:0,height:0},console.warn(t.message)}else warning(!1,'Image should receive either a "src" or "source" prop')},emojis={},regex=emojiRegex(),reflect=e=>(...t)=>e(...t).then(e=>e,e=>e),makeFetchEmojiImage=()=>reflect(resolveImage),_removeNoColor=e=>"️"!==e,getCodePoints=e=>Array.from(e).filter(_removeNoColor).map(e=>e.codePointAt(0).toString(16)).join("-"),buildEmojiUrl=e=>{const{url:t,format:r}=Font$1.getEmojiSource();return`${t}${getCodePoints(e)}.${r}`},fetchEmojis=e=>{const t=Font$1.getEmojiSource();if(!t||!t.url)return[];const r=[];let o;for(;o=regex.exec(e);){const e=o[0];if(!emojis[e]||emojis[e].loading){const t=buildEmojiUrl(e);emojis[e]={loading:!0};const o=makeFetchEmojiImage();r.push(o({uri:t}).then(t=>{emojis[e].loading=!1,emojis[e].data=t.data}))}}return r},embedEmojis=e=>{const t=[];for(let r=0;r<e.length;r++){const o=e[r];let i,a=0;for(;i=regex.exec(o.string);){const e=i.index,r=i[0],s=o.attributes.fontSize,n=o.string.slice(a,e+i[0].length);emojis[r]&&emojis[r].data?t.push({string:n.replace(i,String.fromCharCode(65532)),attributes:{...o.attributes,attachment:{width:s,height:s,yOffset:Math.floor(.1*s),image:emojis[r].data}}}):t.push({string:n.replace(i,String.fromCharCode(0)),attributes:o.attributes}),a=e+r.length}a<o.string.length&&t.push({string:o.string.slice(a),attributes:o.attributes})}return t},fetchAssets=e=>{const t=[],r=e.children.slice(0);for(;r.length>0;){const e=r.shift();isImage(e)&&t.push(fetchImage(e)),e.style&&e.style.fontFamily&&t.push(Font$1.load(e.style)),"string"==typeof e&&t.push(...fetchEmojis(e)),"string"==typeof e.value&&t.push(...fetchEmojis(e.value)),e.children&&e.children.forEach(e=>{r.push(e)})}return t},resolveAssets=e=>R.compose(R.then(R.always(e)),e=>Promise.all(e),fetchAssets)(e),isNotArray=R.complement(R.is(Array)),castArray=R.when(isNotArray,e=>[e]),compact=R.filter(Boolean),isArray=R.is(Array),mergeStyles$1=e=>e.reduce((e,t)=>{const r=isArray(t)?flatten(t):t;return Object.keys(r).forEach(t=>{null!==r[t]&&void 0!==r[t]&&(e[t]=r[t])}),e},{}),flatten=R.compose(mergeStyles$1,compact,castArray),hasOwnProperty=Object.prototype.hasOwnProperty,styleShorthands={margin:{marginTop:!0,marginRight:!0,marginBottom:!0,marginLeft:!0},marginHorizontal:{marginLeft:!0,marginRight:!0},marginVertical:{marginTop:!0,marginBottom:!0},padding:{paddingTop:!0,paddingRight:!0,paddingBottom:!0,paddingLeft:!0},paddingHorizontal:{paddingLeft:!0,paddingRight:!0},paddingVertical:{paddingTop:!0,paddingBottom:!0},border:{borderTopColor:!0,borderTopStyle:!0,borderTopWidth:!0,borderRightColor:!0,borderRightStyle:!0,borderRightWidth:!0,borderBottomColor:!0,borderBottomStyle:!0,borderBottomWidth:!0,borderLeftColor:!0,borderLeftStyle:!0,borderLeftWidth:!0},borderTop:{borderTopColor:!0,borderTopStyle:!0,borderTopWidth:!0},borderRight:{borderRightColor:!0,borderRightStyle:!0,borderRightWidth:!0},borderBottom:{borderBottomColor:!0,borderBottomStyle:!0,borderBottomWidth:!0},borderLeft:{borderLeftColor:!0,borderLeftStyle:!0,borderLeftWidth:!0},borderColor:{borderTopColor:!0,borderRightColor:!0,borderBottomColor:!0,borderLeftColor:!0},borderRadius:{borderTopLeftRadius:!0,borderTopRightRadius:!0,borderBottomRightRadius:!0,borderBottomLeftRadius:!0},borderStyle:{borderTopStyle:!0,borderRightStyle:!0,borderBottomStyle:!0,borderLeftStyle:!0},borderWidth:{borderTopWidth:!0,borderRightWidth:!0,borderBottomWidth:!0,borderLeftWidth:!0},objectPosition:{objectPositionX:!0,objectPositionY:!0},transformOrigin:{transformOriginX:!0,transformOriginY:!0},flex:{flexGrow:!0,flexShrink:!0,flexBasis:!0}},expandStyles=e=>{if(!e)return e;const t=Object.keys(e),r={};for(let o=0;o<t.length;o++){const i=t[o],a=e[i];if(styleShorthands[i]){const e=styleShorthands[i];for(const t in e)hasOwnProperty.call(e,t)&&(r[t]=a)}else r[i]=a}return r},MM_FACTOR=1/25.4*72,CM_FACTOR=1/2.54*72,parseValue=e=>{const t=/^(-?\d*\.?\d+)(in|mm|cm|pt|vh|vw|px)?$/g.exec(e);return t?{value:parseFloat(t[1],10),unit:t[2]||"pt"}:{value:e,unit:void 0}},transformUnit=R.curryN(2,(e,t)=>{const r=parseValue(t);switch(r.unit){case"in":return 72*r.value;case"mm":return r.value*(1/25.4*72);case"cm":return r.value*(1/2.54*72);case"vh":return r.value*(e.height/100);case"vw":return r.value*(e.width/100);default:return r.value}}),transformUnits=(e,t)=>R.map(transformUnit(e),t);var transformUnits$1=R.curryN(2,transformUnits);const resolveMediaQueries=(e,t)=>Object.keys(t).reduce((r,o)=>/@media/.test(o)?{...r,...matchMedia({[o]:t[o]},e)}:{...r,[o]:t[o]},{});var resolveMediaQueries$1=R.curryN(2,resolveMediaQueries);const LINK_STYLES={color:"blue",textDecoration:"underline"},filterNoneValues=R.reject(R.equals("none")),resolveStyles=e=>R.compose(transformUnits$1(e),transformColors,transformStyles,expandStyles,resolveMediaQueries$1(e),filterNoneValues,flatten),resolveNodeStyles=e=>t=>R.o(R.when(isLink,R.evolve({style:R.merge(LINK_STYLES)})),R.evolve({style:resolveStyles(e),children:R.map(resolveNodeStyles(e))}))(t),resolvePageStyles=e=>{const t=R.prop("box",e),r=R.prop("style",e),o=R.isEmpty(t)?r:t;return R.evolve({style:resolveStyles(o),children:R.map(resolveNodeStyles(o))})(e)};var resolveStyles$1=R.evolve({children:R.map(resolvePageStyles)});const getTransformStyle=e=>R.pathOr("50%",["style",e]),getOrigin=e=>{if(!e.box)return{};const{left:t,top:r,width:o,height:i}=e.box,a=getTransformStyle("transformOriginX")(e),s=getTransformStyle("transformOriginY")(e),n=matchPercent(a),l=matchPercent(s);return{left:t+(n?o*n.percent:a),top:r+(l?i*l.percent:s)}},resolveNodeOrigin=e=>R.compose(R.evolve({children:R.map(resolveNodeOrigin)}),R.converge(R.assoc("origin"),[getOrigin,R.identity]))(e),resolveOrigin=R.evolve({children:R.map(resolveNodeOrigin)}),VALID_ORIENTATIONS=[PORTRAIT,LANDSCAPE],getOrientation=R.compose(R.ifElse(R.includes(R.__,VALID_ORIENTATIONS),R.identity,R.always(PORTRAIT)),R.pathOr(PORTRAIT,["props","orientation"])),isLandscape=R.compose(R.equals(LANDSCAPE),getOrientation),toSizeObject=R.applySpec({width:R.prop(0),height:R.prop(1)}),flipSizeObject=R.applySpec({width:R.prop("height"),height:R.prop("width")}),getStringSize=R.compose(toSizeObject,R.prop(R.__,PAGE_SIZES),R.toUpper),getNumberSize=R.compose(toSizeObject,e=>[e]),throwInvalidError=e=>{throw new Error(`Invalid Page size: ${JSON.stringify(e)}`)},getSize=e=>{const t=R.compose(R.cond([[R.is(String),getStringSize],[R.is(Array),toSizeObject],[R.is(Number),getNumberSize],[R.is(Object),R.identity],[R.T,throwInvalidError]]),R.pathOr("A4",["props","size"]))(e);return isLandscape(e)?flipSizeObject(t):t},assocIfNil=(e,t,r)=>R.when(R.compose(R.isNil,R.prop(e)),R.assoc(e,t))(r);var assocIfNil$1=R.curryN(3,assocIfNil);const resolvePageSize=e=>{const t=getSize(e);return R.evolve({style:R.merge(R.__,t)})(e)},resolvePageSizes=R.evolve({children:R.map(R.compose(resolvePageSize,assocIfNil$1("style",{})))}),lineIndexAtHeight=(e,t)=>{let r=0;if(!e.lines)return 0;for(let o=0;o<e.lines.length;o++){const i=e.lines[o];if(r+i.box.height>t)return o;r+=i.box.height}return e.lines.length},heightAtLineIndex=(e,t)=>{let r=0;if(!e.lines)return r;for(let o=0;o<t;o++){const t=e.lines[o];if(!t)break;r+=t.box.height}return r},zero=R.always(0),getTop=R.pathOr(0,["box","top"]),getWidows=R.pathOr(2,["props","widows"]),getOrphans=R.pathOr(2,["props","orphans"]),getLineBreak=(e,t)=>{const r=getTop(e),o=getWidows(e),i=getOrphans(e),a=e.lines.length,s=lineIndexAtHeight(e,t-r);return 0===s?0:a<i?a:s<i||a<i+o?0:a===i+o?i:a-s<o?a-o:s},splitText=(e,t)=>{const r=getLineBreak(e,t),o=heightAtLineIndex(e,r),i=e.box.height-o;return[R.evolve({lines:R.slice(0,r),style:R.evolve({marginBottom:zero,paddingBottom:zero,borderBottomWidth:zero,borderBottomLeftRadius:zero,borderBottomRightRadius:zero}),box:{height:R.always(o),borderBottomWidth:zero}},e),R.evolve({lines:R.slice(r,1/0),style:R.evolve({marginTop:zero,paddingTop:zero,borderTopWidth:zero,borderTopLeftRadius:zero,borderTopRightRadius:zero}),box:{top:zero,height:R.always(i),borderTopWidth:zero}},e)]},zero$1=R.always(0),getTop$1=R.pathOr(0,["box","top"]),hasFixedHeight=R.hasPath(["style","height"]),subtractHeight=e=>R.o(R.subtract(R.__,e),R.path(["box","height"])),splitNode=(e,t)=>{if(!e)return[null,null];const r=getTop$1(e),o=R.evolve({style:R.evolve({marginBottom:zero$1,paddingBottom:zero$1,borderBottomWidth:zero$1,borderBottomLeftRadius:zero$1,borderBottomRightRadius:zero$1}),box:{height:R.always(t-r),borderBottomWidth:zero$1}})(e),i=R.ifElse(hasFixedHeight,subtractHeight(t-r),R.always(null))(e);return[o,R.evolve({style:R.evolve({marginTop:zero$1,paddingTop:zero$1,borderTopWidth:zero$1,borderTopLeftRadius:zero$1,borderTopRightRadius:zero$1}),box:{top:zero$1,height:R.always(i),borderTopWidth:zero$1}})(e)]},isString=R.is(String),isNumber$1=R.is(Number),isNotString=R.complement(isString),createInstance=e=>{if(isString(e)||isNumber$1(e))return{type:TEXT_INSTANCE,value:`${e}`};if(isNotString(e.type))return createInstance(e.type(e.props));const{type:t,props:{style:r={},children:o=[],...i}}=e;return{type:t,style:r,props:i,box:{},children:R.compose(R.map(createInstance),castArray)(o)}},getNodesHeight=e=>{let t=0,r=1/0;if(R.isEmpty(e))return 0;for(let o=0;o<e.length;o++){const i=e[o];r=Math.min(r,i.box.top),t=Math.max(t,i.box.top+i.box.height)}return t-r},getWrap=R.ifElse(R.anyPass([isSvg,isNote,isImage,isCanvas]),R.always(!1),R.pathOr(!0,["props","wrap"])),getBreak=R.pathOr(!1,["props","break"]),getMinPresenceAhead=R.path(["props","minPresenceAhead"]),defaultPresenceAhead=e=>t=>Math.min(e.box.height,t),getPresenceAhead=(e,t)=>{let r=0;for(let o=0;o<e.length;o++){const i=e[o];if(!i.box)continue;const a=t>i.box.top,s=i.props.presenceAhead||defaultPresenceAhead(i);i&&a&&(r+=s(t-i.box.top))}return r},shouldBreak=(e,t,r)=>{const o=getMinPresenceAhead(e),i=getPresenceAhead(t,r),a=getNodesHeight(t),s=r<e.box.top+e.box.height,n=getWrap(e);return getBreak(e)||!n&&s||o<a&&i<o},getComputedPadding=e=>t=>{const r=t._yogaNode;return r?r.getComputedPadding(e):null},getPadding=R.applySpec({paddingTop:firstPass(getComputedPadding(Yoga.EDGE_TOP),R.path(["box","paddingTop"]),R.path(["style","paddingTop"]),R.path(["style","paddingVertical"]),R.path(["style","padding"]),R.always(0)),paddingRight:firstPass(getComputedPadding(Yoga.EDGE_RIGHT),R.path(["box","paddingRight"]),R.path(["style","paddingRight"]),R.path(["style","paddingHorizontal"]),R.path(["style","padding"]),R.always(0)),paddingBottom:firstPass(getComputedPadding(Yoga.EDGE_BOTTOM),R.path(["box","paddingBottom"]),R.path(["style","paddingBottom"]),R.path(["style","paddingVertical"]),R.path(["style","padding"]),R.always(0)),paddingLeft:firstPass(getComputedPadding(Yoga.EDGE_LEFT),R.path(["box","paddingLeft"]),R.path(["style","paddingLeft"]),R.path(["style","paddingHorizontal"]),R.path(["style","padding"]),R.always(0))}),getContentArea=e=>{const{paddingTop:t}=getPadding(e);return R.path(["style","height"],e)-t},IGNORABLE_CODEPOINTS=[8232,8233],buildSubsetForFont=e=>IGNORABLE_CODEPOINTS.reduce((t,r)=>e.hasGlyphForCodePoint&&e.hasGlyphForCodePoint(r)?t:[...t,String.fromCharCode(r)],[]),ignoreChars=e=>e.map(e=>{const t=buildSubsetForFont(e.attributes.font),r=new RegExp(t.join("|"));return{string:e.string.replace(r,""),attributes:e.attributes}}),PREPROCESSORS=[ignoreChars,embedEmojis],getFragments$1=e=>{if(!e)return[{string:""}];let t=[];const{color:r="black",backgroundColor:o,fontFamily:i="Helvetica",fontWeight:a,fontStyle:s,fontSize:n=18,textAlign:l="left",lineHeight:p,textDecoration:d,textDecorationColor:c,textDecorationStyle:h,textTransform:g,letterSpacing:R,textIndent:u,opacity:m}=e.style,f=Font$1.getFont({fontFamily:i,fontWeight:a,fontStyle:s}),y={font:f?f.data:i,color:r,opacity:m,fontSize:n,backgroundColor:o,align:l,indent:u,link:e.src,characterSpacing:R,underlineStyle:h,underline:"underline"===d,underlineColor:c||r,strike:"line-through"===d,strikeStyle:h,strikeColor:c||r,lineHeight:p?p*n:null};e.children.forEach(e=>{isImage(e)?t.push({string:String.fromCharCode(65532),attributes:{...y,attachment:{width:e.style.width||n,height:e.style.height||n,image:e.image.data}}}):isTextInstance(e)?t.push({string:transformText(e.value,g),attributes:y}):e&&t.push(...getFragments$1(e))});for(const e of PREPROCESSORS)t=e(t);return t},getAttributedString$1=e=>AttributedString.fromFragments(getFragments$1(e)),engines$1={linebreaker:linebreaker,justification:justification,textDecoration:textDecoration,scriptItemizer:scriptItemizer,wordHyphenation:wordHyphenation,fontSubstitution:fontSubstitution},engine$1=layoutEngine(engines$1),getContainer$1=(e,t,r)=>{return{x:0,y:0,width:t,maxLines:R.path(["style","maxLines"],e),height:r||1/0,truncateMode:R.path(["style","textOverflow"],e)}},getLayoutOptions=e=>({hyphenationPenalty:e.props.hyphenationPenalty,hyphenationCallback:Font$1.getHyphenationCallback(),shrinkWhitespaceFactor:{before:-.5,after:-.5}}),layoutText$1=R.compose(R.reduce(R.concat,[]),R.converge(engine$1,[getAttributedString$1,getContainer$1,getLayoutOptions])),isNotSvg=R.complement(isSvg),hasLines=e=>e.props.fixed?!R.isEmpty(e.lines):!!e.lines,shouldLayoutText=e=>isText(e)&&!hasLines(e),resolveTextLayout=e=>R.compose(R.evolve({children:R.map(R.when(isNotSvg,resolveTextLayout))}),R.when(shouldLayoutText,R.compose(R.converge(R.assoc("lines"),[R.converge(layoutText$1,[R.identity,R.path(["box","width"]),R.path(["box","height"])]),R.identity]))))(e),getInheritStyles=R.compose(R.pick(INHERITED_PROPERTIES),R.propOr({},"style")),mergeStyles$2=e=>R.evolve({style:R.merge(e)}),resolveInheritance=e=>{if(isSvg(e))return e;const t=getInheritStyles(e);return R.evolve({children:R.map(R.compose(resolveInheritance,mergeStyles$2(t)))})(e)},getComputedMargin=e=>t=>{const r=t._yogaNode;return r?r.getComputedMargin(e):null},getMargin=R.applySpec({marginTop:firstPass(getComputedMargin(Yoga.EDGE_TOP),R.path(["box","marginTop"]),R.path(["style","marginTop"]),R.path(["style","marginVertical"]),R.path(["style","margin"]),R.always(0)),marginRight:firstPass(getComputedMargin(Yoga.EDGE_RIGHT),R.path(["box","marginRight"]),R.path(["style","marginRight"]),R.path(["style","marginHorizontal"]),R.path(["style","margin"]),R.always(0)),marginBottom:firstPass(getComputedMargin(Yoga.EDGE_BOTTOM),R.path(["box","marginBottom"]),R.path(["style","marginBottom"]),R.path(["style","marginVertical"]),R.path(["style","margin"]),R.always(0)),marginLeft:firstPass(getComputedMargin(Yoga.EDGE_LEFT),R.path(["box","marginLeft"]),R.path(["style","marginLeft"]),R.path(["style","marginHorizontal"]),R.path(["style","margin"]),R.always(0))}),getTop$2=e=>e?e.getComputedTop():0,getRight=e=>e?e.getComputedRight():0,getBottom=e=>e?e.getComputedBottom():0,getLeft=e=>e?e.getComputedLeft():0,getPosition=e=>{const t=e._yogaNode;return R.applySpec({top:getTop$2,right:getRight,bottom:getBottom,left:getLeft})(t)},DEFAULT_DIMENSION={width:0,height:0},getDimension=e=>{const t=e._yogaNode;return t?{width:t.getComputedWidth(),height:t.getComputedHeight()}:DEFAULT_DIMENSION},getComputedBorder=e=>t=>t?t.getComputedBorder(e):0,getBorderWidth=e=>{const t=e._yogaNode;return R.applySpec({borderTopWidth:getComputedBorder(Yoga.EDGE_TOP),borderRightWidth:getComputedBorder(Yoga.EDGE_RIGHT),borderBottomWidth:getComputedBorder(Yoga.EDGE_BOTTOM),borderLeftWidth:getComputedBorder(Yoga.EDGE_LEFT)})(t)},setDisplay=e=>R.tap(t=>{const r=t._yogaNode;r&&r.setDisplay("none"===e?Yoga.DISPLAY_NONE:Yoga.DISPLAY_FLEX)}),setOverflow=e=>R.tap(t=>{const r=t._yogaNode;if(!R.isNil(e)&&r){const t=R.cond([[R.equals("hidden"),R.always(Yoga.OVERFLOW_HIDDEN)],[R.equals("scroll"),R.always(Yoga.OVERFLOW_SCROLL)],[R.T,R.always(Yoga.OVERFLOW_VISIBLE)]])(e);r.setOverflow(t)}}),setFlexWrap=e=>R.tap(t=>{const r=t._yogaNode;if(r){const t=R.cond([[R.equals("wrap"),R.always(Yoga.WRAP_WRAP)],[R.equals("wrap-reverse"),R.always(Yoga.WRAP_WRAP_REVERSE)],[R.T,R.always(Yoga.WRAP_NO_WRAP)]])(e);r.setFlexWrap(t)}}),isNotNil$1=R.complement(R.isNil),setYogaValue=(e,t)=>r=>R.tap(o=>{const i=o._yogaNode;if(!R.isNil(r)&&i){const o=isNotNil$1(t),a=`set${upperFirst$1(e)}`,s=`${a}Auto`,n=`${a}Percent`,l=matchPercent(r);if(l&&!i[n])throw new Error(`You can't pass percentage values to ${e} property`);l?o?i[n](t,l.value):i[n](l.value):"auto"===r?o?i[s](t):i[s]():o?i[a](t,r):i[a](r)}}),setFlexGrow=R.compose(setYogaValue("flexGrow"),R.defaultTo(0)),setFlexBasis=setYogaValue("flexBasis"),setAlign=e=>t=>R.tap(r=>{const o=r._yogaNode;if(o){const r=R.cond([[R.equals("flex-start"),R.always(Yoga.ALIGN_FLEX_START)],[R.equals("center"),R.always(Yoga.ALIGN_CENTER)],[R.equals("flex-end"),R.always(Yoga.ALIGN_FLEX_END)],[R.equals("stretch"),R.always(Yoga.ALIGN_STRETCH)],[R.equals("baseline"),R.always(Yoga.ALIGN_BASELINE)],[R.equals("space-between"),R.always(Yoga.ALIGN_SPACE_BETWEEN)],[R.equals("space-around"),R.always(Yoga.ALIGN_SPACE_AROUND)],[R.T,R.always("items"===e?Yoga.ALIGN_STRETCH:Yoga.ALIGN_AUTO)]])(t);o[`setAlign${upperFirst$1(e)}`](r)}}),setAlignSelf=setAlign("self"),setAlignItems=setAlign("items"),setFlexShrink=R.compose(setYogaValue("flexShrink"),R.defaultTo(1)),setAspectRatio=e=>R.tap(t=>{const r=t._yogaNode;!R.isNil(e)&&r&&r.setAspectRatio(e)}),setAlignContent=setAlign("content"),setPositionType=e=>R.tap(t=>{const r=t._yogaNode;!R.isNil(e)&&r&&r.setPositionType("absolute"===e?Yoga.POSITION_TYPE_ABSOLUTE:Yoga.POSITION_TYPE_RELATIVE)}),isRow=R.equals("row"),isRowReverse=R.equals("row-reverse"),isColumnReverse=R.equals("column-reverse"),setFlexDirection=e=>R.tap(t=>{const r=t._yogaNode;if(r){const t=R.cond([[isRow,R.always(Yoga.FLEX_DIRECTION_ROW)],[isRowReverse,R.always(Yoga.FLEX_DIRECTION_ROW_REVERSE)],[isColumnReverse,R.always(Yoga.FLEX_DIRECTION_COLUMN_REVERSE)],[R.T,R.always(Yoga.FLEX_DIRECTION_COLUMN)]])(e);r.setFlexDirection(t)}}),setJustifyContent=e=>R.tap(t=>{const r=t._yogaNode;if(!R.isNil(e)&&r){const t=R.cond([[R.equals("center"),R.always(Yoga.JUSTIFY_CENTER)],[R.equals("flex-end"),R.always(Yoga.JUSTIFY_FLEX_END)],[R.equals("space-between"),R.always(Yoga.JUSTIFY_SPACE_BETWEEN)],[R.equals("space-around"),R.always(Yoga.JUSTIFY_SPACE_AROUND)],[R.equals("space-evenly"),R.always(Yoga.JUSTIFY_SPACE_EVENLY)],[R.T,R.always(Yoga.JUSTIFY_FLEX_START)]])(e);r.setJustifyContent(t)}}),setMarginTop=setYogaValue("margin",Yoga.EDGE_TOP),setMarginRight=setYogaValue("margin",Yoga.EDGE_RIGHT),setMarginBottom=setYogaValue("margin",Yoga.EDGE_BOTTOM),setMarginLeft=setYogaValue("margin",Yoga.EDGE_LEFT),setPaddingTop=setYogaValue("padding",Yoga.EDGE_TOP),setPaddingRight=setYogaValue("padding",Yoga.EDGE_RIGHT),setPaddingBottom=setYogaValue("padding",Yoga.EDGE_BOTTOM),setPaddingLeft=setYogaValue("padding",Yoga.EDGE_LEFT),setBorderTop=setYogaValue("border",Yoga.EDGE_TOP),setBorderRight=setYogaValue("border",Yoga.EDGE_RIGHT),setBorderBottom=setYogaValue("border",Yoga.EDGE_BOTTOM),setBorderLeft=setYogaValue("border",Yoga.EDGE_LEFT),setPositionTop=setYogaValue("position",Yoga.EDGE_TOP),setPositionRight=setYogaValue("position",Yoga.EDGE_RIGHT),setPositionBottom=setYogaValue("position",Yoga.EDGE_BOTTOM),setPositionLeft=setYogaValue("position",Yoga.EDGE_LEFT),setWidth=setYogaValue("width"),setMinWidth=setYogaValue("minWidth"),setMaxWidth=setYogaValue("maxWidth"),setHeight=setYogaValue("height"),setMinHeight=setYogaValue("minHeight"),setMaxHeight=setYogaValue("maxHeight"),getAspectRatio=e=>e?(e.maxX-e.minX)/(e.maxY-e.minY):null,measureCanvas=(e,t,r,o,i,a)=>{const s=getAspectRatio(t.props.viewBox)||1;return o===Yoga.MEASURE_MODE_EXACTLY||o===Yoga.MEASURE_MODE_AT_MOST?{width:r,height:r/s}:a===Yoga.MEASURE_MODE_EXACTLY?{width:i*s}:{}};var measureSvg=R.curryN(6,measureCanvas);const linesWidth=e=>e.lines?Math.max(...e.lines.map(e=>AttributedString.advanceWidth(e))):-1,linesHeight=e=>e.lines?e.lines.reduce((e,t)=>e+t.box.height,0):-1,measureText=(e,t,r,o,i,a)=>o===Yoga.MEASURE_MODE_EXACTLY?(t.lines||(t.lines=layoutText$1(t,r,i)),{height:linesHeight(t)}):o===Yoga.MEASURE_MODE_AT_MOST?(t.lines||(t.lines=layoutText$1(t,r,i)),{height:linesHeight(t),width:Math.min(r,linesWidth(t))}):{};var measureText$1=R.curryN(6,measureText);const getRatio=R.ifElse(R.hasPath(["image","data"]),e=>e.image.width/e.image.height,R.always(1)),isHeightAuto=R.pathSatisfies(R.isNil,["box","height"]),SAFETY_HEIGHT=10,measureImage=(e,t,r,o,i,a)=>{const s=getRatio(t),n=getMargin(t),l=getPadding(e),p=isHeightAuto(e)?1/0:e.box.height-l.paddingTop-l.paddingBottom-n.marginTop-n.marginBottom-10;if(!t.image)return{width:0,height:0};if(o===Yoga.MEASURE_MODE_EXACTLY&&a===Yoga.MEASURE_MODE_UNDEFINED){const e=r/s;return{height:Math.min(p,e)}}if(a===Yoga.MEASURE_MODE_EXACTLY&&(o===Yoga.MEASURE_MODE_AT_MOST||o===Yoga.MEASURE_MODE_UNDEFINED))return{width:Math.min(i*s,r)};if(o===Yoga.MEASURE_MODE_EXACTLY&&a===Yoga.MEASURE_MODE_AT_MOST){const e=r/s;return{height:Math.min(i,p,e)}}return o===Yoga.MEASURE_MODE_AT_MOST&&a===Yoga.MEASURE_MODE_AT_MOST?s>1?{width:r,height:Math.min(r/s,i)}:{width:Math.min(i*s,r),height:i}:{height:i,width:r}};var measureImage$1=R.curryN(6,measureImage);const SAFETY_HEIGHT$1=10,getMax=R.reduce(R.max,-1/0),measureCtx=()=>{const e={},t=[],r=()=>e,o=(e,r)=>t.push([e,r]),i=R.compose(r,o),a=(t,r,i,a)=>(o(t,r),o(t+i,r),o(t,r+a),o(t+i,r+a),e),s=(t,r,i,a)=>(o(t-i,r-(a=a||i)),o(t+i,r-a),o(t+i,r+a),o(t-i,r+a),e);return e.rect=a,e.moveTo=i,e.lineTo=i,e.circle=s,e.polygon=((...e)=>(t.push(...e),r())),e.ellipse=s,e.roundedRect=a,e.text=r,e.path=r,e.lineWidth=r,e.bezierCurveTo=r,e.quadraticCurveTo=r,e.scale=r,e.rotate=r,e.translate=r,e.dash=r,e.clip=r,e.save=r,e.fill=r,e.font=r,e.stroke=r,e.lineCap=r,e.opacity=r,e.restore=r,e.lineJoin=r,e.fontSize=r,e.fillColor=r,e.miterLimit=r,e.strokeColor=r,e.fillOpacity=r,e.strokeOpacity=r,e.linearGradient=r,e.radialGradient=r,e.getWidth=(()=>R.compose(getMax,R.pluck(0))(t)),e.getHeight=(()=>R.compose(getMax,R.pluck(1))(t)),e},measureCanvas$1=(e,t)=>{const r=getMargin(t),o=getPadding(e),i=isHeightAuto(e)?1/0:e.box.height-o.paddingTop-o.paddingBottom-r.marginTop-r.marginBottom-10,a=measureCtx();t.props.paint(a);const s=a.getWidth();return{height:Math.min(i,a.getHeight()),width:s}};var measureCanvas$2=R.curryN(6,measureCanvas$1);const YOGA_NODE="_yogaNode",YOGA_CONFIG=Yoga.Config.create();YOGA_CONFIG.setPointScaleFactor(0);const setNodeHeight=e=>R.ifElse(isPage,setHeight(e.box.height),setHeight(e.box.height||e.style.height)),setYogaValues=R.tap(e=>{R.compose(setNodeHeight(e),setWidth(e.style.width),setMinWidth(e.style.minWidth),setMaxWidth(e.style.maxWidth),setMinHeight(e.style.minHeight),setMaxHeight(e.style.maxHeight),setMarginTop(e.style.marginTop),setMarginRight(e.style.marginRight),setMarginBottom(e.style.marginBottom),setMarginLeft(e.style.marginLeft),setPaddingTop(e.style.paddingTop),setPaddingRight(e.style.paddingRight),setPaddingBottom(e.style.paddingBottom),setPaddingLeft(e.style.paddingLeft),setPositionType(e.style.position),setPositionTop(e.style.top),setPositionRight(e.style.right),setPositionBottom(e.style.bottom),setPositionLeft(e.style.left),setBorderTop(e.style.borderTopWidth),setBorderRight(e.style.borderRightWidth),setBorderBottom(e.style.borderBottomWidth),setBorderLeft(e.style.borderLeftWidth),setDisplay(e.style.display),setFlexDirection(e.style.flexDirection),setAlignSelf(e.style.alignSelf),setAlignContent(e.style.alignContent),setAlignItems(e.style.alignItems),setJustifyContent(e.style.justifyContent),setFlexWrap(e.style.flexWrap),setOverflow(e.style.overflow),setAspectRatio(e.style.aspectRatio),setFlexBasis(e.style.flexBasis),setFlexGrow(e.style.flexGrow),setFlexShrink(e.style.flexShrink))(e)}),insertYogaNodes=e=>R.tap(t=>e.insertChild(t._yogaNode,e.getChildCount())),setMeasureFunc=e=>t=>{const r=t._yogaNode;return isText(t)&&r.setMeasureFunc(measureText$1(e,t)),isImage(t)&&r.setMeasureFunc(measureImage$1(e,t)),isCanvas(t)&&r.setMeasureFunc(measureCanvas$2(e,t)),isSvg(t)&&r.setMeasureFunc(measureSvg(e,t)),t},isNotText=R.complement(isText),isNotNote=R.complement(isNote),isNotSvg$1=R.complement(isSvg),isNotTextInstance=R.complement(isTextInstance),isLayoutElement=R.allPass([isNotText,isNotNote,isNotSvg$1]),createYogaNodes=e=>t=>{const r=Yoga.Node.createWithConfig(YOGA_CONFIG);return R.compose(setMeasureFunc(e),R.when(isLayoutElement,R.evolve({children:R.map(R.compose(insertYogaNodes(r),createYogaNodes(e)))})),setYogaValues,R.assoc(YOGA_NODE,r))(t)},calculateLayout=R.tap(e=>e._yogaNode.calculateLayout()),persistDimensions=e=>R.evolve({children:R.map(R.when(isNotTextInstance,persistDimensions)),box:R.always(R.mergeAll([getPadding(e),getMargin(e),getBorderWidth(e),getPosition(e),getDimension(e)]))})(e),destroyYogaNodes=e=>R.compose(R.dissoc(YOGA_NODE),R.tap(e=>Yoga.Node.destroy(e._yogaNode)),R.evolve({children:R.map(R.when(isLayoutElement,destroyYogaNodes))}))(e),resolvePageDimensions=e=>R.ifElse(R.isNil,R.always(null),R.compose(destroyYogaNodes,persistDimensions,calculateLayout,createYogaNodes(e)))(e),resolveDimensions=e=>R.evolve({children:R.map(resolvePageDimensions)})(e),SAFTY_THRESHOLD=.001,assingChildren=R.assoc("children"),getTop$3=R.pathOr(0,["box","top"]),getHeight=R.path(["box","height"]),getChildren$1=R.propOr([],"children"),isElementOutside=R.useWith(R.lte,[R.identity,getTop$3]),isFixed=R.pathEq(["props","fixed"],!0),allFixed=R.all(isFixed),isDynamic=R.hasPath(["props","render"]),relayoutPage=R.compose(resolveTextLayout,resolveInheritance,resolvePageDimensions),splitView=(e,t)=>{const[r,o]=splitNode(e,t),[i,a]=splitChildren(t,e);return[assingChildren(i)(r),assingChildren(a)(o)]},split=R.ifElse(isText,splitText,splitView),splitNodes=(e,t)=>{const r=[],o=[];for(let i=0;i<t.length;i++){const a=t[i],s=t.slice(i+1),n=R.filter(isFixed,s),l=getTop$3(a),p=getHeight(a),d=isElementOutside(e,a),c=shouldBreak(a,s,e),h=e+.001<l+p;if(isFixed(a))o.push(a),r.push(a);else if(d){const t=R.evolve({box:{top:R.subtract(R.__,e)}})(a);o.push(t)}else{if(c){const t=R.evolve({box:{top:R.subtract(R.__,e)},props:R.evolve({break:R.always(!1)})})(a);r.push(...n),o.push(t,...s);break}if(h){const[t,i]=split(a,e);t&&r.push(t),i&&o.push(i)}else r.push(a)}}return[r,o]},splitChildren=(e,t)=>{const r=getChildren$1(t),o=e-getTop$3(t);return splitNodes(o,r)},splitPage=(e,t)=>{const r=getContentArea(e),o=R.path(["style","height"],e),i=resolveDynamicPage({pageNumber:t},e),[a,s]=splitNodes(r,i.children),n=R.compose(relayoutPage,assingChildren(a),R.assocPath(["box","height"],o))(e);return R.isEmpty(s)||allFixed(s)?[n,null]:[n,R.compose(relayoutPage,assingChildren(s),R.dissocPath(["box","height"]))(e)]},shouldResolveDynamicNodes=e=>R.either(isDynamic,R.compose(R.any(shouldResolveDynamicNodes),R.propOr([],"children")))(e),resolveDynamicPage=(e,t)=>R.when(shouldResolveDynamicNodes,R.compose(relayoutPage,resolveDynamicNodes(e)))(t),resolveDynamicNodes=e=>t=>{const r=R.always(isDynamic(t));return R.evolve({children:R.ifElse(r,()=>{const r=t.props.render(e);return[createInstance(r)]},R.map(resolveDynamicNodes(e))),lines:R.when(r,R.always([]))},t)},paginate=(e,t)=>{if(!e)return[];let r=splitPage(e,t);const o=[r[0]];let i=r[1];for(;null!==i;)r=splitPage(i,t+o.length),o.push(r[0]),i=r[1];return o},resolvePageIndices=(e,t,r)=>{const o=r.length;return resolveDynamicPage({pageNumber:t+1,totalPages:o},e)},resolvePagination=e=>{let t=[],r=1;for(let o=0;o<e.children.length;o++){const i=e.children[o],a=paginate(i,r);r+=a.length,t=t.concat(a)}return t=t.map(resolvePageIndices),assingChildren(t,e)},removeMargins=R.compose(R.dissocPath(["style","margin"]),R.dissocPath(["style","marginTop"]),R.dissocPath(["style","marginRight"]),R.dissocPath(["style","marginBottom"]),R.dissocPath(["style","marginLeft"]),R.dissocPath(["style","marginHorizontal"]),R.dissocPath(["style","marginVertical"])),resolvePageMargins=R.evolve({children:R.map(removeMargins)}),getNodeText=e=>R.cond([[R.is(String),R.identity],[isTextInstance,R.prop("value")],[R.T,R.compose(getNodesText,R.propOr([],"children"))]])(e),getNodesText=R.compose(R.join(""),R.map(getNodeText)),wrapTextInstance=e=>[{type:"TEXT_INSTANCE",value:e}],resolveNoteChildren=e=>R.ifElse(isNote,R.evolve({children:R.compose(wrapTextInstance,getNodesText)}),R.evolve({children:R.map(resolveNoteChildren)}))(e),resolvePageHorizontalPadding=e=>t=>{const r=matchPercent(t);return r?r.percent*e.width:t},resolvePageVerticalPadding=e=>t=>{const r=matchPercent(t);return r?r.percent*e.height:t},resolvePagePaddings=e=>{const t=R.pathOr({},["props","size"],e);return R.evolve({style:R.evolve({paddingLeft:resolvePageHorizontalPadding(t),paddingRight:resolvePageHorizontalPadding(t),paddingTop:resolvePageVerticalPadding(t),paddingBottom:resolvePageVerticalPadding(t)})})(e)};var resolvePagePaddings$1=R.evolve({children:R.map(resolvePagePaddings)});const resolveRadius=e=>t=>{const r=matchPercent(t);return r?r.percent*Math.min(e.width,e.height):t},resolvePercentRadius=e=>R.evolve({children:R.map(resolvePercentRadius),style:R.evolve({borderTopLeftRadius:resolveRadius(e.box),borderTopRightRadius:resolveRadius(e.box),borderBottomRightRadius:resolveRadius(e.box),borderBottomLeftRadius:resolveRadius(e.box)})})(e),transformHeight=e=>t=>{const r=matchPercent(t);return r?r.percent*e:t},getPageArea=e=>{return R.path(["style","height"],e)-R.pathOr(0,["style","paddingTop"],e)-R.pathOr(0,["style","paddingBottom"],e)},hasHeight=R.hasPath(["style","height"]),resolveNodePercentHeight=e=>t=>{if(hasHeight(e)){const r=getPageArea(e);return R.evolve({style:{height:transformHeight(r)}})(t)}return t},resolvePagePercentHeight=e=>R.evolve({children:R.map(resolveNodePercentHeight(e))})(e),resolvePercentHeight=R.evolve({children:R.map(resolvePagePercentHeight)}),hasRenderProp=R.hasPath(["props","render"]),hasTextInstanceChilds=R.compose(R.all(isTextInstance),R.propOr([],"children")),resolveLinkSubstitution=e=>R.evolve({children:R.map(R.ifElse(R.both(isLink,R.either(hasRenderProp,hasTextInstanceChilds)),R.assoc("type",TEXT),resolveLinkSubstitution))})(e),asyncCompose=(...e)=>async t=>{for(const r of R.reverse(e))t=await r(t);return t},layout=asyncCompose(resolveZIndex,resolveRulers,resolveOrigin,resolvePagination,resolveTextLayout,resolvePercentRadius,resolveDimensions,resolveSvg,resolveAssets,resolveInheritance,resolvePercentHeight,resolvePagePaddings$1,resolveStyles$1,resolveNoteChildren,resolveLinkSubstitution,resolvePageMargins,resolvePageSizes),propsEqual=(e,t)=>{const r=Object.keys(e),o=Object.keys(t);if(r.length!==o.length)return!1;for(let o=0;o<r.length;o++){const i=r[o];if("render"!==i){if("children"!==i&&e[i]!==t[i]){if("object"==typeof e[i]&&"object"==typeof t[i]&&propsEqual(e[i],t[i]))continue;return!1}if("children"===i&&("string"==typeof e[i]||"string"==typeof t[i]))return e[i]===t[i]}else if(!e[i]!=!t[i])return!1}return!0},emptyObject={},createRenderer=({onChange:e=(()=>{})})=>ReactFiberReconciler({schedulePassiveEffects:scheduler.unstable_scheduleCallback,cancelPassiveEffects:scheduler.unstable_cancelCallback,supportsMutation:!0,isPrimaryRenderer:!1,warnsIfNotActing:!1,appendInitialChild(e,t){e.children.push(t)},createInstance:(e,{style:t,children:r,...o})=>({type:e,box:{},style:t||{},props:o||{},children:[]}),createTextInstance:(e,t)=>({type:"TEXT_INSTANCE",value:e}),finalizeInitialChildren:(e,t,r)=>!1,getPublicInstance:e=>e,prepareForCommit(){},prepareUpdate:(e,t,r,o)=>!propsEqual(r,o),resetAfterCommit:e,resetTextContent(e){},getRootHostContext:()=>emptyObject,getChildHostContext:()=>emptyObject,shouldSetTextContent:(e,t)=>!1,now:Date.now,useSyncScheduling:!0,appendChild(e,t){e.children.push(t)},appendChildToContainer(e,t){"ROOT"===e.type?e.document=t:e.children.push(t)},insertBefore(e,t,r){const o=e.children.indexOf(r);-1!==o&&t&&e.children.splice(o,0,t)},removeChild(e,t){const r=e.children.indexOf(t);-1!==r&&e.children.splice(r,1)},removeChildFromContainer(e,t){const r=e.children.indexOf(t);-1!==r&&e.children.splice(r,1)},commitTextUpdate(e,t,r){e.value=r},commitUpdate(e,t,r,o,i){const{style:a,...s}=i;e.props=s,e.style=a}}),create=e=>e,absoluteFillObject={position:"absolute",top:0,left:0,bottom:0,right:0};var StyleSheet={hairlineWidth:1,create:create,flatten:flatten,absoluteFillObject:absoluteFillObject},version="2.0.0-beta.6";const View=VIEW,Text=TEXT,Link=LINK,Page=PAGE,Note=NOTE,Image=IMAGE,Document=DOCUMENT,Canvas=CANVAS,Svg=SVG,G="G",Path=PATH,Rect=RECT,Line=LINE,Circle=CIRCLE,Ellipse=ELLIPSE,Polygon=POLYGON,Polyline=POLYLINE,Defs=DEFS,Tspan=TSPAN,ClipPath=CLIP_PATH,Stop=STOP,LinearGradient=LINEAR_GRADIENT,RadialGradient=RADIAL_GRADIENT,pdf=({initialValue:e,onChange:t})=>{const r={type:"ROOT",document:null},o=createRenderer({onChange:t}),i=o.createContainer(r);e&&s(e);const a=async()=>{const e=new PDFDocument__default({autoFirstPage:!1});console.time("layout");const t=await layout(r.document);return console.timeEnd("layout"),render(e,t)};function s(e){o.updateContainer(e,i,null)}function n(e={}){r.document.props.onRender&&r.document.props.onRender(e)}return{layout:async()=>layout(r),container:r,updateContainer:s,toBuffer:async function(){return n(),a()},toBlob:async function(){const e=(await a()).pipe(BlobStream());return new Promise((t,r)=>{e.on("finish",()=>{try{const o=e.toBlob("application/pdf");n({blob:o}),t(o)}catch(e){r(e)}}),e.on("error",r)})},toString:function(){let e="";const t=a();return new Promise((r,o)=>{try{t.on("data",function(t){e+=t}),t.on("end",function(){r(e)})}catch(e){o(e)}})}}},renderToStream=async function(e){const t=pdf({initialValue:e});return await t.toBuffer()},renderToFile=async function(e,t,r){const o=await renderToStream(e),i=fs.createWriteStream(t);return o.pipe(i),new Promise((e,a)=>{i.on("finish",()=>{r&&r(o,t),e(o)}),i.on("error",a)})},throwEnvironmentError=e=>{throw new Error(`${e} is a web specific API. Or you're either using this component on Node, or your bundler is not loading react-pdf from the appropiate web build.`)},PDFViewer=()=>{throwEnvironmentError("PDFViewer")},PDFDownloadLink=()=>{throwEnvironmentError("PDFDownloadLink")},BlobProvider=()=>{throwEnvironmentError("BlobProvider")},render$1=renderToFile;var node={pdf:pdf,View:View,Text:Text,Link:Link,Page:Page,Font:Font$1,Note:Note,Image:Image,Canvas:Canvas,Svg:Svg,G:G,Path:Path,Rect:Rect,Line:Line,Circle:Circle,Ellipse:Ellipse,Polygon:Polygon,Polyline:Polyline,Defs:Defs,Tspan:Tspan,ClipPath:ClipPath,Stop:Stop,LinearGradient:LinearGradient,RadialGradient:RadialGradient,version:version,Document:Document,StyleSheet:StyleSheet,PDFViewer:PDFViewer,BlobProvider:BlobProvider,PDFDownloadLink:PDFDownloadLink,renderToStream:renderToStream,renderToFile:renderToFile,render:render$1};exports.renderToStream=renderToStream,exports.renderToFile=renderToFile,exports.PDFViewer=PDFViewer,exports.PDFDownloadLink=PDFDownloadLink,exports.BlobProvider=BlobProvider,exports.render=render$1,exports.default=node,exports.pdf=pdf,exports.View=View,exports.Text=Text,exports.Link=Link,exports.Page=Page,exports.Font=Font$1,exports.Note=Note,exports.Image=Image,exports.Canvas=Canvas,exports.Svg=Svg,exports.G=G,exports.Path=Path,exports.Rect=Rect,exports.Line=Line,exports.Circle=Circle,exports.Ellipse=Ellipse,exports.Polygon=Polygon,exports.Polyline=Polyline,exports.Defs=Defs,exports.Tspan=Tspan,exports.ClipPath=ClipPath,exports.Stop=Stop,exports.LinearGradient=LinearGradient,exports.RadialGradient=RadialGradient,exports.version=version,exports.Document=Document,exports.StyleSheet=StyleSheet;
//# sourceMappingURL=react-pdf.cjs.min.js.map
